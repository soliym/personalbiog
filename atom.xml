<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>soliym</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://soliym.top/"/>
  <updated>2019-12-24T08:40:31.928Z</updated>
  <id>http://soliym.top/</id>
  
  <author>
    <name>soliym</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云服务器搭建web网站一</title>
    <link href="http://soliym.top/2019/12/24/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAweb%E7%BD%91%E7%AB%99%E4%B8%80/"/>
    <id>http://soliym.top/2019/12/24/云服务器搭建web网站一/</id>
    <published>2019-12-24T08:19:08.000Z</published>
    <updated>2019-12-24T08:40:31.928Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于在云服务器上搭建web服务器的过程，云服务器是百度智能云上的学生套餐，安装的是Linux的centos，下面将从云服务器的购买到搭建wordpress网站，详细介绍每一步流程</p><a id="more"></a><h3 id="一、购买云服务器"><a href="#一、购买云服务器" class="headerlink" title="一、购买云服务器"></a>一、购买云服务器</h3><p>在百度云购买云服务器，学生8元/月，操作系统Linux，入门级服务器，在腾讯云中也有学生优惠套餐，10元/月，服务器在哪都可以，重点是操作系统，本文以centos7.2位例</p><h3 id="二、登录云服务器"><a href="#二、登录云服务器" class="headerlink" title="二、登录云服务器"></a>二、登录云服务器</h3><h5 id="1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录"><a href="#1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录" class="headerlink" title="1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录"></a>1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录</h5><h5 id="2、通过浏览器的VNC远程登录"><a href="#2、通过浏览器的VNC远程登录" class="headerlink" title="2、通过浏览器的VNC远程登录"></a>2、通过浏览器的VNC远程登录</h5><h5 id="3、通过Xshell登录"><a href="#3、通过Xshell登录" class="headerlink" title="3、通过Xshell登录"></a>3、通过Xshell登录</h5><p>1）通过公网IP地址登录</p><p>2）查看Linux版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# cat /etc/centos-release</span><br><span class="line">CentOS Linux release 7.2.1511 (Core)</span><br></pre></td></tr></table></figure><h3 id="三、云服务器配置"><a href="#三、云服务器配置" class="headerlink" title="三、云服务器配置"></a>三、云服务器配置</h3><h5 id="1、查看是否安装httpd-Apache-及软件包管理器yum"><a href="#1、查看是否安装httpd-Apache-及软件包管理器yum" class="headerlink" title="1、查看是否安装httpd(Apache)及软件包管理器yum"></a>1、查看是否安装httpd(Apache)及软件包管理器yum</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx /]# rpm -ql httpd    </span><br><span class="line">[root@instance-3naulqbx /]# rpm -ql yum</span><br></pre></td></tr></table></figure><h5 id="2、安装httpd，如果安装则跳过"><a href="#2、安装httpd，如果安装则跳过" class="headerlink" title="2、安装httpd，如果安装则跳过"></a>2、安装httpd，如果安装则跳过</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx /]# yum install httpd</span><br></pre></td></tr></table></figure><h5 id="3、重启httpd服务"><a href="#3、重启httpd服务" class="headerlink" title="3、重启httpd服务"></a>3、重启httpd服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# systemctl restart httpd</span><br></pre></td></tr></table></figure><h5 id="4、在浏览器中测试"><a href="#4、在浏览器中测试" class="headerlink" title="4、在浏览器中测试"></a>4、在浏览器中测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://你的公网IP地址</span><br></pre></td></tr></table></figure><p>如果显示Apache的欢迎界面，则配置成功，那么web服务的基础配置完成</p><h3 id="四、网站搭建"><a href="#四、网站搭建" class="headerlink" title="四、网站搭建"></a>四、网站搭建</h3><h4 id="1、静态网站"><a href="#1、静态网站" class="headerlink" title="1、静态网站"></a>1、静态网站</h4><p>/var/www/html目录下创建index.html文件，该文件是web网站访问的默认访问页面，如果有该文件，则客户端访问该页面，没有则访问Apache的欢迎界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# vim /var/www/html/index.html</span><br></pre></td></tr></table></figure><p>在文件中写入helloworld</p><p>-—————————</p><p>关于vim的操作，可以去学习一下，在网站部署中会经常用到，一般操作，按I 编辑文件，按esc回到命令模式，然后Ctrl+：进入到末行模式，输入wq 保存退出</p><p>-—————————</p><p>静态网站就搭建完成，可以通过前端修改index.html</p><h4 id="2、wordpress网站搭建"><a href="#2、wordpress网站搭建" class="headerlink" title="2、wordpress网站搭建"></a>2、wordpress网站搭建</h4><p>LAMP=Linux+Apache+mariadb+php</p><p>以上表示Linux服务器搭建动态网站需要的四种工具</p><p>操作系统Linux、Web服务平台Apache、数据库mariadb（MySQL）、PHP脚本语言</p><p>因此，在服务器中必须包含四种工具，前面已经安装了前两个，接下来安装后两个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# yum install php* -y</span><br><span class="line">[root@instance-3naulqbx test]# yum install -y mariadb-server.x86_64</span><br></pre></td></tr></table></figure><p>安装完以后重启mariadb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# systemctl restart mariadb</span><br></pre></td></tr></table></figure><h5 id="（1）上传WordPress源码"><a href="#（1）上传WordPress源码" class="headerlink" title="（1）上传WordPress源码"></a>（1）上传WordPress源码</h5><p>1）在/下创建一个test目录，用来存放web程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx ~]# mkdir /test</span><br></pre></td></tr></table></figure><p>2）使用xshell上传源码到服务器</p><p>打开xftp，进入到xftp界面，左边为自己主机，右边为服务器，找到test目录，将web程序拖拽到服务器的方框内，上传完成后，在服务器中查看</p><h5 id="（2）配置MySQL数据库"><a href="#（2）配置MySQL数据库" class="headerlink" title="（2）配置MySQL数据库"></a>（2）配置MySQL数据库</h5><p>1）初始化数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# mysql_secure_installation</span><br></pre></td></tr></table></figure><p>一直回车就可以</p><p>2）创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# mysql -uroot -proot</span><br></pre></td></tr></table></figure><p>创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; create database wordpress;</span><br></pre></td></tr></table></figure><p>通过show查看是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show databases;</span><br></pre></td></tr></table></figure><p>注意每条命令后的’;’，输入quit退出</p><p>然后重启数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# systemctl restart mariadb.service</span><br></pre></td></tr></table></figure><h5 id="（3）解压web程序"><a href="#（3）解压web程序" class="headerlink" title="（3）解压web程序"></a>（3）解压web程序</h5><p>进入网站的默认文档目录下，删除index.html文件，然后将web程序移动到该目录下解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# cd /var/www/html</span><br><span class="line">[root@instance-3naulqbx html]# mv /test/wordpress-4.7.4-zh_CN.zip  /var/www/html</span><br><span class="line">[root@instance-3naulqbx html]# unzip wordpress-4.7.4-zh_CN.zip</span><br></pre></td></tr></table></figure><h5 id="（4）测试"><a href="#（4）测试" class="headerlink" title="（4）测试"></a>（4）测试</h5><p>在网站中输入公网IP/wordpress,如果出现WordPress的安装界面，则安装成功</p><p>可能出现的问题：</p><p>1）如果不出现安装界面，但是出现“Index of /wordpress”界面，可能是PhP或者mysql没有安装成功，检查重装。</p><p>2）出现“您的PHP似乎没有安装运行WordPress所必需的MySQL扩展”提示，可用通过安装php-mysql解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx wordpress]# yum install php-mysql</span><br></pre></td></tr></table></figure><p>（5）安装wordpress</p><p>1）数据库名为服务器创建的数据库名</p><p>2）用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx test]# mysql -uroot -proot</span><br></pre></td></tr></table></figure><p>-u后为用户名</p><p>-p后为 密码</p><p>3）其他默认</p><p>4）配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx wordpress]# vim wp-config.php</span><br></pre></td></tr></table></figure><p>根据提示建立wp-config.php文件</p><h5 id="（6）安装完成"><a href="#（6）安装完成" class="headerlink" title="（6）安装完成"></a>（6）安装完成</h5><p>如果成功进入到wrodpress界面，那么安装成功，但是在访问该界面时，还是通过IP访问，我们通常都是通过域名访问的，下一节将介绍通过域名访问并且是https访问</p><h5 id="（7）关于wrodpress"><a href="#（7）关于wrodpress" class="headerlink" title="（7）关于wrodpress"></a>（7）关于wrodpress</h5><p>wrodpress中有许多主题和插件，但是下载需要ftp服务，下面提供一个解决方法，可以不用ftp服务就可以在线更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx wordpress]# vim wp-config.php </span><br><span class="line">  define(&quot;FS_METHOD&quot;, &quot;direct&quot;);</span><br><span class="line">  define(&quot;FS_CHMOD_DIR&quot;, 0777);</span><br><span class="line">  define(&quot;FS_CHMOD_FILE&quot;, 0777);</span><br></pre></td></tr></table></figure><p>打开wp-cinfig.php文件，将这三行添加在最后并且修改wordpress的权限为777</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-3naulqbx html]# chmod 777 -R wordpress/</span><br></pre></td></tr></table></figure><p>由于wrodpress官方服务器的问题，现在会出现 “too many  Request”问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于在云服务器上搭建web服务器的过程，云服务器是百度智能云上的学生套餐，安装的是Linux的centos，下面将从云服务器的购买到搭建wordpress网站，详细介绍每一步流程&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://soliym.top/categories/Linux/"/>
    
    
      <category term="Web服务器" scheme="http://soliym.top/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>internet校验和的增量更新</title>
    <link href="http://soliym.top/2019/12/05/internet%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%9A%84%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    <id>http://soliym.top/2019/12/05/internet校验和的增量更新/</id>
    <published>2019-12-05T14:25:59.000Z</published>
    <updated>2019-12-05T14:57:22.113Z</updated>
    
    <content type="html"><![CDATA[<p>在IP协议中，首部格式中有一个首部校验和字段，该字段采用的校验方法与常用的奇偶校验和循环冗余校验不同，下面将详细介绍这种方法，以及它所遇到的问题及解决方案</p><a id="more"></a><h3 id="一、校验方法"><a href="#一、校验方法" class="headerlink" title="一、校验方法"></a>一、校验方法</h3><p>IP首部的校验方法：</p><p>只校验首部不校验数据部分</p><p>发送方：将校验和字段置为0，然后将首部以2字节为一组，以二进制反码的形式相加，将其结果取反码后，写入到IP数据报的首部校验和字段。</p><p>接受方：与发送方的操作相似，收到数据报后，将首部以2字节16bit为一组，以二进制反码的形式相加，如果结果为1，则表示该数据报的首部在传输中没有差错，否则出现差错。</p><p>该方法在TCP/IP协议中有很多协议都会用到，比如TCP、UDP，不同的是，TCP、UDP添加了12字节的伪首部</p><h3 id="二、存在的问题"><a href="#二、存在的问题" class="headerlink" title="二、存在的问题"></a>二、存在的问题</h3><p>在TCP、UDP存在的问题是这种检错的方法并不可靠，但是它简单、效率高，在TCP、UDP中并没有什么太大的缺陷，而在IP数据报中，因为IP数据报是基于第三层网络层转发的，因此，会频繁的对IP数据报修改，比如IP协议中的TTL值，每经过一个路由器都要减去1，该值都要发生变化，对应校验和也要发生变化，而源数据只发生了很小的一次变化，就要重新计算校验和，这大大降低了路由器的转发速率。</p><p>在RFC1141文档中提供了一种解决方法：增量更新</p><p>即在原始值只发生了很小的变化，可以对校验和做出很小的改变，而不用重新计算校验和</p><h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><p>原始校验和C，以及字节m的旧值和新值：</p><p>​         C’= C +（-m）+ m’= C +（m’-m）</p><p>虽然该公式更新了校验和C，但是没更新校验和的反码</p><p> 〜C’=〜（C +（-m）+ m’）=〜C +（m-m’）=〜C + m +〜m’</p><p>C语言代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*implemented according with RFC 1071 and1141*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">csum_incremental_update</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> old_csum,</span></span></span><br><span class="line"><span class="function"><span class="params">​                <span class="keyword">unsigned</span> <span class="keyword">short</span> old_field,</span></span></span><br><span class="line"><span class="function"><span class="params">​                <span class="keyword">unsigned</span> <span class="keyword">short</span> new_field)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> csum = old_csum + old_field + (~new_field &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">   csum = (csum &gt;&gt; <span class="number">16</span>) + (csum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">   csum +=  (csum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">   <span class="keyword">return</span> csum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在IP协议中，首部格式中有一个首部校验和字段，该字段采用的校验方法与常用的奇偶校验和循环冗余校验不同，下面将详细介绍这种方法，以及它所遇到的问题及解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://soliym.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络层" scheme="http://soliym.top/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Http与Https的区别和加密原理</title>
    <link href="http://soliym.top/2019/12/02/Http%E4%B8%8EHttps%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
    <id>http://soliym.top/2019/12/02/Http与Https的区别和加密原理/</id>
    <published>2019-12-02T13:24:38.000Z</published>
    <updated>2019-12-02T13:30:35.557Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP与HTTPS的区别及工作过程  </p><a id="more"></a>                                                          <h3 id="一、HTTP介绍"><a href="#一、HTTP介绍" class="headerlink" title="一、HTTP介绍"></a>一、HTTP介绍</h3><h4 id="1、什么是HTTP"><a href="#1、什么是HTTP" class="headerlink" title="1、什么是HTTP"></a>1、什么是HTTP</h4><p>（一）HTTP（Hypertext Transfer Protocol）：超文本传输协议</p><p>一种建立在TCP上的无状态连接的应用层协议，HTTP是WWW的数据交互的基础，超文本文档包括超链接链接到其他资源用户可以很容易获取。HTTP发展用来促进超文本和WWW。所谓协议，就是指双方遵循的规则、约定。http协议，就是浏览器和服务器之间进行通信的一种规规则。</p><p>（二）TCP-IP详解对HTTP的概述</p><p>H T T P是一个简单的协议。客户进程建立一条同服务器进程的 T C P连接，然后发出请求并读取服务器进程的响应。服务器进程关闭连接表示本次响应结束。服务器进程返回的文件通常含有指向其他服务器上文件的指针 (超文本链接)。用户显然可以很轻松地沿着这些链接从一 个服务器到下一个服务器。 </p><h4 id="2、HTTP特点"><a href="#2、HTTP特点" class="headerlink" title="2、HTTP特点"></a>2、HTTP特点</h4><p>1、简单：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的不同类型。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>3、请求-响应模式：客户端每次向服务器发起一个请求时都建立一个连接， 服务器处理完客户的请求即断开连接。</p><p>4、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 </p><h4 id="3、HTTP工作过程"><a href="#3、HTTP工作过程" class="headerlink" title="3、HTTP工作过程"></a>3、HTTP工作过程</h4><h5 id="（一）概述"><a href="#（一）概述" class="headerlink" title="（一）概述"></a>（一）概述</h5><p>HTTP客户端发起请求，创建端口。</p><p>HTTP服务器在端口监听客户端请求。</p><p>HTTP服务器向客户端返回状态和内容</p><h5 id="（二）详解"><a href="#（二）详解" class="headerlink" title="（二）详解"></a>（二）详解</h5><h6 id="1、输入地址后回车，首先执行域名解析"><a href="#1、输入地址后回车，首先执行域名解析" class="headerlink" title="1、输入地址后回车，首先执行域名解析"></a>1、输入地址后回车，首先执行域名解析</h6><p>（1）查询浏览器自身的DNS缓冲</p><p>（2）如果缓冲失效则查找系统的DNS缓冲</p><p>（3）如果系统DNS缓冲没有查到则查看本地Host文件</p><p>（4）如果找不到配置则浏览器发起DNS系统调用</p><p>（5）主机向DNS服务器发起查询，获取IP地址</p><h6 id="2、连接并进行通信"><a href="#2、连接并进行通信" class="headerlink" title="2、连接并进行通信"></a>2、连接并进行通信</h6><p>（1）浏览器获得域名对应的IP地址后，发起TCP“三次握手”</p><p>（2）TCP/IP连接建立起来后，浏览器就可以向服务器发送http请求</p><p>（3）服务器接收到这个请求，根据路径参数，经过后端的一些处理之后，把处理后的一个结果的数据返回给浏览器</p><h6 id="3、浏览器渲染页面"><a href="#3、浏览器渲染页面" class="headerlink" title="3、浏览器渲染页面"></a>3、浏览器渲染页面</h6><h6 id="4、HTTP的不足"><a href="#4、HTTP的不足" class="headerlink" title="4、HTTP的不足"></a>4、HTTP的不足</h6><p>（一）安全性</p><p>​      （1）HTTP使用明文通信，内容可能窃取</p><p>​      （2）不验证通信方的身份，因此有可能遭遇伪装</p><p>​      （3）无法证明报文的完整性，有可能已遭篡改</p><p>（二）响应时间长</p><p>​      （1）基于TCP工作，可靠但是速度慢</p><p>​      （2）HTTP协议是无状态协议，传输完成后断开TCP连接，下一次的请求需要重新建立连接</p><p>（三）臃肿的消息首部</p><h3 id="二、HTTP的改进-HTTPS"><a href="#二、HTTP的改进-HTTPS" class="headerlink" title="二、HTTP的改进-HTTPS"></a>二、HTTP的改进-HTTPS</h3><p>Https并不是一个崭新的协议，而是在http的基础上发展而来相当于是Http的升级版。它主要是为了解决http协议安全性不足的问题而诞生的。HTTPS 就是在 HTTP 下加入了 SSL 层，从而保护了交换数据隐私和完整性，提供对网站服务器身份认证的功能，简单来说它就是安全版的 HTTP。</p><p>Http+加密+认证+完整性保护=https</p><p>Https的通信端口由SSL/TSL代替了，它是一种应用层协议。一般的情况下http直接和Tcp进行通信，当使用了SSL之后，就会变成先和SSL通信，SSL再和TCP进行通信。</p><h3 id="三、HTTPS采用的加密技术"><a href="#三、HTTPS采用的加密技术" class="headerlink" title="三、HTTPS采用的加密技术"></a>三、HTTPS采用的加密技术</h3><h4 id="（一）对称密钥加密"><a href="#（一）对称密钥加密" class="headerlink" title="（一）对称密钥加密"></a>（一）对称密钥加密</h4><p> SSL采用的加密技术叫做“单密钥加密”，也叫作“对称密钥加密”，这种加密方法是这样的，比如客户端向服务器发送一条信息，首先客户端会采用已知的算法对信息进行加密，接收端对加密的信息进行解密的时候需要用到密钥，中间会传递密钥，（加密和解密的密钥是同一个），密钥在传输中间是被加密的。这种方式看起来安全，但是仍有潜在的危险，一旦被窃听，或者信息被挟持，就有可能破解密钥，而破解其中的信息，这种方式存在安全隐患。</p><h4 id="（二）非对称密钥加密"><a href="#（二）非对称密钥加密" class="headerlink" title="（二）非对称密钥加密"></a>（二）非对称密钥加密</h4><p>“非对称加密”使用的时候有两把锁，一把叫做“私钥”，一把是“公钥”，使用非对称加密的加密方式的时候，服务器首先告诉客户端按照自己给定的公开密钥进行加密处理，客户端按照公开密钥加密以后，服务器接受到信息再通过自己的私有密钥进行解密，这样做的好处就是解密的钥匙根本就不会进行传输，因此也就避免了被挟持的风险。就算公开密钥被窃听者拿到了，它也很难进行解密。</p><h3 id="四、HTTPS通信加密机制"><a href="#四、HTTPS通信加密机制" class="headerlink" title="四、HTTPS通信加密机制"></a>四、HTTPS通信加密机制</h3><h4 id="（一）HTTPS采用混合机制的加密方式"><a href="#（一）HTTPS采用混合机制的加密方式" class="headerlink" title="（一）HTTPS采用混合机制的加密方式"></a>（一）HTTPS采用混合机制的加密方式</h4><p>https则综合了对称密钥加密和非对称密钥加密的两种方式，充分利用两者的优势，在最初的连接的时候使用非对称密钥的加密方式保证连接的安全性，之后稳定的通讯采用对称加密的方式，稳定的通讯是指确保交换的密钥是安全的。</p><p>某网站拥有用于非对称加密的公钥A、私钥A’，浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器，浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器，服务器拿到后用私钥A’解密得到密钥X，这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。</p><p>虽然这种加密方式比对称加密和非对称加密安全，但是还是存在漏洞，某网站拥有用于非对称加密的公钥A、私钥A’，浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器，中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’），浏览器随机生成一个用于对称加密的密钥X，用公钥B（浏览器不知道公钥被替换了）加密后传给服务器，中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器，服务器拿到后用私钥A’解密得到密钥X</p><p>为了应对这种漏洞，HTTPS加入了一种新的安全机制，证书认证</p><h4 id="（二）https的证书机制"><a href="#（二）https的证书机制" class="headerlink" title="（二）https的证书机制"></a>（二）https的证书机制</h4><p>1、服务器的开发者携带公开密钥，向数字证书认证机构提出公开密钥的申请，数字证书认证机构在认清申请者的身份，审核通过以后，会对开发者申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将密钥放在证书里面，绑定在一起</p><p>2、服务器将这份数字证书发送给客户端，因为客户端也认可证书机构，客户端可以通过数字证书中的数字签名来验证公钥的真伪，来确保服务器传过来的公开密钥是真实的。一般情况下，证书的数字签名是很难被伪造的，这取决于认证机构的公信力。一旦确认信息无误之后，客户端就会通过公钥对报文进行加密发送，服务器接收到以后用自己的私钥进行解密。</p><h3 id="五、SSL-TLS"><a href="#五、SSL-TLS" class="headerlink" title="五、SSL/TLS"></a>五、SSL/TLS</h3><p>SSL(Secure Sockets Layer <a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82" target="_blank" rel="noopener">安全套接层</a>),及其继任者<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">传输层安全</a>（Transport Layer Security，TLS）是为<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548" target="_blank" rel="noopener">网络通信</a>提供安全及<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/110071" target="_blank" rel="noopener">数据完整性</a>的一种安全协议。TLS与SSL在<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536" target="_blank" rel="noopener">传输层</a>对网络连接进行加密。</p><p>SSL是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密，所以HPPTS是HTTP+SSL/TCP的简称。</p><p>标准化后的SSL更名为TLS(Transport Layer Security 安全传输层协议)</p><h4 id="（一）SSL协议"><a href="#（一）SSL协议" class="headerlink" title="（一）SSL协议"></a>（一）SSL协议</h4><p>SSL协议是一个分层的协议，共有两层组成。处于SSL协议的底层的是SSL记录层协议(SSL Record Protocol)，它位于可靠的传输层协议(如TCP)之上，用于封装高层协议的数据。其中SSL握手协议(SSL Handshake Protocol)允许服务方和客户方互相认证，并在应用层协议传送数据之前协商出一个加密算法和会话密钥。</p><p>SSL协议实现的安全机制包括：</p><p>数据传输的机密性：利用对称密钥算法对传输的数据进行加密。</p><p>身份验证机制：基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。</p><p>消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性。</p><h4 id="（二）加密算法"><a href="#（二）加密算法" class="headerlink" title="（二）加密算法"></a>（二）加密算法</h4><h5 id="1、散列函数Hash"><a href="#1、散列函数Hash" class="headerlink" title="1、散列函数Hash"></a>1、散列函数Hash</h5><p>常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性。</p><h5 id="2、对称加密"><a href="#2、对称加密" class="headerlink" title="2、对称加密"></a>2、对称加密</h5><p>常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听。</p><h5 id="3、非对称加密"><a href="#3、非对称加密" class="headerlink" title="3、非对称加密"></a>3、非对称加密</h5><p>即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。</p><h3 id="六、SSL-TSL握手过程"><a href="#六、SSL-TSL握手过程" class="headerlink" title="六、SSL/TSL握手过程"></a>六、SSL/TSL握手过程</h3><p>（一）客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息</p><p>（二）服务端返回协商的信息结果，包括选择使用的协议版本，选择的加密套件 ，选择的压缩算法、随机数等，其中随机数用于后续的密钥协商;服务器端配置对应的证书链，用于身份验证与密钥交换</p><p>（三）证书校验，客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作</p><p>（四）合法性验证通过之后，客户端计算产生随机数字 Pre-master，并用证书公钥加密，发送给服务器</p><p>（五）服务器用私钥解密加密的数据，基于之前交换的两个明文随机数，计算得到协商密钥，计算之前所有接收信息的 hash 值，验证数据和密钥正确性;</p><p>（六）握手结束</p><h3 id="七、HTTPS工作流程"><a href="#七、HTTPS工作流程" class="headerlink" title="七、HTTPS工作流程"></a>七、HTTPS工作流程</h3><h4 id="（一）建立连接"><a href="#（一）建立连接" class="headerlink" title="（一）建立连接"></a>（一）建立连接</h4><p>1.服务端首先把自己的公钥（Key1）发给证书颁发机构，向证书颁发机构申请证书。</p><p>2.证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端。</p><p>3.当客户端向服务端请求通信的时候，服务端不再直接返回自己的公钥（Key1），而是把自己申请的证书返回给客户端。</p><p>4.客户端收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以客户端只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名，客户端对证书验证成功后，就可以放心地再次利用机构公钥，解密出服务端的公钥Key1。</p><ol start="5"><li><p>客户端生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给服务端。</p></li><li><p>服务端用自己的私钥解开加密，得到对称加密密钥Key2。于是客户端与服务端开始用Key2进行对称加密的通信。</p></li></ol><h4 id="（二）数据传输"><a href="#（二）数据传输" class="headerlink" title="（二）数据传输"></a>（二）数据传输</h4><ol><li><p>对应用层数据进行分片成合适的 block</p></li><li><p>为分片数据编号，防止重放攻击</p></li><li><p>使用协商的压缩算法压缩数据</p></li><li><p>计算 MAC 值和压缩数据组成传输数据</p></li><li><p>使用 key 加密数据，发送给服务器</p></li><li><p>服务器收到数据之后使用key解密，校验数据，解压缩数据，重新组装</p></li></ol><h3 id="八、HTTP与HTTPS的不同"><a href="#八、HTTP与HTTPS的不同" class="headerlink" title="八、HTTP与HTTPS的不同"></a>八、HTTP与HTTPS的不同</h3><p>(1) HTTPS是加密传输协议，HTTP是明文传输协议</p><p>(2) HTTPS需要用到SSL证书，而HTTP不用</p><p>(3) HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO</p><p>(4) HTTPS标准端口443，HTTP标准端口80</p><p>(5) HTTPS基于传输层，HTTP基于应用层</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP与HTTPS的区别及工作过程  &lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>单钥密码体制三</title>
    <link href="http://soliym.top/2019/12/01/%E5%8D%95%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E4%B8%89/"/>
    <id>http://soliym.top/2019/12/01/单钥密码体制三/</id>
    <published>2019-12-01T05:09:52.000Z</published>
    <updated>2019-12-01T05:33:51.432Z</updated>
    
    <content type="html"><![CDATA[<p>下面介绍我国的商用分组密码SM4及单钥密码中的分组密码</p><a id="more"></a><h3 id="一、SM4的特点"><a href="#一、SM4的特点" class="headerlink" title="一、SM4的特点"></a>一、SM4的特点</h3><p>1、</p><p>数据分组长度=128位、密钥长度=128位 </p><p>数据处理单位：字节（ 8位），字（32位） </p><p>2、</p><p>基本轮函数加迭代 </p><p>解密算法与加密算法相同-密钥使用顺序不同</p><h3 id="二、SM4-密码算法基本运算"><a href="#二、SM4-密码算法基本运算" class="headerlink" title="二、SM4 密码算法基本运算"></a>二、SM4 密码算法基本运算</h3><h4 id="1、SM4使用模2加和循环移位运算"><a href="#1、SM4使用模2加和循环移位运算" class="headerlink" title="1、SM4使用模2加和循环移位运算"></a>1、SM4使用模2加和循环移位运算</h4><p>1）模2加：⊕，32 比特异或运算 </p><p>2）循环移位：<em>&lt;&lt;&lt; i</em> <em>，</em>把32位字循环左移<em>i</em> 位</p><h4 id="2、代换运算：S盒"><a href="#2、代换运算：S盒" class="headerlink" title="2、代换运算：S盒"></a>2、代换运算：S盒</h4><p>起混淆作用，输入8bit序列，输出8bit序列</p><p>运算规则根据s盒代换</p><h4 id="3、非线性变换"><a href="#3、非线性变换" class="headerlink" title="3、非线性变换"></a>3、非线性变换</h4><p>由4个并行的S盒构成，输入x1,x2,x3,x4,输出y1,y2,y3,y4</p><p>运算规则根据s盒代换</p><h4 id="4、线性变换"><a href="#4、线性变换" class="headerlink" title="4、线性变换"></a>4、线性变换</h4><p>起扩散作用，输入32bit，输出32bit，循环移位</p><p>L(B)=B^(B&lt;&lt;&lt;2)^(B&lt;&lt;&lt;10)^(B&lt;&lt;&lt;18)^(B&lt;&lt;&lt;24)</p><h4 id="5、合成变换"><a href="#5、合成变换" class="headerlink" title="5、合成变换"></a>5、合成变换</h4><p>由非线性变换和线性变换复合而成</p><h4 id="6、轮函数"><a href="#6、轮函数" class="headerlink" title="6、轮函数"></a>6、轮函数</h4><p>轮函数运算式：F(x0,x1,x2,x3,rk)=x0^T(x1^x2^x3^rk)</p><p>T函数本质上分两步：一是S盒非线性变换，另一个是线性移位。 </p><h3 id="三、加密流程"><a href="#三、加密流程" class="headerlink" title="三、加密流程"></a>三、加密流程</h3><h4 id="加密与解密流程图"><a href="#加密与解密流程图" class="headerlink" title="加密与解密流程图"></a>加密与解密流程图</h4><p><img src="/2019/12/01/单钥密码体制三/01.png" alt="01"></p><h4 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h4><p><img src="/2019/12/01/单钥密码体制三/02.png" alt="02"></p><h3 id="四、加密步骤"><a href="#四、加密步骤" class="headerlink" title="四、加密步骤"></a>四、加密步骤</h3><h4 id="1、明文分组"><a href="#1、明文分组" class="headerlink" title="1、明文分组"></a>1、明文分组</h4><p>SM4算法分组长度为128bit，也就是16个字节，如果SM4算法分组长度为128bit，也就是16个字节，如果明文字节数不是16的整数倍，仍然采取补0凑足128位的方法。</p><p>将明文转换成二进制，然后以128bit分组。</p><h4 id="2、明文组分组"><a href="#2、明文组分组" class="headerlink" title="2、明文组分组"></a>2、明文组分组</h4><p>将128bit的明文组均分为各32bit的子组。</p><h4 id="3、合成变换"><a href="#3、合成变换" class="headerlink" title="3、合成变换"></a>3、合成变换</h4><p><img src="/2019/12/01/单钥密码体制三/03.png" alt="03"></p><p>非线性变换S盒置换规则：</p><p>SM4中利用了4个完全相同的S盒，每个S盒对应8位的输入和8位的输出</p><p>以输入的前半字节为行号，后半字节为列号，行列交叉点处的数据即为输出</p><p>线性变换循环移位加：</p><p>运算规则： </p><p>C=L（B）<em>=B</em>⊕(<em>B</em>&lt;&lt;&lt;2)⊕(<em>B</em>&lt;&lt;&lt;10)⊕(<em>B</em>&lt;&lt;&lt;18) ⊕(<em>B</em>&lt;&lt;&lt;24)</p><p>流程：X1,x2,x3,rk先异或输出32bit数，然后非线性变换，由四个并行的s盒置换，输出32bit数，在经线性变换，输出32bit数</p><h4 id="4、轮函数"><a href="#4、轮函数" class="headerlink" title="4、轮函数"></a>4、轮函数</h4><p>X0&lt;-x1,x1&lt;-x2,x2&lt;-x3,x3-&lt;x0^T(x1^x2^x3^rk)</p><h4 id="5、反序变换"><a href="#5、反序变换" class="headerlink" title="5、反序变换"></a>5、反序变换</h4><p>R（x32,x33,x34,x35）=（x35,x34,x33,x32）</p><h3 id="五、密钥生成"><a href="#五、密钥生成" class="headerlink" title="五、密钥生成"></a>五、密钥生成</h3><p><img src="/2019/12/01/单钥密码体制三/04.png" alt="04"></p><p>1、系统参数FK</p><p>2、固定参数CK</p><p>1、初始密钥MK分为4X32=128bit</p><p>2、MK与FK异或得到K</p><p>3、32轮函数变换得到32个子密钥，轮函数与加密过程基本相同，只是将线性变换修改为</p><p><em>L<strong>(</strong>B<strong>)=</strong>B</em>⊕<em>(<strong>B</strong>&lt;&lt;&lt;</em> <em>13**)</em>⊕<em>(<strong>B</strong>&lt;&lt;&lt;</em> <em>23<strong>)</strong>,<strong>加密函数中用到的是密钥，而密钥扩展算法中用到的是</strong>32bit<strong>固定参数</strong>CK</em></p><h3 id="六、安全性"><a href="#六、安全性" class="headerlink" title="六、安全性"></a>六、安全性</h3><p>①国家专业机构设计。算法简洁，以字和字节为处理单位，对称运算，符合当今分组密码主流。 </p><p>②专业机构进行了密码分析，因此是安全的。 </p><p>③民间学者对21轮SM4进行了差分密码分析。 </p><p>④尚需经过实践检验。</p><h3 id="七、流密码"><a href="#七、流密码" class="headerlink" title="七、流密码"></a>七、流密码</h3><h4 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h4><p>流密码：将明文划分成字符，或其编码的基本单元，字符分别与密钥流作用进行加密，解密时以同步产生的同样的密钥流实现。流密码强度完全依赖于密钥所产生的序列的随机性和不可预测性。</p><p>如果密码序列是一个非周期序列，那么可以做到一次一密体制，一次一密可以实现无条件安全。</p><h4 id="ZUC算法"><a href="#ZUC算法" class="headerlink" title="ZUC算法"></a>ZUC算法</h4><p>ZUC本质上一个密钥序列产生的算法，其输入为128bit的初始密钥和128比特的初始向量，输出为32比特的密钥字序列，其逻辑上分为三层，分别是：16级线性反馈移位寄存器（LFSR），比特重组（BR），非线性函数F。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面介绍我国的商用分组密码SM4及单钥密码中的分组密码&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>AES列混淆机制详解</title>
    <link href="http://soliym.top/2019/11/25/AES%E5%88%97%E6%B7%B7%E6%B7%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://soliym.top/2019/11/25/AES列混淆机制详解/</id>
    <published>2019-11-25T09:04:37.000Z</published>
    <updated>2019-11-25T10:23:29.069Z</updated>
    
    <content type="html"><![CDATA[<p>在AES中列混淆是比较重要的一步，在列混淆的设计中，设计的算法思想及运算机制是非常值得学习，它包括多项式相乘的处理，以及十六进制乘法中的Xtime机制</p><a id="more"></a><h3 id="一、多项式"><a href="#一、多项式" class="headerlink" title="一、多项式"></a>一、多项式</h3><p>在AES中列混淆是将矩阵的每一列通过运算得到一列新的值，这个运算即使矩阵相乘，将行位移后的矩阵的列，表示为多项式，该多项式有4个项，最高项的次幂为3，多项式系数为矩阵的列值，按列值的行号等于每一项的次幂，得到一个多项式，记为s(x)；</p><p>在固定给出一个多项式，该多项式与s(x)一样，同为最高项的幂为3，该多项式的系数是固定的，这里记为c(x)；</p><p>那么通过两多项式相乘可以得到一个多项式f(x)，但是这个多项式并不是一个最高次幂是3的多项式，因此需要对该多项式取余，即模X^4+1;</p><p>因为x^4+1在F2上约等于(x+1)^4,模一个4次多项式是为了得到一个三次多项式。</p><p>即：X^(i)mod(X^4+1)=X^(imod4)</p><h3 id="二、多项式相乘"><a href="#二、多项式相乘" class="headerlink" title="二、多项式相乘"></a>二、多项式相乘</h3><p>计算两个多项式相乘并不是容易的事，但是可以通过的矩阵的运算，直接求解f(x)的系数</p><p>可以得到：x^3的系数为s3c0+s2c1+s1c2+s0c3，通过验证，多项式的系数可以通过两个矩阵相乘得出，两个矩阵由s(x)和c(x)得出：</p><p>首先根据固定的多项式可以得到一个4X4的矩阵，第3行排列c3 、c2、c1、c0，然后第2行为c2、c1、c0、c3，每一次根据i+1行的循环左移一位，因此，第0行为c0、c3、c2、c1</p><p>s(x)可以得到一个4X1的矩阵，即s0、s1、s2、s3，然后两个矩阵相乘可以得到一个4X1的新列，AES列混淆，就是用这个新列去代换旧列</p><h3 id="三、Xtime-机制"><a href="#三、Xtime-机制" class="headerlink" title="三、Xtime()机制"></a>三、Xtime()机制</h3><p>因为明文矩阵和固定多项式的系数是8bit，即用十六进制表示，因此会遇到十六进制相乘，Xtime()就是简化这个过程</p><p><img src="/2019/11/25/AES列混淆机制详解/01.png" alt="01"></p><p>由上述可以总结：对于02或是03这样的乘法，那我们就可以通过Xtime()机制优化算法</p><p>Xtime()：</p><p>将括号内的数左移一位，判断是否有溢出</p><p>1、无溢出，直接输出</p><p>2、有溢出，异或1B后输出</p><p>判断最高位是否溢出：如果最高位为0，则一位后不输出，如果为1，则移位后溢出</p><h3 id="四、列混淆的完整表达式"><a href="#四、列混淆的完整表达式" class="headerlink" title="四、列混淆的完整表达式"></a>四、列混淆的完整表达式</h3><p><img src="/2019/11/25/AES列混淆机制详解/02.png" alt="02"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在AES中列混淆是比较重要的一步，在列混淆的设计中，设计的算法思想及运算机制是非常值得学习，它包括多项式相乘的处理，以及十六进制乘法中的Xtime机制&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>单钥密码体制二</title>
    <link href="http://soliym.top/2019/11/24/%E5%8D%95%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E4%BA%8C/"/>
    <id>http://soliym.top/2019/11/24/单钥密码体制二/</id>
    <published>2019-11-24T11:54:21.000Z</published>
    <updated>2019-11-25T08:55:29.210Z</updated>
    
    <content type="html"><![CDATA[<p>数据加密标准-DES是第一个并且也是十分重要的现代对称加密算法，但是由于DES密钥太短，伴随着计算机的计算能力的突飞猛进，DES已经极其不安全，所以需要新的加密算法代替DES，由2000年公布的AES高级加密标准代替DES。</p><a id="more"></a><h3 id="一、AES"><a href="#一、AES" class="headerlink" title="一、AES"></a>一、AES</h3><p>RIJIdael是分组长度和密钥长度均可变的分组密码，密钥长度和分组长度可以独立指定为128b、192b、256b，由比利时密码学家Daemen和Rijmen设计。</p><p>二、加密流程图</p><p><img src="/2019/11/24/单钥密码体制二/01.png" alt="01"></p><h3 id="三、加密步骤"><a href="#三、加密步骤" class="headerlink" title="三、加密步骤"></a>三、加密步骤</h3><h4 id="1、明文分组"><a href="#1、明文分组" class="headerlink" title="1、明文分组"></a>1、明文分组</h4><p>AES是分组密码，将明文分成固定长度大小的组，每组分别加密，以128为例，将128bit的明文以字节为单位分为16组，在按序每4字节为一列，组成4X4矩阵。</p><h4 id="2、字节代换"><a href="#2、字节代换" class="headerlink" title="2、字节代换"></a>2、字节代换</h4><p>在4X4矩阵中，每个元素都是1字节，8bit，因此，每个元素的前4bit组成行，后4bit组成列，通过s盒查找，代换为新的元素</p><h4 id="3、行位移"><a href="#3、行位移" class="headerlink" title="3、行位移"></a>3、行位移</h4><p>将4X4矩阵每行循环左移i个元素，i为正整数，从0开始。</p><h4 id="4、列混淆"><a href="#4、列混淆" class="headerlink" title="4、列混淆"></a>4、列混淆</h4><p>将矩阵的每个列视为GF（2^8）上的多项式，再与一个固定的多项式c(x)进行模x^4+1乘法，要求c（x）是模x^4+1可逆的多项式</p><p><img src="/2019/11/24/单钥密码体制二/02.png" alt="02"></p><p>列混淆的实质是两个多项式的相乘，并且希望得到一个多项式，但是两个多项式相乘的结果最高次项不是3，在列混淆中时两个最高次幂为3的多项式相乘，因此，需要模x^4+1.其中</p><p>因为多项式的乘法可由线性代数，即矩阵乘法给出，所以采用矩阵运算。</p><h4 id="5、轮密钥加"><a href="#5、轮密钥加" class="headerlink" title="5、轮密钥加"></a>5、轮密钥加</h4><p>将4X4的明文矩阵和4X4的密钥矩阵按位异或，既128bit与128bit异或</p><h3 id="四、密钥生成"><a href="#四、密钥生成" class="headerlink" title="四、密钥生成"></a>四、密钥生成</h3><p>初始给定的密钥是128bit，用于初始加密，但是在后面的10轮迭代中都需要用到密钥，它们加密的密钥是不同的，需要通过初始的128bit密钥，扩展出10个128bit的密钥。因此，AES加密需要11X128bit的密钥。</p><p>密钥是按矩阵的列进行分组的，需要添加40个新列来扩展密钥。</p><p><img src="/2019/11/24/单钥密码体制二/03.png" alt="03"></p><p>当i可以被4整除，需要用到T函数</p><p>T函数：1、RCON轮常量，轮常量是一个字32bit，这个字最右边为3个字节24bit的0。</p><p>​                    轮常量是固定的，每一轮均不相同。</p><p>​              2、ROTBYTE字节代换，利用S盒对输入的数替换，前4bit为行，后4bit为列</p><p>​              3、BYTESUB字循环，循环左移一个字节，即abcd变为bcda</p><h3 id="五、解密过程"><a href="#五、解密过程" class="headerlink" title="五、解密过程"></a>五、解密过程</h3><p>AES与DES不同，AES的解密过程与加密过程是不同的，不同是指解密的过程是相反的，而Feistel密码的加密解密可以使用相同的电路或程序，因为AES所有中间的加密过程都是可逆的，所以解密过程与加密过程相反，具体操作位加密操作的逆过程。</p><p>例：</p><p><img src="/2019/11/24/单钥密码体制二/04.png" alt="04"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据加密标准-DES是第一个并且也是十分重要的现代对称加密算法，但是由于DES密钥太短，伴随着计算机的计算能力的突飞猛进，DES已经极其不安全，所以需要新的加密算法代替DES，由2000年公布的AES高级加密标准代替DES。&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>单钥密码体制(一)</title>
    <link href="http://soliym.top/2019/11/24/%E5%8D%95%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E4%B8%80/"/>
    <id>http://soliym.top/2019/11/24/单钥密码体制一/</id>
    <published>2019-11-24T09:34:01.756Z</published>
    <updated>2019-11-24T09:57:33.605Z</updated>
    
    <content type="html"><![CDATA[<p>信息安全的两次变革：第一次是计算机的诞生，许多重要文件存储于计算机中，因此，计算机的主机安全就成为了一个重要的问题。第二次是计算机网络及分布式系统的诞生，人们利用网络对数据传输，在这个复杂且庞大的网络中，如何去传输重要数据，这又给信息安全带来新的问题和挑战。随着这些问题的解决，密码学也在不断的发展中。信息安全的四个目标：保密性、完整性、可用性、合法使用。</p><a id="more"></a><h3 id="一、单钥密码体制"><a href="#一、单钥密码体制" class="headerlink" title="一、单钥密码体制"></a>一、单钥密码体制</h3><p>单钥密码体制也称为私钥加密体制，因为通信双方采用的密码相同，因此，也称为对称加密体制，根据其加密算法的特点，可分为：分组密码和流密码。</p><p>古典密码：是一种简单的加密体制，它伴随着密码学的发展，它的思想对单钥密码体制影响深远，代换和置换思想，是单钥密码体制的基础。</p><p>密码学可分为古代密码、近代密码、现代密码，它有两个重要的时期，一是1949，密码学成为一门学科，二是1976年，公钥密码算法的出现。</p><p>密码学的进程：从单表代替到多表代替，再到机械码，以及现在的现代密码学，未来将会出现的量子密码学。</p><p>密码学中有一个重要的定律：伯格夫斯基定律：每一个密码都是可以破解的</p><p>虽然有些密码至今没有人可以破解，但是根据密码学的加密规则来说，密文都是根据一定的规则由明文加密而来，因此，密文肯定是可以破解的，只是时间和方法问题。</p><p>既然所有的密码都是可以破解的，那么机密算法的安全性在哪？</p><p>1、破译的成本超过加密信息性价值</p><p>2、破译的时间超过加密信息的生命周期</p><h3 id="二、分组密码DES"><a href="#二、分组密码DES" class="headerlink" title="二、分组密码DES"></a>二、分组密码DES</h3><h4 id="1、DES"><a href="#1、DES" class="headerlink" title="1、DES"></a>1、DES</h4><p>DES是一种分组加密算法，输入的明文为64位，密钥为56位，生成的密文分组长度为64位</p><h4 id="2、DES算法"><a href="#2、DES算法" class="headerlink" title="2、DES算法"></a>2、DES算法</h4><p>1、对输入分组进行固定的“初始置换”IP运算，可以将这个置换表示为：</p><p>  <img src="/2019/11/24/单钥密码体制一/01.png" alt="01"></p><p> 注意：这里L0和R0称为“左右半分组”，各为32比特。IP是固定的函数（即输入密钥不是它的参数），它是公开的。这个过程实际上为“扩散（ Diffusion ）”。</p><p>2、迭代运算，即将下面的运算迭代16轮</p><p><img src="/2019/11/24/单钥密码体制一/02.png" alt="02"></p><p>这个过程就是香农信息论中的“混淆”       </p><p>3、将16轮迭代后得到的结果（L16, R16）输入到IP的逆置换IP-1中：</p><p>注意：DES算法的加密和解密运算均采用这3个步骤。仅有的不同是：如果加密算法中使用的轮密钥次序为k1, k2, …, k16，那么解密算法中使用的密钥次序为：k16, k15, …, k1。   </p><p><img src="/2019/11/24/单钥密码体制一/03.png" alt="03"></p><p>加密流程：</p><p><img src="/2019/11/24/单钥密码体制一/04.png" alt="04"></p><p>3、密钥生成</p><p><img src="/2019/11/24/单钥密码体制一/05.png" alt="05"></p><p>4、迭代结构</p><p><img src="/2019/11/24/单钥密码体制一/06.png" alt="06"></p><p>DES的轮结构重点在于F函数，F函数将32bit明文扩展为48bit密文，然后在于密钥异或，再通过S盒的替换，压缩成32bit。</p><p>F函数中明文的扩展：将明文分为8*4的矩阵，在矩阵的左右两侧，各加入一列元素，元素生成规则为：元素空间为0到32，左侧一列为第一列元素-1，如果为-1，则为32，右侧一列+1模32</p><p>F函数中的密文压缩：通过8个s盒的代换，代换规则，将48bit密文分为8组，每组6bit，分别对应8个S盒，然后将每组的第一位和最后一位组成行，其他位组成列，然后查表替换。</p><h3 id="三、DES安全性"><a href="#三、DES安全性" class="headerlink" title="三、DES安全性"></a>三、DES安全性</h3><p>因为DES的密钥太短，因此不能抵抗穷举密钥搜索攻击，已被破解，但是它的思想影响了后来单钥密码体制的设计。</p><h3 id="四、DES的设计思想"><a href="#四、DES的设计思想" class="headerlink" title="四、DES的设计思想"></a>四、DES的设计思想</h3><p>DES的设计主要包含了扩散和混淆，这也是单钥加密算法中，分组密码的基本设计思想，扩散是将密钥对明文的影响尽可能多的去影响明文中的元素，使明文和密文的差别尽可能的大。混淆是将明文和密文的联系尽可能小，通过统计等手段，不能确定明文和密文之间的关系。</p><p>扩散和混淆的思想来源于古典密码中的置换和代换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信息安全的两次变革：第一次是计算机的诞生，许多重要文件存储于计算机中，因此，计算机的主机安全就成为了一个重要的问题。第二次是计算机网络及分布式系统的诞生，人们利用网络对数据传输，在这个复杂且庞大的网络中，如何去传输重要数据，这又给信息安全带来新的问题和挑战。随着这些问题的解决，密码学也在不断的发展中。信息安全的四个目标：保密性、完整性、可用性、合法使用。&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>vlan接口模式</title>
    <link href="http://soliym.top/2019/11/07/vlan%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%BC%8F/"/>
    <id>http://soliym.top/2019/11/07/vlan接口模式/</id>
    <published>2019-11-07T13:24:05.138Z</published>
    <updated>2019-12-24T08:47:58.730Z</updated>
    
    <content type="html"><![CDATA[<p>vlan三种接口模式区别：</p><a id="more"></a><h3 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h3><h4 id="1、收到数据包"><a href="#1、收到数据包" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>收到一个数据包，判断是否有vlan信息，如果没有则打上端口的pvid，并进行交换转发</p><h4 id="2、发送数据包"><a href="#2、发送数据包" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>将数据包的vlan信息剥离，直接发送出去</p><h3 id="Trunk端口"><a href="#Trunk端口" class="headerlink" title="Trunk端口"></a>Trunk端口</h3><h4 id="1、收到数据包-1"><a href="#1、收到数据包-1" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>1）收到一个数据包，判断是否有vlan信息，如果没有则打上端口的pvid，并进行交换转发</p><p>2）如果有vlan信息，则判断该trunk端口是否容许该vlan数据包进入，容许转发，否则丢弃。</p><h4 id="2、发送数据包-1"><a href="#2、发送数据包-1" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>比较端口的pvid和发送的vlan信息，如果相同则剥离vlan信息，然后发送，不相等，则直接发送。</p><h3 id="hybrid端口"><a href="#hybrid端口" class="headerlink" title="hybrid端口"></a>hybrid端口</h3><h4 id="1、收到数据包-2"><a href="#1、收到数据包-2" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>1）没有vlan信息，则打上端口的pvid，然后交换转发</p><p>2）有vlan信息，则判断该端口是否容许该vlan的数据包进入</p><h4 id="2、发送数据包-2"><a href="#2、发送数据包-2" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>判断该vlan的属性</p><p>1）untagged 剥离vlan tag，进行转发</p><p>2）tagged 直接发送</p><p>3）没有接口容许vlan，丢弃</p><p>注：交换机内部在处理数据包时，所有数据包一定是打上vlan tag的</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、tag报文是在原来以太网mac帧格式的基础上，在源mac和目的mac地址的后面加上4字节的vlan信息，组成802.1q帧，对于vlan信息PC网卡不能识别</p><p>2、access端口只能属于一个vlan</p><p>3、trunk端口可用于多个vlan通信</p><p>4、hybrid端口允许端个vlan通过，可以接受和发送多vlan报文</p><p>5、hybrid和trunk端口在处理数据报时，方法是一样的，不同在于，发送数据包，hybrid端口可以容许多个vlan数据包发送时不打标签，trunk端口只容许缺省vlan的数据包发送时不打标签</p><p>6、access端口只属于一个vlan，所以它的缺省vlan就是在所在vlan，hybrid和trunk端口属于多个vlan，他们的缺省vlan为vlan 1</p><p>7、如果设置了端口的缺省vlan id，当端口收到不带vlan tag的数据包之后，则将数据包转发到缺省vlan所在的交换机端口，当端口发送带有vlan tag的数据包时，如果数据包的vlan id与端口缺省vlan 相同，则交换机将去掉数据包携带的vlan tag，然后转发到该接口。</p><p>8、华为交换机的缺省vlan为pvid</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vlan三种接口模式区别：&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="HCNP" scheme="http://soliym.top/tags/HCNP/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(三)</title>
    <link href="http://soliym.top/2019/09/23/OSPF(%E4%B8%89)/"/>
    <id>http://soliym.top/2019/09/23/OSPF(三)/</id>
    <published>2019-09-23T09:56:03.224Z</published>
    <updated>2019-09-23T09:57:49.065Z</updated>
    
    <content type="html"><![CDATA[<h5 id="10、过滤OSPF路由"><a href="#10、过滤OSPF路由" class="headerlink" title="10、过滤OSPF路由"></a>10、过滤OSPF路由</h5><p>利用OSPF的汇总，在汇总条目的同时要求ospf协议传递这些汇总路由来实现路由过滤—cisco、华为均可</p><a id="more"></a><p> ospf 1 router-id 4.4.4.4 </p><p> area 0.0.0.1 </p><p> abr-summary 192.168.1.144 255.255.255.248 not-advertise  该条路由将不能再传递—3类</p><p>[r6]ospf  1 </p><p>[r6-ospf-1]asbr-summary 192.168.1.132 255.255.255.252 not-advertise  拒绝7类的传递</p><p>注：此处所谓的汇总网络号，实际可以是具体的明细路由；</p><h5 id="11、OSPF不规则区域"><a href="#11、OSPF不规则区域" class="headerlink" title="11、OSPF不规则区域"></a>11、OSPF不规则区域</h5><p>（一）规则区域：星型结构—骨干区域位于中心，非骨干区域连接骨干区域</p><p>​                   —必须存在合法的ABR</p><p>该规则的意义在于减少LSA的更新量—星型结构稳定性较高，性价比好；</p><p>OSPF存在的条件：</p><p>1、直连的邻居间，区域ID必须相同，route-id不同，否则无法建立邻居关系—ABR-连接不同的区域。</p><p>2、一台ABR没有连接到骨干区域，则为不合法ABR，不能进行路由信息的共享。</p><p>3、合法的ABR上的区域间。可直接进行路由信息共享，无须经过骨干区域。</p><p>（二）不规则区域</p><p>1、没有连接到骨干的非骨干区域</p><p>2、不连续的骨干区域</p><p>（三）解决方法：</p><p>​       1）tunnel 隧道–GRE，一种简单的VPN</p><p>在两台的ABR上建立tunnel，然后将其宣告到OSPF协议中</p><p>配置：</p><p>interface Tunnel0/0/0</p><p> ip address 10.1.1.1 255.255.255.0 </p><p> tunnel-protocol gre</p><p> source 34.1.1.1</p><p>destination 45.1.1.2</p><p>缺点：</p><p>1、周期和触发的信息将对中间的穿越区域造成资源的占用；</p><p>2、选路不佳</p><p>​      2）OSPF-vlink 虚电路—网络中合法的ABR（工作的区域0的ABR），和非法ABR间建立一条虚链路（在OSPF协议中构建，没有新生网段）   由合法ABR授权非法ABR进行区域间路由共享</p><p>配置：</p><p> [r3]ospf 1 </p><p> [r3-ospf-1]area 1 </p><p> [r3-ospf-1-area-0.0.0.1]vlink-peer 5.5.5.5    此处5.5.5.5为对端ABR的router-id</p><p>优点：</p><p>没有新生链路，故选路正常    </p><p>缺点：</p><p>cisco设备中OSPF虚链路为避免对中间穿越区域周期保活和更新产生资源占用，取消了周期的hello包和周期更新；—- 不可靠，不稳定</p><p>华为设备中依然保留周期的hello包和更新—-占用中间区域资源</p><p>​          3）OSPF多进程双向重发布</p><p>OSPF多进程，进程号仅具有本地意义，邻居间建立邻居关系时可以使用不同的进程号；</p><p>若在一台设备上同时启动多个进程，那么不同进程存在自己的邻居关系，生成不同的数据库（不共享）；</p><p>最终将所有数据库计算所得路由加载于同一张路由表中；</p><p>在解决不规则区域时，可以让非法ABR将不同的OSPF区域工作在不同的OSPF进程中，之后使用双向重发布技术来实现路由共享；</p><p>配置：</p><p>[r2]ospf  1 </p><p>[r2-ospf-1]import-route  ospf  2 </p><p>[r2]ospf  2 </p><p>[r2-ospf-2]import-route  ospf  1</p><p>优点：1、选路正常    2、无周期信息   3、但依然可靠（触发更新、邻居关系周期保障）</p><h5 id="12、OSPF扩展知识"><a href="#12、OSPF扩展知识" class="headerlink" title="12、OSPF扩展知识"></a>12、OSPF扩展知识</h5><p>（一）附录E — link-id相同的问题</p><p>若一台ABR将两条3类LSA导入其他区域；同时这两条LSA的link-id会相同；</p><p>假设：短掩码网段先进入，link-id正常显示；长掩码进入时link-id加反掩码</p><p>20.1.0.0/16–link-id  20.1.0.0   </p><p>20.1.0.0/24–link-id  20.1.0.255   </p><p>若长掩码先进入，再短掩码进入时，长掩码的信息被刷新为反掩码；</p><p>link-id相同时，短掩码正常显示，长掩码加反掩码</p><p>（二）OSPF选路规则</p><p>1、AD（管理距离）无关的第一种情况：</p><p>r2(config)#router ospf 1 </p><p>r2(config-router)#distance 109 1.1.1.1 0.0.0.0</p><p>本地从RID为1.1.1.1的设备处学习到路由条目，管理距离修改109；</p><p>一台路由器从两个OSPF邻居处学习到了两条相同的路由时，仅比较度量值，不关注管理距离；因为仅针对一台邻居进行管理距离修改的结果是要么两台都被改，要么修改失败；-关注IOS版本—有时修改RID大路由器管理距离生效，有时需要修改RID小的设备；</p><p>2、AD（管理距离）无关的第二种情况 O  IA 3类</p><p>O IA 与 O IA路由相遇，到达相同目标的两条3类路由，这两条路由均通过非骨干传递，仅关注cost值，不关注管理距离；</p><p>若一条通过骨干区域传递，另一条同过非骨干区域传递–非骨干传递的路由无效</p><p>OSPF的水平分割：区域标号为A的3类LSA，不能回到区域A；</p><p>3、OE 与OE   E为5类    N 为7类   默认所有重发布进入路由条目均为类型2，类型2在路由表中cost值不会显示沿途的累加，仅显示起始度量；</p><p>①两条均为OE2或者均为N2，起始度量相同； 关注沿途的累加度量 （OE2路由在表中度量默认不显示内部度量，仅显示起始度量）</p><p>②两条均为OE2或者均为N2，起始度量不同；优先起始度量小的路径；</p><p>注：以上设计是便于管理员快速干涉选路；</p><p>4、OE1路由仅比较总度量（起始度量+沿途累加），仅修改起始度量不一定能干涉选路，必须在修改或使得总度量产生区别才能干涉选路；</p><p>拓扑优于路由   1/2LSA计算所得路由优于3/4/5/7类计算所得</p><p>内部优于外部   3类优于4/5/7类</p><p>类型1优于类型2  E1优于E2，N1优于N2，E1优于N2，N1优于E2；</p><p>E1与N1相遇，或E2与N2相遇，先比总度量（起始+沿途）小优；度量一致5类优于7类</p><p>5、FA-转发地址</p><p>正常OSPF区域收到的5类LSA不存在FA值；</p><p>产生FA的条件：</p><p>1、5类LSA —- 假设R9为ASBR，S0/0口工作的OSPF中，E0/0口工作在非ospf协议或不同ospf进程中；且S0/1也宣告在和S0/0相同的OSPF进程中，同时该接口的工作方式为广播型；</p><p>将在5类LSA中出现FA地址，地址为R9连接R10网段中R10的接口ip；R9与R10间运行的是EIGRP协议</p><p>意义在于让R9前端的OSPF设备(比如R8)，清楚的知道域外的下一跳拓扑结构，更好的避免环路；</p><p>2、7类LSA—必然出现FA地址</p><p>假设R9为ASBR，S0/0口工作的OSPF中，S0/1口工作在非ospf协议或不同进程中；</p><p>S0/1未运行OSPF–FA地址为R9上最后宣告的环回地址（个别IOS也可能是最大环回接口ip地址），若R9没有环回接口；FA地址为R9上最后宣告的物理接口地址（个别IOS也可能是最大的物理接口ip地址）</p><p>R9的S0/1也工作OSPF协议中，S0/1接口工作方式为广播，那么FA地址为R10接口ip；</p><p>S0/1的工作方式为点到点，那么FA地址为R9的s0/1口ip</p><p>切记：在FA地址出现后，4类LSA无效；人为过滤掉4类LSA，依然可达域外；</p><p>​      当4类LSA存在，却人为过滤了到达FA地址的路由，那么将无法访问域外；</p><p>​      一旦出现FA地址，所有的选路计算均基于FA地址进行；</p><p> 1、针对存在FA的5/7类路由，4类LSA无意义，仅递归到FA地址；若FA地址被策略过滤导致不可达；</p><p> 2、路由表中的度量是到FA地址的度量，不是到ASBR的度量；</p><p>6、NP位+E位   P位被加密，故抓包时看不见P位；</p><p>正常NSSA区域内的1类LSA中，N=1    E=0  标识该区域转发7类LSA，不转发5类</p><p>非NSSA区域E=1 N=0 标识可以转发5类，不能转发7类</p><p>P位为1，标识该区域将执行7类转5类；  P为0，不能7转5；</p><p>区域0连接到两个非骨干区域，这两个非骨干假设为区域1和区域2；区域1/2同时连接外部协议，且同时进行了重发布配置；区域1为NSSA区域，区域2为非NSSA区域；那么此时的区域1，P位=0不能进行7转5；故骨干区域只能收到从区域2来的外部路由；</p><p>若区域1和区域2均为NSSA区域，那么ABR的RID大区域进行7转5，另一个区域不转，</p><p>故骨干区域只能收到从一个区域传递的外部路由；</p><p>7、SFP算法 –OSPF防环机制</p><p>在同一个区域每台路由具有一致的LSDB</p><p>每台路由器以自己为根计算到达每个目标的最短路径（最小cost值）</p><p>必须区域划分–</p><p>优势-1）域间汇总减少路由条目数量</p><p>汇总路由是在所有明细路由均消失后才删除，网络更稳定</p><p>区域划分后不同类别的LSA传播范围不同，控制更新量</p><p>过程–基于本地LSDB(1/2类LSA)生成–生成有向图–基于有向图来进行最短路径树生成</p><p>最短路径树，关注本地LINK-ID的LSA开始–》基于该LSA内提及到点到点或传输网络信息再查看link-id递归到下一条信息；基于所有点到点和传输网络信息生成最短路径树主干；</p><p>然后用树中每台设备的末梢网络信息补充路由表，完成收敛</p><h5 id="13、OSPF的扩展配置"><a href="#13、OSPF的扩展配置" class="headerlink" title="13、OSPF的扩展配置"></a>13、OSPF的扩展配置</h5><p>1、认证—接口认证</p><p>[r3]interface GigabitEthernet 0/0/1   在直连邻居的接口上配置即可</p><p>[r3-GigabitEthernet0/0/1]ospf authentication-mode md5 1 cisco123   密文认证，key编号1，密码为cisco123，密码直接以MD5值传递；</p><p>2、被动接口 – 只接受不发送路由协议的信息，其他信息正常通过；华为成为沉默接口</p><p>[r3]ospf 1 </p><p>[r3-ospf-1]silent-interface GigabitEthernet 0/0/0</p><p>3、修改计时器—OSPF的hello time 为10或30s；dead time为hello 的4倍；</p><p>3类缺省 –》 配置特殊区域后自动生成  –  末梢、完全末梢、完全NSSA</p><p>5类缺省—》本地路由表中通过其他协议或OSPF的其他进程生成了缺省路由条目—前提</p><p>之后使用重发布机制将改条目重发布到ospf的协议中来；</p><p>[r4]ospf  1 </p><p>[r4-ospf-1]default-route-advertise</p><p>默认导入路由起始度量为1,类型2；</p><p>[r4-ospf-1]default-route-advertise type 1 cost 10  修改类型和起始度量</p><p>改小计时器可以加快收敛速度，但将增加对网络资源占用；故修改时不宜修改过小，维持原有的倍数关系；</p><p>[r3]interface GigabitEthernet 0/0/1</p><p>[r3-GigabitEthernet0/0/1]ospf timer hello 5  修改本端的hello time，本端的dead time自动4倍关系匹配；直连邻居间hello 和dead time必须完全一致，否则无法建立邻居关系；</p><p>缺省路由 –  3类的缺省        5类的缺省      7类缺省</p><p>若本地路由表中没有缺省条目，也可以让设备强制向内网发送一条5类缺省</p><p>[r4-ospf-1]default-route-advertise always  默认为类型2，cost值为1；</p><p>[r4-ospf-1]default-route-advertise always type 1 cost 10  修改类型和起源cost；</p><p>7类缺省：普通的NSSA区域将自动产生7类的LSA；也可在NSSA区域内手动生成出7类缺省</p><p>[r4]ospf  1 </p><p>[r4-ospf-1]area 1 </p><p>[r4-ospf-1-area-0.0.0.1]nssa default-route-advertise  默认为类型2 ，起始cost为1；</p><p>优选顺序：内部优于外部，类型1优于类型2；</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;10、过滤OSPF路由&quot;&gt;&lt;a href=&quot;#10、过滤OSPF路由&quot; class=&quot;headerlink&quot; title=&quot;10、过滤OSPF路由&quot;&gt;&lt;/a&gt;10、过滤OSPF路由&lt;/h5&gt;&lt;p&gt;利用OSPF的汇总，在汇总条目的同时要求ospf协议传递这些汇总路由来实现路由过滤—cisco、华为均可&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(二)</title>
    <link href="http://soliym.top/2019/09/19/OSPF(%E4%BA%8C)/"/>
    <id>http://soliym.top/2019/09/19/OSPF(二)/</id>
    <published>2019-09-19T09:46:51.653Z</published>
    <updated>2019-09-19T09:51:19.591Z</updated>
    
    <content type="html"><![CDATA[<h5 id="7、OSPF-从邻居建立成为邻接关系的条件"><a href="#7、OSPF-从邻居建立成为邻接关系的条件" class="headerlink" title="7、OSPF 从邻居建立成为邻接关系的条件"></a>7、OSPF 从邻居建立成为邻接关系的条件</h5><h6 id="1、网络类型"><a href="#1、网络类型" class="headerlink" title="1、网络类型"></a>1、网络类型</h6><p>基于接口网络类型来区别：</p><p>接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的</p><a id="more"></a><p>点到点：在一个网段内只能存在两个节点，即便强制连接第三节点，最终也无法正常的通讯</p><p>​       串行链路上，二层封装为ppp或hdlc –没有物理寻址</p><p>MA：多路访问 –在一个网段内的节点数量不限制；</p><p>BMA： 广播型多路访问技术；在一个MA网络中同时存在广播机制；</p><p>​        二层封装技术为以太网；</p><p>NBMA：非广播型多路技术；在一个MA网络中没有广播机制；</p><p>​        二层封装技术为帧中继—串行链路   MGRE–点到点</p><p>在点到点网络中，OSPF协议正常均从邻居关系晋升为邻接关系；</p><p>在MA网络中，若所有邻居皆建立为邻接关系，将导致大量的重复更新；距离矢量路由协议在MA环境中使用了接口水平分割机制；由于OSPF协议是基于数据库同步对比的方式来进行收敛，故不支持接口的水平分割；</p><p>ospf最终将在MA网段进行DR/BDR的选举；非DR/BDR间将维持邻居关系，不建立邻接关系来避免重复更新；</p><h6 id="2、选举规则"><a href="#2、选举规则" class="headerlink" title="2、选举规则"></a>2、选举规则</h6><p>比较接口优先级  0-255 大优   </p><p> 默认点到点链路接口不行进行DR/BDR选举，故cisco 优先级为0-不参选  </p><p>MA网络中所有参选接口默认优选级为1，在优先级一致的情况必须参选设备的route-id数值大优；</p><p>干涉选举：修改参选接口的优先级</p><p>[r1-GigabitEthernet0/0/0]ospf dr-priority 2</p><p>因为选举非抢占，故修改优先级后，必须重启ospf协议进程</p><p><r1>reset ospf 1 process </r1></p><p>Warning: The OSPF process will be reset. Continue? [Y/N]:y</p><p>建议：网络存在DR/BDR后，其他设备修改为0，不参选；不需要重启设备的进程；</p><h6 id="8、OSPFlsa类型"><a href="#8、OSPFlsa类型" class="headerlink" title="8、OSPFlsa类型"></a>8、OSPFlsa类型</h6><p>1、OSPF的数据库表—LSDB 链路状态数据库</p><p>数据库表中装载OSPF的不同类型的LSA；</p><p>[r1]display  ospf lsdb  router   1.1.1.1     具体某条LSA</p><p>类别名   link-id</p><p>每条LSA均存在以下信息</p><p>  Type      : Router  类别名</p><p>  Ls id     : 1.1.1.1    link-id  在目录中番号</p><p>  Adv rtr   : 1.1.1.1    通告者的RID</p><p>  Ls age    : 532     老化时间 正常1800周期刷新，触发更新导致刷新；最大老化3609</p><p>  Len       : 60     长度</p><p>  Options   :  E      选项</p><p>  seq#      : 80000003   序列号</p><p>  chksum    : 0xb2ee     校验和码</p><p>OSPF的LSA是1800会更新一次序列号会加一</p><p>LSA的新旧比较</p><p>1、会先比较序列号，序列号越大越优，</p><p>2、如果序列号相同，会比较校验值（checksum)越大越优</p><p>3、如果校验值也相同，会比较LSA Age时间，是否等于MAX-age时间（3600）</p><p>4、如果age时间不等于max-age时间，会比较他们的差值，如果差值大15分钟（900秒），小的优</p><p>5、如果age时间不等于max-age时间，会比较他们的差值，如果差值小于15分钟，说明是同一条LSA，忽略其中一条</p><p>2、什么情况下LSA会更新：</p><p>1、1800到期会更新</p><p>2、触发更新（接口地址变化（增加，或删除），修改接口开销值，删除接口，或者删除通告）</p><p>[r4-ospf-1]import-route rip 1   将RIP进程1重发布到OSPF的进程1</p><p>[r5]display ospf lsdb ase originate-router  查看5类LSA</p><p>ASBR—自治系统边界路由器—协议边界路由器</p><p>3、LSA类型</p><p>LSA类别                 传播范围                         通告者                                    携带信息</p><p>LSA-1 router         本地设备所在区域     该区域每台设备的RID   每台设备本地所在区域的直连    拓扑</p><p>LSA-2 Network     本地设备所在区域                DR                     单个MA网段的拓扑</p><p>LSA-3 summary     整个OSPF域                       ABR                    域间路由</p><p>LSA-4 asbr             除ASBR所在的区域             ABR                   ASBR位置</p><p>​                              外的整个ospf域；               asbr                   所在区域基于1类交代位置</p><p>LSA-5 external      整个OSPF域                       ASBR                  域外路由</p><p>LSA-7 NSSA          本地的NSSA区域                ASBR                  域外路由</p><p>​                </p><p>LSA类别                    link-id                         通告者</p><p>LSA-1 router         通告者的RID                本区域内每台设备必须发送</p><p>LSA-2 Network      DR的接口ip地址          每个MA网段中的DR</p><p>LSA-3 summary     域间路由目标网络号     ABR，在经过下一台ABR时，修改为新的ABR的RID</p><p>LSA-4 asbr             ASBR的RID                 和ASBR同一区域的ABR，在经过下一台ABR时，修改为新的ABR的RID</p><p>LSA-5 external       域外路由目标网络号            ASBR</p><p>LSA-7 NSSA           域外路由目标网络号            ASBR；  离开本地NSSA区域时转换为5类</p><p>OSPF协议正常学习到的路由条目优先级为10；重发布进入的路由为150；</p><h6 id="9、LSA优化"><a href="#9、LSA优化" class="headerlink" title="9、LSA优化"></a>9、LSA优化</h6><p>优化OSPF协议，减少LSA的更新量；正常1类LSA是一台设备一条，2类lsa是一个网段的DR一条；3类和5类是一条路由一条LSA；4类是一台ASBR产生一条；</p><p>1、汇总—减少骨干区域的更新量</p><p>1）域间路由汇总—将非骨干区域汇总到骨干区域</p><p>在ABR上进行配置</p><p>[r1]ospf 1</p><p>[r1-ospf-1]area 2   只能汇总本地通过该区域1、2类LSA产生的路由</p><p>[r1-ospf-1-area-0.0.0.2]abr-summary 5.5.4.0 255.255.252.0 </p><p>注：汇总配置完成后，需要手工添加空接口防环路由</p><p>2）域外路由汇总；因为域外路由由ASBR重发布导入；故在导入的ASBR上进行配置</p><p>[r4]ospf 1</p><p>[r4-ospf-1]asbr-summary 99.1.0.0 255.255.252.0</p><p>2、特殊区域-减少非骨干区域的更新量—不能是骨干区域，不能存在的虚链路；</p><p>①不能存在ASBR</p><p>1、末梢区域 stub   拒绝4/5类的LSA；生成一条3类的缺省路由指向骨干区域</p><p>[r5]ospf 1   </p><p>[r5-ospf-1]area 2</p><p>[r5-ospf-1-area-0.0.0.2]stub</p><p>切记:该区域所有设备均需要定义为末梢区域；</p><p>2、完全末梢区域 在末梢区域的基础上，进一步拒绝3类lsa，仅保留一条3类的缺省；</p><p>先将该区域配置为末梢，区域然后仅在abr上定义完全即可；</p><p>[r1-ospf-1-area-0.0.0.2]stub no-summary</p><p>②存在ASBR</p><p>1、NSSA 非完全末梢区域—该区域拒绝其他区域的ASBR产生的4/5LSA；本地区域内ASBR产生的5类LSA，以7类在本区域传播，从本区域进入骨干区域时由ABR（新的ASBR）转换为5类，同时自动产生一条7的缺省指向骨干区域；</p><p>[r4]ospf</p><p>[r4-ospf-1]are 1</p><p>[r4-ospf-1-area-0.0.0.1]nssa  </p><p>本区域内所有设备均需配置</p><p>2、完全NSSA –在NSSA的基础上，进一步拒绝3的LSA；生成一条3类缺省指向骨干区域；</p><p>先将该区域配置为NSSA区域，然后仅在ABR上定义完全即可</p><p>[r3-ospf-1-area-0.0.0.1]nssa  no-summary</p><p>切记:考虑到ISP连接网络后，产生的缺省路由与OSPF特殊区域产生的缺省可能导致环路；</p><p>​     ISP连接到的哪个区域，那么该区域不能设定为任何的特殊区域；</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;7、OSPF-从邻居建立成为邻接关系的条件&quot;&gt;&lt;a href=&quot;#7、OSPF-从邻居建立成为邻接关系的条件&quot; class=&quot;headerlink&quot; title=&quot;7、OSPF 从邻居建立成为邻接关系的条件&quot;&gt;&lt;/a&gt;7、OSPF 从邻居建立成为邻接关系的条件&lt;/h5&gt;&lt;h6 id=&quot;1、网络类型&quot;&gt;&lt;a href=&quot;#1、网络类型&quot; class=&quot;headerlink&quot; title=&quot;1、网络类型&quot;&gt;&lt;/a&gt;1、网络类型&lt;/h6&gt;&lt;p&gt;基于接口网络类型来区别：&lt;/p&gt;
&lt;p&gt;接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(一)</title>
    <link href="http://soliym.top/2019/09/19/OSPF(%E4%B8%80)/"/>
    <id>http://soliym.top/2019/09/19/OSPF(一)/</id>
    <published>2019-09-19T09:40:53.475Z</published>
    <updated>2019-09-19T09:50:58.070Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、动态路由协议"><a href="#一、动态路由协议" class="headerlink" title="一、动态路由协议"></a>一、动态路由协议</h4><p>1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。</p><a id="more"></a><p>2、动态路由协议分类：</p><p>​                   1、基于AS将路由协议分为IGP和EGP</p><p>​                         AS-自治系统    </p><p>​                                   0-65535  标准为2个字节   扩展为4个字节</p><p>​                                                   1-64511          公有</p><p>​                                                    64512-65535 私有</p><p>​                         IGP—内部网关路由协议（as之内使用）</p><p>​                                   RIP/OSPF/EIGRP(Cisco)/isis</p><p>​                                 EGP—外部网关路由协议（as之间使用）</p><p>​                                    BGP/EGP</p><p>​                   2、内部网关路由协议—IGP分类</p><p>​                         ①更新时是否携带子网掩码：有类别—不携带</p><p>​                                                                     无类别—携带</p><p>​                         ②工作特点：距离适量—RIP/EIGRP</p><p>​                                                                基于路由条目收敛</p><p>​                                             链路状态—OSPF/ISIS</p><p>​                                                               基于LSA收敛</p><h4 id="二、开放式最短路径优先协议"><a href="#二、开放式最短路径优先协议" class="headerlink" title="二、开放式最短路径优先协议"></a>二、开放式最短路径优先协议</h4><h5 id="1、OSPF协议特点"><a href="#1、OSPF协议特点" class="headerlink" title="1、OSPF协议特点"></a>1、OSPF协议特点</h5><p>适用范围：IGP</p><p>类型：链路状态型动态路由协议</p><p>算法：SPF算法  </p><p>封装：基于IP封装，协议号为89—跨层封装</p><p>版本：OSPFV2—IPV4、OSPFV3—IPV6</p><p>更新方式：组播或单播—224.0.0.5/224.0.0.6</p><p>​                      触发更新/周期更新—周期更新时间是30min</p><p>区域划分：OSPF需要合理规划IP地址和区域划分</p><p>​                 —目的：减少lsa数量、减少lsa传播范围、减少对资源的消耗</p><p>​                 —原因：OSPF需要消耗大量的路由器资源</p><p>metric计算：OSPF使用cost计算metric</p><p>​                    cost=参考带宽/链路实际带宽</p><p>​                    每条路由信息的metric值=该条路径上每段链路的cost值的总和</p><p>router-id：在网络内唯一标识一台路由器</p><h5 id="2、区域划分"><a href="#2、区域划分" class="headerlink" title="2、区域划分"></a>2、区域划分</h5><p>​     1、区域内传拓扑：</p><p>​          —用于每台路由器计算到达所有未知路径的最短路径</p><p>​          —拓扑信息：路由器之间的连接关系</p><p>​    2、 区域间传路由：</p><p>​           —区域间传递计算完成的路由信息</p><p>​           —路由信息：包含的接口的路由信息</p><p>​     3、区域标识：使用十进制或类似于ip地址的32位二进制</p><p>​     4、区域划分：基于链路（接口）</p><p>​     5、区域类型：骨干区域</p><p>​                            —区域0，必须存在且唯一</p><p>​                                  非骨干区域</p><p>​                           —非0区域</p><p>​     6、 路由器的角色：        </p><p>​           —骨干路由器：一个路由器的所有接口都在area 0中</p><p>​            —非骨干路由器：一个路由器的所有接口都不在area 0 中</p><p>​            —ABR：区域边界路由器：能够产生3类LSA的路由器既有接口属于area 0 又有接口属        于非area 0</p><p>​            —ASBR：自治系统边界路由器，能够产生5类或7类LSA的路由器，连接ospf网络和非ospf网络，并且将非ospf引入到ospf网络中</p><p>​       7、区域划分规则</p><p>​          ①OSPF网络中必须存在并唯一的骨干区域（若OSPF仅仅存在一个区域可以为非0区域）</p><p>​          ②非骨干区域必须与骨干区域直接相连（非骨干不能非骨干直接相连）</p><p>​     8、不规则区域：1.不连续的0区域     2.非骨干没有挂靠在骨干区域之上</p><h5 id="3、OSPF数据报"><a href="#3、OSPF数据报" class="headerlink" title="3、OSPF数据报"></a>3、OSPF数据报</h5><p>   OSPF数据包跨层封装于三层报头</p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="img"></p><p>五类数据报：</p><p>1、hello（224.0.0.5）：发现、建立、保活邻居关系、邻接关系</p><p>2、DBD-数据库描述包：本地链路状态数据库的目录</p><p>3、LSR-链路状态查询：根据DBD中的描述，对未知的lsa请求</p><p>4、LSU-链路状态更新：对请求的LSR的回复，携带lsa信息</p><p>5、LSACK-链路状态确认：确认包，保证lsa传递的可靠性</p><p>DBD：数据库描述数据包  使用隐式确认，分为两种：1.主从选举DBD-包含mtu，若不一致则停留在预启动   2.发送LSA头部摘要信息（LSA目录）</p><p>由于IP数据报不可靠，所以除hello外，其他数据包需要确认</p><p>DBD—序列号，显示或隐式确认</p><p>LSR—LSU</p><p>LSU—LSACK</p><h5 id="4、OSPF状态机"><a href="#4、OSPF状态机" class="headerlink" title="4、OSPF状态机"></a>4、OSPF状态机</h5><p>down：一旦收发hello，则进入下一状态</p><p>init—初始化：当接收到的hello中携带自己的router-id，则进入下一状态</p><p>2way—双发通信：邻居关系建立的标志</p><p>​             点到点网络直接进入下一状态，ma网路进行DR/BDR选举</p><p>​             条件匹配：若条件匹配成功，进入下一状态</p><p>​                              若条件匹配失败，停留在当前状态，依靠hello保活邻居关系</p><p>Exstart预启动:通过类hello包DBD进行主从关系选举，router-id大的为主，优先进入下一状态</p><p>​                 （通过主从选举确定先发送DBD的一方，确保传输的可靠性和对链路带宽的占用小）          如果mtu不相同则停留在该阶段</p><p>exchange准交换：使用真正的DBD包进行数据库目录的共享</p><p>loading 加载：使用LSR/LSU/LSack来获取未知的LSA信息</p><p>lsr–请求列表-针对每一条发送lsu</p><p>lsu–重传列表-对方收到lsu后发送ack确认，如果没收到，则重发</p><p>full转发:邻接关系建立的标志</p><h5 id="5、OSPF工作方式"><a href="#5、OSPF工作方式" class="headerlink" title="5、OSPF工作方式"></a>5、OSPF工作方式</h5><p>启动宣告配置完成后，路由器开始组播（224.0.0.5）收发OSPF的hello包；若接收到的hello包中存在本地的route-id，建立邻居关系，生成邻居表；</p><p>之后基于表格中所有的邻居进行条件的匹配，匹配失败将维持邻居关系，仅hello包周期保活即可；</p><p>匹配成功者间可以建立邻接关系；邻居间使用DBD进行数据库目录的比对；之后使用LSR查询目录中未知的LSA信息，对端使用LSU来携带传递LSA，最终需要LSack进行接收确认；</p><p>当本地收集到区域内所有设备的LSA后，生成LSDB—链路状态数据库表；</p><p>本地基于LSDB启用SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表内；</p><p>收敛完成，仅hello包周期保活所有的邻居和邻接关系；每30MIN周期进行DBD包的收发来进行纠错；</p><p>结构突变：</p><p>新增网段—直连新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛</p><p>断开网段—断开新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛</p><p>无法沟通—-dead time 和最大老化来解决</p><p>正常邻居间存在hello包，若超过dead time依然没有hello包，断开邻居关系，删除从该邻居处学习到的所有信息</p><p>若邻居关系依然正常，但每30min的周期没有正常进行，每条lsa后方存在一个老化时间，默认最大为3609s；到达最大老化时删除该LSA信息即可；</p><p>名词：</p><p>Router-ID：路由器标示符，用于标识该路由器在OSPF网络中的唯一性</p><p>选举规则：1.手工指定最优先    2.最大的环回接口地址  3.最大的物理接口</p><p>hello时间、dead时间：默认10、40或 30、120s</p><p>DR优先级 ：</p><p>DR：指定路由器</p><p>BDR：备份指定路由器</p><p>LSA：链路状态通告；在不同条件下存在不同类别的LSA，用于携带拓扑或路由</p><p>LSDB：链路状态数据库；所有LSA的集合</p><p>OSPF收敛行为—OSPF的LSA洪泛</p><p>​                           OSPF的LSDB同步</p><p>OSPF邻居关系建立条件：</p><p>1.router-ID必须不同    </p><p>2.area-ID必须一致</p><p>3.认证类型和认证型数据都一致   </p><p>4.hello时间、dead时间都一致  </p><p>5.特殊区域标识必须一致  </p><p>6.若在MA网络中，network mask必须一致</p><p>7.必须同时使用单播或组播</p><h5 id="6、OSPF基础配置"><a href="#6、OSPF基础配置" class="headerlink" title="6、OSPF基础配置"></a>6、OSPF基础配置</h5><h6 id="（一）cisco"><a href="#（一）cisco" class="headerlink" title="（一）cisco"></a>（一）cisco</h6><p>r1(config)#router ospf 1   启动时需要配置进程号，仅具有本地意义</p><p>r1(config-router)#router-id 1.1.1.1   配置RID，要求为全网唯一</p><p>​                              手工—环回接口最大数字—物理接口最大数字</p><p>宣告：1、激活  2、路由或拓扑   3、区域划分</p><p>r1(config-router)#network 1.1.1.1 0.0.0.0 area 0</p><p>r1(config-router)#network 12.1.1.0 0.0.0.255 area 0</p><p>​                                   反掩码</p><p>启动配置完成后，所有设备间使用hello包，发现并建立邻居关系，生成邻居表：</p><p>Hello time 为10s，dead time 为 hello time 的4倍；</p><p>r2#show ip ospf neighbor </p><p>Neighbor ID     Pri   State           Dead Time   Address         Interface</p><p>1.1.1.1           0   FULL/  -        00:00:34    12.1.1.1        Serial1/0</p><p>3.3.3.3           0   FULL/  -        00:00:39    23.1.1.2        Serial1/1</p><p>邻居关系建立后，邻居间进行条件匹配，匹配成功者间进入邻接关系；基于DBD/LSR/LSU/LSack获取未知LSA信息，生成LSDB–数据库表；</p><p>r2#show ip ospf database </p><p>LSDB同步完成后，本地使用SPF最短路径选路规则，将到达未知网段的路由加载路由表：</p><p>使用字母O标识通过OSPF学习的路由；</p><p>O      本地区域内的路由，是本地通过拓扑计算所得</p><p>O IA    域间路由，其他区域的路由，通过ABR共享进入的</p><p>管理距离为110；度量为cost值=开销值=参考带宽/接口带宽</p><p>默认参考带宽为100M；整段路径cost值之和最小为最佳路径；</p><p>注：当接口带宽大于参考带宽时，cost值为1；将可能导致选路不佳，建议修改参考带宽</p><p>r1(config)#router ospf 1 </p><p>r1(config-router)#auto-cost reference-bandwidth ?    </p><p>  <1-4294967>  The reference bandwidth in terms of Mbits per second</1-4294967></p><p>r1(config-router)#auto-cost reference-bandwidth 1000</p><p>切记：整个网络所有设备均需要修改一致；</p><p>【5】OSPF建立成为邻接关系的条件—-关注网络类型</p><p>点到点–在一个网段内只能存在两个节点</p><p>MA网络—在一个网段内节点数量不限制</p><p>在点到点网络ospf只能直接建立邻接关系；</p><p>在MA网络中为避免重复的更新，将进行DR/BDR选举，所有的非DR/BDR间仅建立邻居关系；DR/BDR与其他非DR/BDR建立邻接关系，基于224.0.0.6沟通；</p><p>选举规则：</p><p>比较接口优先级  0-255 大优  默认为1；</p><p>接口优先级若相同，比较RID；</p><p>r1(config)#interface fastEthernet 0/0</p><p>r1(config-if)#ip ospf priority 3  修改接口优先级</p><p>注：ospf选择非抢占的，因此在人为修改了优先级后，必须重启所有设备的OSPF进程</p><p>r1#clear ip ospf process </p><p>Reset ALL OSPF processes? [no]: yes</p><p>可以将设备的参选接口优先级修改为0,—-不参选；但至少留一台设备参选，否则将无DR,网络无法通行；</p><h6 id="（二）华为"><a href="#（二）华为" class="headerlink" title="（二）华为"></a>（二）华为</h6><p>[r1]ospf 1 router-id 1.1.1.1  启动时需要定义进程号，仅具有本地意义；  建议同时配置ROUTER-ID；</p><p>​                      手工—环回最大数值IP地址—物理接口最大数值IP地址</p><p>宣告：</p><p>[r2]ospf 1 router-id 2.2.2.2</p><p> [r2-ospf-1]area 0</p><p> [r2-ospf-1-area-0.0.0.0]network 12.1.1.2 0.0.0.0</p><p> [r2-ospf-1]area 1 </p><p> [r2-ospf-1-area-0.0.0.1]network 23.1.1.1 0.0.0.0</p><p>OSPF的区域划分规则：</p><p>星型结构—所有的非骨干区域必须连接到的骨干区域，否则不能进行区域间路由共享</p><p>ABR—区域边界路由器  同时工作的多个区域间；合法ABR必须同时工作在骨干区域，否则不能进行区域间的路由共享；</p><p>启动配置完成后，路由器间使用hello包收发建立邻居关系，生成邻居表：</p><p>[r2]display ospf peer</p><p>Area 0.0.0.0 interface 12.1.1.2(GigabitEthernet0/0/0)’s neighbors</p><p> Router ID: 1.1.1.1          Address: 12.1.1.1        </p><p>   State: Full  Mode:Nbr is  Slave  Priority: 1</p><p>   DR: 12.1.1.1  BDR: 12.1.1.2  MTU: 0    </p><p>   Dead timer due in 35  sec </p><p>   Retrans timer interval: 5 </p><p>   Neighbor is up for 00:18:48     </p><p>   Authentication Sequence: [ 0 ]</p><p>邻居关系建立后，邻居间进行条件的匹配；匹配成功建立邻接关系，同步LSDB完成后，本地生成LSDB—数据库表；</p><p>[r2]display ospf lsdb   查看数据库的目录；内部存在各种类别的信息，需要具体查看</p><p>LSDB同步完成后，本地基于SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表中；</p><p>[r3]display  ip routing-table  查看路由表</p><p>Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</p><p>​        1.1.1.1/32  OSPF    10   2           D   23.1.1.1        GigabitEthernet0/0/0</p><p>​        2.2.2.2/32  OSPF    10   1           D   23.1.1.1        GigabitEthernet0/0/0</p><p>[r3]display ip routing-table protocol ospf  查看本地所有通过OSPF协议学习到的路由</p><p>[r1]display ospf routing    查看本地工作OSPF的直连，及本地通过OSPF学习到的路由</p><p>Destination        Cost  Type       NextHop         AdvRouter       Area</p><p> 1.1.1.1/32         0     Stub       1.1.1.1         1.1.1.1         0.0.0.0</p><p> 12.1.1.0/24        1     Transit     12.1.1.1        1.1.1.1         0.0.0.0</p><p> 2.2.2.2/32         1     Stub       12.1.1.2        2.2.2.2         0.0.0.0</p><p> 3.3.3.3/32         2     Inter-area  12.1.1.2        2.2.2.2         0.0.0.0</p><p> 23.1.1.0/24        2     Inter-area  12.1.1.2        2.2.2.2         0.0.0.0</p><p>  类型标记为Inter-area 代表其他区域产生的路由条目</p><p>OSPF的度量值为cost=开销值=参考带宽/接口带宽</p><p>默认的参考带宽为100M；OSPF默认优选整段路径cost之和最小；</p><p>若接口带宽大于参考带宽，cost值为1；将可能导致选路的不佳，建议修改默认的参考带宽；</p><p>[r1]ospf 1</p><p>[r1-ospf-1]bandwidth-reference 1000</p><p>切记：一旦修改，全网所有设备均需修改为一致；</p><p>​             </p><p>​     </p><p>​      </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、动态路由协议&quot;&gt;&lt;a href=&quot;#一、动态路由协议&quot; class=&quot;headerlink&quot; title=&quot;一、动态路由协议&quot;&gt;&lt;/a&gt;一、动态路由协议&lt;/h4&gt;&lt;p&gt;1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>EIGRP增强内部网关路由协议简述</title>
    <link href="http://soliym.top/2019/09/02/EIGRP%E5%A2%9E%E5%BC%BA%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
    <id>http://soliym.top/2019/09/02/EIGRP增强内部网关路由协议简述/</id>
    <published>2019-09-02T09:14:50.548Z</published>
    <updated>2019-09-02T09:14:50.548Z</updated>
    
    <content type="html"><![CDATA[<p><strong>EIGRP：增强内部网关路由协议</strong> <strong>— cisco</strong>私有的协议</p><p>无类别距离矢量协议，协议号88；组播更新：224.0.0.10</p><p>增量更新—仅触发、无周期更新—–可靠性、更新量小</p><p>支持非等开销负载均衡</p> <a id="more"></a><p>AD        本地下一跳到达目标的度量</p><p>FD       本地到达目标的度量</p><p>S         最佳路径的下一跳路由器</p><p>FS       备份路径的下一跳路由器</p><p>FC       可行性条件，成为备份路径的条件</p><p>【1】EIGRP的数据包</p><p>Hello 包       用于邻居发现、建立、保活   hello time  5s</p><p>Update包         路由条目–目标网络号+度量值</p><p>查询包                    查询路径，最佳路径和备份路径—-非等开销负载均衡</p><p>应答包         查询确认</p><p>ACK            </p><p>【2】EIGRP的4大组件 组建</p><p>Hello机制—-认识所有邻居</p><p>PDM —-支持多种网络层协议 （协议有关单元） 协议无关单元 IPX appletalk</p><p>RTP–可靠传输协议—-借鉴TCP的4种可靠机制–确认、重传、排序、流控（不能超过链路带宽的百分之50）</p><p>DUAL—扩散更新（弥散更新）算法</p><p>【3】EIGRP的工作过程</p><p>启动配置后，运行EIGRP协议的路由器，通过组播224.0.0.10向所有的邻居发送hello包；收到邻居的hello包后及表示认识了邻居，生成邻居表；</p><p>邻居关系建立后，邻居间使用更新包进行路由信息的共享；</p><p>收集到所有的路由条目后，本地生成–拓扑表；—装载所有的最佳和备份路径；</p><p>本地默认将拓扑表中的最佳路径全部加载到路由表内；—收敛完成</p><p>结构突变：</p><p>新增网段—直连新增网段的设备，使用更新包告知所有邻居即可</p><p>断开网段—-直连断开网段的设备，发出查询包，通过DUAL，收集应答包来重新收敛</p><p>无法沟通—-hello time 5s   hold time 15s</p><p>更新包、查询包、应答包–均被RTP服务    </p><p>接收到这三种包时，需要ACK来确认，若未进行确认将单播重传，最大16次，若依然失败断开邻居关系；RTP在转发这三种包时，还会对其进行排序和流控；</p><p>【4】EIGRP的配置</p><p>r1(config)#router eigrp ?    启动时需要配置AS号</p><p>  <1-65535>  Autonomous system number</1-65535></p><p>r1(config)#router eigrp 90   此处理解为全网一致的进程号；</p><p>r1(config-router)#   </p><p>r1(config-router)#no auto-summary   关闭自动汇总</p><p>宣告：激活     路由</p><p>r1(config-router)#network 1.0.0.0</p><p>r1(config-router)#network 124.1.1.1 0.0.0.0</p><p>EIGRP宣告时，可以向rip一样直接配置主类，也可以像OSPF一样使用反掩码进行匹配</p><p>启动配置完成后，邻居间使用hello包建立邻居关系，生成邻居表：</p><p>r2#show ip eigrp neighbors </p><p>IP-EIGRP neighbors for process 90</p><p>H   Address                 Interface       Hold Uptime   SRTT   RTO  Q  Seq</p><p>​                                            (sec)         (ms)       Cnt Num</p><p>2   124.1.1.4               Fa0/0             10 00:01:59   28   200  0  11</p><p>1   23.1.1.2                Se1/1             13 00:02:14   39   234  0  11</p><p>0   124.1.1.1               Fa0/0             13 00:02:19  389  2334  0  7</p><p>邻居关系建立后，邻居间使用更新包收敛路由信息，生成拓扑表：</p><p>本地到达邻居的最佳和备份路径；</p><p>r3(config)#interface s1/1</p><p>r3(config-if)#bandwidth 800   修改接口参考带宽</p><p>一个接口的实际传输带宽—-硬件、QOS；参考带宽并不影响实际传输带宽，只影响路由协议的选路；</p><p>r3#show ip eigrp topology </p><p>IP-EIGRP Topology Table for AS(90)/ID(3.3.3.3)</p><p>Codes: P - Passive, A - Active, U - Update, Q - Query, R - Reply,</p><p>​       r - reply Status, s - sia Status </p><p>P 1.1.1.0/24, 1 successors, FD is 2300416</p><p>​        via 23.1.1.1 (2300416/156160), Serial1/0   最佳</p><p>​        via 34.1.1.2 (3842560/156160), Serial1/1   备份</p><p>​                    FD      AD</p><p>FD可行距离 —- 本地通过该路径到达目标的度量</p><p>AD可行后继距离（通告距离）—-本地的下一跳到达目标的度量值</p><p>FC可行条件—-成为备份路径的条件  备份的AD小于不等于最佳路径的FD值</p><p>备份路径的意义在于可以和最佳路径一起完成非等开销负载均衡；</p><p>非等开销负载均衡：当到达一个目标地址时，若存在两条开销相近的路径时，可以让设备将流量按比例延这些路径同时传输，提高链路的利用率；</p><p>差异值：备份的FD/最佳路径的FD=向上取整</p><p>设备默认的差异值规定为1，标示仅支持等开销负载均衡</p><p>r3#show ip protocols </p><p>  EIGRP maximum metric variance 1</p><p>可以通过修改差异值，来实现非等开销负载均衡</p><p>r3(config)#router eigrp 90</p><p>r3(config-router)#variance 2</p><p>r3#show ip route 1.1.1.0</p><p>默认设备将最佳路径加载于路由表中：</p><p>D - EIGRP, EX - EIGRP external</p><p>使用字母D标示正常EIGRP学习的路由；</p><p>管理距离为90；</p><p>度量：复合度量—–各种参数</p><p>度量计算公式：存在权重值  </p><p>Formula with default K values (K1 = 1, K2 = 0, K3 = 1, K4 = 0, K5 = 0):</p><p>当K5为0时：</p><p>Metric = [K1 <em> BW + ((K2 </em> BW) / (256 – load)) + K3 * delay]</p><p>当K5大于0时:</p><p>Metric = [K1 <em> BW + ((K2 </em> BW) / (256 – load)) + K3 <em> delay]</em> [K5 / (reliability + K4)]</p><p>带宽 可靠性 延迟 负载 MTU</p><p>默认k值下度量计算为带宽+延时：</p><p>带宽=（10^7/整路径最小带宽）*256</p><p>延时=（整段路径入口的延时之和/10）*256</p><p>256为放大因子—-1、放大参数便于比较  2、兼容IGRP</p><p>【5】EIGRP的扩展配置</p><p>认证</p><p>r2(config)#key chain a</p><p>r2(config-keychain)#key 1</p><p>r2(config-keychain-key)#key-string cisco123</p><p>r2(config)#interface s1/1</p><p>r2(config-if)#ip authentication key-chain eigrp 90 a</p><p>r2(config-if)#ip authentication mode eigrp 90 md5 </p><p>注：EIGRP仅支持MD5认证，故在没有修改模式前，认证是无意义的</p><p>手工汇总–在更新源路由器上，所有更新发出接口上进行配置</p><p>r3(config)#interface s1/0</p><p>r3(config-if)#ip summary-address eigrp 90 3.3.2.0 255.255.254.0 </p><p>汇总配置完成后，在汇总设备上将自动产生指向汇总地址的空接口防环路由</p><p>被动接口–只接收不发送路由协议信息</p><p>​            用于连接用户的接口，不能用于连接邻居的接口</p><p>r3(config)#router eigrp 90</p><p>r3(config-router)#passive-interface loopback 0</p><p>加快收敛  hello 5s     hold time15s</p><p>r3(config)#interface s1/1</p><p>r3(config-if)#ip hello-interval eigrp 90 5</p><p>r3(config-if)#ip hold-time eigrp 90 15</p><p>缺省路由—在边界路由器上向所有直连内网的接口上进行汇总配置，汇总地址0.0.0.0/0；</p><p>​             但边界路由器需要静态缺省指向ISP</p><p>r1(config)#interface fastEthernet 0/0</p><p>r1(config-if)#ip summary-address eigrp 90 0.0.0.0 0.0.0.0</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;EIGRP：增强内部网关路由协议&lt;/strong&gt; &lt;strong&gt;— cisco&lt;/strong&gt;私有的协议&lt;/p&gt;
&lt;p&gt;无类别距离矢量协议，协议号88；组播更新：224.0.0.10&lt;/p&gt;
&lt;p&gt;增量更新—仅触发、无周期更新—–可靠性、更新量小&lt;/p&gt;
&lt;p&gt;支持非等开销负载均衡&lt;/p&gt;
    
    </summary>
    
      <category term="CCNA" scheme="http://soliym.top/categories/CCNA/"/>
    
    
      <category term="EIGRP" scheme="http://soliym.top/tags/EIGRP/"/>
    
  </entry>
  
  <entry>
    <title>OSPF开放最短路径优先协议简述</title>
    <link href="http://soliym.top/2019/09/02/OSPF%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
    <id>http://soliym.top/2019/09/02/OSPF开放最短路径优先协议简述/</id>
    <published>2019-09-02T09:12:08.004Z</published>
    <updated>2019-09-02T09:12:08.008Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、开放式最短路径优先协议"><a href="#一、开放式最短路径优先协议" class="headerlink" title="一、开放式最短路径优先协议"></a>一、开放式最短路径优先协议</h5><p> OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。</p><a id="more"></a><p>OSPFv2用于ipv4网络，OSPFv3用在ipv6网络。可用于大型网络。</p><h5 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h5><p><strong>链路状态</strong></p><p>OSPF路由器收集其所在网络区域上各路由器的连接状态信息，即链路状态信息（Link-State），生成链路状态数据库(Link-State Database)。路由器掌握了该区域上所有路由器的链路状态信息，也就等于了解了整个网络的拓扑状况。OSPF路由器利用“最短路径优先算法(Shortest Path First, SPF)”，独立地计算出到达任意目的地的路由。</p><p><strong>区域</strong></p><p>OSPF协议引入“分层路由”的概念，将网络分割成一个“主干”连接的一组相互独立的部分，这些相互独立的部分被称为“区域”(Area)，“主干”的部分称为“主干区域”。每个区域就如同一个独立的网络，该区域的OSPF路由器只保存该区域的链路状态。每个路由器的链路状态数据库都可以保持合理的大小，路由计算的时间、报文数量都不会过大。</p><p><strong>共有五种区域的主要区别在于它们和外部路由器间的关系：</strong></p><p><strong>标准区域</strong>: 一个标准区域可以接收链路更新信息和路由总结。</p><p><strong>主干区域</strong>(传递区域):主干区域是连接各个区域的中心实体。主干区域始终是“区域0”，所有其他的区域都要连接到这个区域上交换路由信息。主干区域拥有标准区域的所有性质。</p><p><strong>存根区域</strong>（stub Area）：存根区域是不接受自治系统以外的路由信息的区域。如果需要自治系统以外的路由，它使用默认路由0.0.0.0。</p><p><strong>完全存根区域</strong>：它不接受外部自治系统的路由以及自治系统内其他区域的路由总结。需要发送到区域外的报文则使用默认路由：0.0.0.0。完全存根区域是Cisco自己定义的。 </p><p><strong>不完全存根区域**</strong>(NSAA)**: 它类似于存根区域，但是允许接收以LSA Type 7发送的外部路由信息，并且要把LSA Type 7转换成LSA Type 5。</p><p>OSPF中的四种路由器</p><p>在OSPF多区域网络中，路由器可以按不同的需要同时成为以下四种路由器中的几种： </p><p>\1. 内部路由器：所有端口在同一区域的路由器，维护一个链路状态数据库。 </p><p>\2. 主干路由器：具有连接主干区域端口的路由器。 </p><p>\3. 区域边界路由器(ABR)：具有连接多区域端口的路由器，一般作为一个区域的出口。ABR为每一个所连接的区域建立链路状态数据库，负责将所连接区域的路由摘要信息发送到主干区域，而主干区域上的ABR则负责将这些信息发送到各个区域。 </p><p>\4. 自治域系统边界路由器(ASBR)：至少拥有一个连接外部自治域网络（如非OSPF的网络）端口的路由器，负责将非OSPF网络信息传入OSPF网络。</p><p>OSPF路由器之间交换链路状态公告(LSA)信息。OSPF的LSA中包含连接的接口、使用的Metric及其他变量信息。OSPF路由器收集链接状态信息并使用SPF算法来计算到各节点的最短路径。</p><p><strong>协议类型</strong></p><p>Hello报文，通过周期性地发送来发现和维护邻接关系；     </p><p>​            存在router ID—-RID 全网唯一的编号，使用ip地址</p><p>DBD(链路状态数据库描述)报文，描述本地路由器保存的LSDB(链路状态数据库)；</p><p>LSR(LS Request)报文，向邻居请求本地没有的LSA；</p><p>LSU(LS Update)报文，向邻居发送其请求或更新的LSA；</p><p>LSAck(LS ACK)报文，收到邻居发送的LSA后发送的确认报文。</p><p>OSPF网络类型</p><p>根据路由器所连接的物理网络不同，OSPF将网络划分为四种类型：广播多路访问型（Broadcast multiAccess）、非广播多路访问型（None Broadcast MultiAccess，NBMA）、点到点型（Point-to-Point）、点到多点型（Point-to-MultiPoint）。 </p><p>指派路由器（DR）和备份指派路由器（BDR）</p><p>在多路访问网络上可能存在多个路由器，为了避免路由器之间建立完全相邻关系而引起的大量开销，OSPF要求在区域中选举一个DR。每个路由器都与之建立完全相邻关系。DR负责收集所有的链路状态信息，并发布给其他路由器。选举DR的同时也选举出一个BDR，在DR失效的时候，BDR担负起DR的职责。 </p><p>点对点型网络不需要DR，因为只存在两个节点，彼此间完全相邻。 协议组成OSPF协议由Hello协议、交换协议、扩散协议组成。</p><p>当路由器开启一个端口的OSPF路由时，将会从这个端口发出一个Hello报文，以后它也将以一定的间隔周期性地发送Hello报文。OSPF路由器用Hello报文来初始化新的相邻关系以及确认相邻的路由器邻居之间的通信状态。 </p><p>对广播型网络和非广播型多路访问网络，路由器使用Hello协议选举出一个DR。在广播型网络里，Hello报文使用多播地址224.0.0.5周期性广播，并通过这个过程自动发现路由器邻居。在MA网络中，DR负责向其他路由器逐一发送Hello报文。</p><h5 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h5><p>一般用于同一个路由域内。在这里，路由域是指一个自治系统（Autonomous System），即AS，它是指一组通过统一的路由政策或路由协议互相交换路由信息的网络。在这个AS中，所有的OSPF路由器都维护一个相同的描述这个AS结构的数据库，该数据库中存放的是路由域中相应链路的状态信息，OSPF路由器正是通过这个数据库计算出其OSPF路由表的。</p><h5 id="四、工作工程"><a href="#四、工作工程" class="headerlink" title="四、工作工程"></a>四、工作工程</h5><h6 id="1、数据包"><a href="#1、数据包" class="headerlink" title="1、数据包"></a>1、数据包</h6><p>5种基本数据包</p><p>HELLO—邻居的发现、建立、保活</p><p>DBD—–数据库描述包—数据库目录信息</p><p>LSR—–链路状态请求</p><p>LSU—–链路状态更新—携带各种LSA</p><p>LSACK—链路状态确认</p><h5 id="2、OSPF的状态机–描述接口状态"><a href="#2、OSPF的状态机–描述接口状态" class="headerlink" title="2、OSPF的状态机–描述接口状态"></a>2、OSPF的状态机–描述接口状态</h5><p>Down：本地一旦发出hello包，进入下一状态</p><p>Init–初始化：本地接收到的hello包中若存在本地的RID，进入下一状态</p><p>2way–双向通信：邻居关系建立的标志</p><p>条件匹配：点到点网络直接进入下一个状态；MA网络将进行DR/BDR选举（40s），非DR/BDR间不能进入下一个状态；</p><p>Exstart–预启动：使用类hello的BDB包进行主从关系选举，RID数值大为主，主从优先进入下一个状态。</p><p>Exchange–准交换：使用真正的BDB进行数据库目录的共享，需要ACK；</p><p>LOding–加载：使用LSR/LSU/LSack来获取未知的LSA信息；</p><p>Full–转发：邻接关系建立的标志；</p><h6 id="3、工作过程"><a href="#3、工作过程" class="headerlink" title="3、工作过程"></a>3、工作过程</h6><p>1、启动配置完成后，本地收发hello包，建立邻居关系，生成邻居表；</p><p>2、再进行条件的匹配，匹配失败将停留于邻居关系，仅hello包保活即可；</p><p>3、匹配成功者之间建立邻接关系，需要DBD共享数据库目录，LSR/LSU/LSack来获取未知的LSA信息，当收集完网络中所有的LSA后，生成数据表–LSDB</p><p>4、LSDB建立完成后，本地基于OSPF选路规则，计算本地到达所有未知网段的最短路径，然后将其加载到路由表中，完成收敛。</p><p>5、收敛完成后–hello包周期保活–30分钟周期的BDB比对，若不一致将会使用LSR/LSU/LSack重新获取</p><h6 id="4、配置"><a href="#4、配置" class="headerlink" title="4、配置"></a>4、配置</h6><p>配置</p><p>R1(config)#router ospf 100                    创建/进入OSPF进程100</p><p>R1(config-router)#router-id 1.1.1.1              指定Router-id，不指定则为环回地址，没有环回则为物理接                          口地址</p><p>R1(config-router)#network 12.1.1.1 0.0.0.0 area 0  可在接口内配置，IP ospd 100 area 0</p><p>​                    1、路由 2、激活 3、区域</p><p>OSPF三种表</p><p>邻居表</p><p>R2#show ip ospf neighbor</p><p>Neighbor ID     Pri   State           Dead Time   Address         Interface</p><p>1.1.1.1           1   FULL/DR         00:00:39    12.1.1.1        FastEthernet1/0</p><p>拓扑表</p><p>R2#show ip ospf database</p><p>​            OSPF Router with ID (2.2.2.2) (Process ID 100)</p><p>​                Router Link States (Area 0)</p><p>Link ID         ADV Router      Age         Seq#       Checksum Link count</p><p>1.1.1.1         1.1.1.1         90          0x80000005 0x00BF34 2</p><p>2.2.2.2         2.2.2.2         458         0x80000003 0x00BA04 3</p><p>​                Net Link States (Area 0)</p><p>Link ID         ADV Router      Age         Seq#       Checksum</p><p>12.1.1.1        1.1.1.1         470         0x80000001 0x004AD0</p><p> 路由表</p><p>R2#show ip ospf route</p><p>​            OSPF Router with ID (2.2.2.2) (Process ID 100)</p><p>​    Area BACKBONE(0)</p><p>​    Intra-area Route List</p><p>*   12.1.1.0/24, Intra, cost 1, area 0, Connected</p><p>​      via 12.1.1.2, FastEthernet1/0</p><p>*   23.1.1.0/24, Intra, cost 1, area 0, Connected</p><p>​      via 23.1.1.2, FastEthernet1/1</p><p>*&gt;  1.1.1.1/32, Intra, cost 2, area 0</p><p>​      via 12.1.1.1, FastEthernet1/0</p><p>*   2.2.2.2/32, Intra, cost 1, area 0, Connected</p><p>​      via 2.2.2.2, Loopback0</p><p>R2#show ip route ospf</p><p>​     1.0.0.0/32 is subnetted, 1 subnets</p><p>O       1.1.1.1 [110/2] via 12.1.1.1, 00:01:50, FastEthernet1/0</p><p>区域划分的规则：</p><p>星型结构 其他区域要和骨干域相连 </p><p>需要存在ABR 区域边界路由器</p><p>​                  通告者             内容</p><p>1类LSA  router  路由器本身         链路状态</p><p>2类LSA  network   DR             描述MA网络</p><p>3类LSA  sumary   ABR             路由条目</p><p>成为邻接关系的条件</p><p>1、如果在串行链路上 直接形成邻接关系</p><p>2、如果是以太网环境 只和DR/BDR形成邻接关系</p><p>选举规则</p><p>先比较优先级  越大越优先</p><p>比较Router-ID 越大越优先</p><p>非抢占性</p><p>修改优先级</p><p>R1(config)#int f0/0</p><p>R1(config-if)#ip ospf priority 2</p><p>干涉选择方法：</p><p>修改DR优先级最大，BDR次大；该选举非抢占，故必须手动重启所有设备进程</p><p>R2#clear ip ospf process </p><p>Reset ALL OSPF processes? [no]: y</p><p>修改DR优先级最大，BDR次大；将其他路由器修改为0</p><p>扩展配置：</p><p>认证</p><p>明文认证：</p><p>R2(config)#int s1/0</p><p>R2(config-if)#ip ospf authentication</p><p>R2(config-if)#ip ospf authentication-key 1 cisco</p><p>密文认证：</p><p>R2(config)#int f0/0</p><p>R2(config-if)#ip ospf authentication message-digest </p><p>R2(config-if)#ip ospf message-digest-key 1 md5 cisco</p><p>区域明文认证：</p><p>R3(config)#router ospf 100</p><p>R3(config-router)#area 0 authentication </p><p>区域密文认证：</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#area 1 authentication message-digest </p><p>被动接口</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#passive-interface loopback 0</p><p>加快收敛速度</p><p>R1(config)#int s1/1</p><p>R1(config-if)#ip ospf hello-interval 5     修改hello时间为5s dead time自动四倍关系</p><p>R1(config-if)#ip ospf dead-interval 20</p><p>链路两端必须一致</p><p>缺省路由</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#default-information originate </p><p>需要有缺省路由指向ISP</p><p>R1(config)#ip route 0.0.0.0 0.0.0.0 loopback 10</p><p>强制下放缺省</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#default-information originate always</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、开放式最短路径优先协议&quot;&gt;&lt;a href=&quot;#一、开放式最短路径优先协议&quot; class=&quot;headerlink&quot; title=&quot;一、开放式最短路径优先协议&quot;&gt;&lt;/a&gt;一、开放式最短路径优先协议&lt;/h5&gt;&lt;p&gt; OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。&lt;/p&gt;
    
    </summary>
    
      <category term="CCNA" scheme="http://soliym.top/categories/CCNA/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>RIP路由信息简述</title>
    <link href="http://soliym.top/2019/09/02/RIP%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E7%AE%80%E8%BF%B0/"/>
    <id>http://soliym.top/2019/09/02/RIP路由信息简述/</id>
    <published>2019-09-02T09:05:26.249Z</published>
    <updated>2019-09-02T09:12:33.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RIP：路由信息协议"><a href="#RIP：路由信息协议" class="headerlink" title="RIP：路由信息协议"></a>RIP：路由信息协议</h4> <a id="more"></a><h5 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a><strong>1.</strong> <strong>定义：</strong></h5><p>路由信息协议（英语：Routing Information Protocol，缩写：RIP）是一种内部网关协议（IGP），为最早出现的距离向量路由协议。属于网络层，可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等。</p><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议， RIP协议要求网络中每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。RIP协议将“距离”定义为：从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为每经过一个路由器则距离加1。“距离”也称为“跳数”。RIP允许一条路径最多只能包含15个路由器，因此，距离等于16时即为不可达。可见 RIP协议只适用于小型互联网，并不适用于复杂网络的情况。</p><h5 id="2-特点："><a href="#2-特点：" class="headerlink" title="2. 特点："></a>2. 特点：</h5><p>（1）仅和相邻的路由器交换信息。如果两个路由器之间的通信不经过另外一个路由器，那么这两个路由器是相邻的。RIP协议规定，不相邻的路由器之间不交换信息。</p><p>（2）路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。</p><p>（3）按固定时间交换路由信息，如，每隔30秒，然后路由器根据收到的路由信息更新路由表。（也可进行相应配置使其触发更新）</p><h5 id="3-版本："><a href="#3-版本：" class="headerlink" title="3.版本："></a>3.版本：</h5><h6 id="（1）版本"><a href="#（1）版本" class="headerlink" title="（1）版本"></a>（1）版本</h6><p>​       RIPv1:使用有类路由，在它的路由更新(Routing Updates)中并不带有子网的资讯，因此它无法支援可变长度子网掩码。这个限制造成在RIPv1的网络中，在同级网络下无法使用不同的子网掩码。换句话说，在同一个网络下所有的子网络数目都是相同的。另外，它也不支援对路由过程时的认证，使得RIPv1有一些轻微的弱点，有机会遭受到可能的攻击。</p><p>​       RIPv2：因为RIPv1的缺陷，RIPv2在1994年被提出，与RIP1最大的不同是RIP2为一个无类别路由协议，其更新消息中携带子网掩码，它支持VLSM、CIDR、认证和多播。另外针对安全性的问题，RIPv2也提供一套方法，未透过加密来达到认证的效果。而之后[RFC 2082]也定义了利用MD5来达到认证的方法。</p><p>​       RIPng：主要是针对IPv6做一些延伸的规范。与RIPv2相比下其最主要的差异是：RIPv2支援RIP更新认证, RIPng 则不支持，因为IPv6路由器理应会使用IPsec来进行身份验证；RIPv2 容许给路由器附上任何标签， RIPng 则不容许；</p><p>RIPv2 在每个路由表项中都保存下一跳的信息，RIPng是对一组路由表项指定下一跳信息；RIPv2 使用UDP端口520和多播地址224.0.0.9通信，RIPng 则使用UDP端口521和多播地址FF02::9通信。</p><h6 id="（2）总结RIPv1和RIPv2的区别"><a href="#（2）总结RIPv1和RIPv2的区别" class="headerlink" title="（2）总结RIPv1和RIPv2的区别"></a>（2）总结RIPv1和RIPv2的区别</h6><p>1.RIPv1是有类路由协议（不携带掩码），RIPv2是无类路由协议（携带掩码）</p><p>2.RIPv1不能支持VLSM，RIPv2可以支持VLSM</p><p>3.RIPv1没有认证的功能，RIPv2可以支持认证，并且有明文和MD5两种认证</p><p>4.RIPv1没有手工汇总的功能，RIPv2可以在关闭自动汇总的前提下，进行手工汇总</p><p>5.RIPv1是广播更新，RIPv2是组播更新，</p><p>6.RIPv1对路由没有标记的功能，RIPv2可以对路由打标记（tag），用于过滤和做策略</p><p>7.RIPv1发送的updata最多可以携带25条路由条目，RIPv2在有认证的情况下最多只能携带24条路由</p><p>8.RIPv1发送的updata包里面没有next-hop属性，RIPv2有next-hop属性，可以用与路由更新的重定</p><h5 id="4-工作原理："><a href="#4-工作原理：" class="headerlink" title="4. 工作原理："></a>4. 工作原理：</h5><p>​       （1）初始化——RIP[1]初始化时，会从每个参与工作的接口上发送请求数据包。该请求数据包会向所有的RIP路由器请求一份完整的路由表。该请求通过LAN上的广播形式发送LAN或者在点到点链路发送到下一跳地址来完成。这是一个特殊的请求，向相邻设备请求完整的路由更新。 　　</p><p>​       （2）接收请求——RIP有两种类型的消息，响应和接收消息。请求数据包中的每个路由条目都会被处理，从而为路由建立度量以及路径。RIP采用跳数度量，值为1的意为着一个直连的网络，16，为网络不可达。路由器会把整个路由表作为接收消息的应答返回。 　　</p><p>​       （3）接收到响应——路由器接收并处理响应，它会通过对路由表项进行添加，删除或者修改作出更新。 　　</p><p>​       （4）常规路由更新和定时——路由器以30秒一次地将整个路由表以应答消息地形式发送到邻居路由器。路由器收到新路由或者现有路由地更新信息时，会设置一个180秒地超时时间。如果180秒没有任何更新信息，路由的跳数设为16。路由器以度量值16宣告该路由，直到刷新计时器从路由表中删除该路由。刷新计时器的时间设为240秒，或者比过期计时器时间多60秒。Cisco还用了第三个计时器，称为抑制计时器。接收到一个度量更高的路由之后的180秒时间就是抑制计时器的时间，在此期间，路由器不会用它接收到的新信息对路由表进行更新，这样能够为网路的收敛提供一段额外的时间。 　　</p><p>​       （5）触发路由更新——当某个路由度量发生改变时，路由器只发送与改变有关的路由，并不发送完整的路由表。</p><h5 id="5-RIP防环机制"><a href="#5-RIP防环机制" class="headerlink" title="5. RIP防环机制"></a>5. RIP防环机制</h5><p>5.1 记数最大值（maximum hop count）：定义最大跳数（最大为15跳），当跳数为16跳时,目标为不可达。</p><p>5.2 水平分割（split horizon）：从一个接口学习到的路由不会再广播回该接口。</p><p>5.3 毒性逆转水平分割（poison reverse）：从一个接口学习的路由会发送回该接口，但是已经被毒化，跳数设置为16跳，不可达。</p><p>5.4 触发更新（trigger update）：一旦检测到路由崩溃，立即广播路由刷新报文，而不等到下一刷新周期。</p><p>5.5 抑制计时器（holddown timer）：防止路由表频繁翻动，增加了网络的稳定性。</p><h5 id="6-RIP路由更新机制"><a href="#6-RIP路由更新机制" class="headerlink" title="6. RIP路由更新机制"></a>6. RIP路由更新机制</h5><p>RIP协议有两种更新机制：一是定期更新，二是触发更新。“定期更新”是根据设置的更新计时器定期发送RIP路由通告。该通告报文中携带了除“水平分割”机制抑制的RIP路由之外本地路由器中的所有RIP路由信息。而“触发更新”则是RIP路由器仅在有路由表项发生变化时发送的RIP路由通告，仅携带本地路由表中有变化的路由信息。RIP路由器一旦察觉到网络变化，就尽快甚至是立即发送更新报文，而不等待更新周期结束。只要触发更新的速度足够快，就可以大大地防止“计数到无穷大”的发生，但是这一现象还是有可能发生的。</p><p>无论是定期更新，还是触发更新，RIP路由的更新规则如下：</p><p>l  如果更新的某路由表项在路由表中没有，则直接在路由表中添加该路由表项；</p><p>l  如果路由表中已有相同目的网络的路由表项，且来源端口相同，那么无条件根据最新的路由信息更新其路由表；</p><p>l  如果路由表中已有相同目的网络的路由表项，但来源端口不同，则要比较它们的度量值，将度量值较小的一个作为自己的路由表项；</p><p>l  如果路由表中已有相同目的网络的路由表项，且度量值相等，保留原来的路由表项。</p><h5 id="7、Rip基础配置"><a href="#7、Rip基础配置" class="headerlink" title="7、Rip基础配置"></a>7、Rip基础配置</h5><p>1）RIPV1</p><p>r1(config)#router rip    启动协议</p><p>r1(config-router)#version 1   选择版本1，若不进行版本选举，默认为升级版本1；</p><p>r1(config-router)#network 1.0.0.0 主类地址—-RIP在宣告时，只能定义主类的范围</p><p>clear ip route *  刷新路由表</p><p>2）RIPV2</p><p>r1(config)#router rip</p><p>r1(config-router)#version 2选择版本2</p><p>r1(config-router)#no auto-summary 关闭自动汇总；</p><p>r1(config-router)#network 12.0.0.0</p><h5 id="8、RIP扩展配置"><a href="#8、RIP扩展配置" class="headerlink" title="8、RIP扩展配置"></a>8、RIP扩展配置</h5><h6 id="1、RIPV2的认证"><a href="#1、RIPV2的认证" class="headerlink" title="1、RIPV2的认证"></a>1、RIPV2的认证</h6><p>​        运行了RIP协议的邻居间，进行身份的核实</p><p>先定制key，再在同邻居直连的接口上调用</p><p><strong>指令：</strong></p><p>r1(config)#key chain xxx</p><p>r1(config-keychain)#key 1</p><p>r1(config-keychain-key)#key-string cisco123   邻居间必须一致</p><p>r1(config)#interface s1/1</p><p>r1(config-if)#ip rip authentication key-chain xxx</p><p>r1(config-if)#ip rip authentication mode md5   模式也必须一致</p><h6 id="2、RIPV2的手工汇总"><a href="#2、RIPV2的手工汇总" class="headerlink" title="2、RIPV2的手工汇总"></a>2、RIPV2的手工汇总</h6><p>在更新源路由器上向所有更新发出的接口上配置</p><p>r2(config)#interface s1/0</p><p>r2(config-if)#ip summary-address rip 2.2.2.0 255.255.254.0 如果在接口中汇总多个路由，则选择掩码短的</p><h6 id="3、被动接口"><a href="#3、被动接口" class="headerlink" title="3、被动接口"></a>3、被动接口</h6><p>仅接收不发送路由协议信息；只能用于连接用户的接口，不得用于连接邻居的接口</p><p>r1(config)#router rip            </p><p>r1(config-router)#passive-interface loopback 0</p><h6 id="4、加快收敛"><a href="#4、加快收敛" class="headerlink" title="4、加快收敛"></a>4、加快收敛</h6><p>RIP计时器    30s 更新  180s失效   180s抑制  240s刷新</p><p>​      适当的修改计时器，可以加快设备的收敛速度</p><p>​      建议修改时维持原有的倍数关系，且不易修改的过小；全网所有设备均修改</p><p>r1(config)#router rip</p><p>r1(config-router)#timers basic 15 90 90 120</p><h6 id="5、缺省路由"><a href="#5、缺省路由" class="headerlink" title="5、缺省路由"></a>5、缺省路由</h6><p>在边界路由器上配置RIP缺省后，内部的路由器将自动生成缺省路由指向边界路由器；边界路由器到达ISP的缺省路由，宣告手工静态配置</p><p>r3(config)#router rip</p><p>r3(config-router)#default-information originate </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;RIP：路由信息协议&quot;&gt;&lt;a href=&quot;#RIP：路由信息协议&quot; class=&quot;headerlink&quot; title=&quot;RIP：路由信息协议&quot;&gt;&lt;/a&gt;RIP：路由信息协议&lt;/h4&gt;
    
    </summary>
    
      <category term="CCNA" scheme="http://soliym.top/categories/CCNA/"/>
    
    
  </entry>
  
  <entry>
    <title>DHCP工作原理</title>
    <link href="http://soliym.top/2019/09/02/DHCP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://soliym.top/2019/09/02/DHCP工作原理/</id>
    <published>2019-09-02T04:12:03.755Z</published>
    <updated>2019-09-02T04:23:42.076Z</updated>
    
    <content type="html"><![CDATA[<p>DHCP 全称Dynamic Host configuration protocol， 动态主机配置协议。 它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数，</p> <a id="more"></a><h4 id="一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上-UDP头，IP头、链路层头-也有一些差别"><a href="#一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上-UDP头，IP头、链路层头-也有一些差别" class="headerlink" title="一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上(UDP头，IP头、链路层头)也有一些差别"></a>一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上(UDP头，IP头、链路层头)也有一些差别</h4><p>​      </p><h5 id="1）DHCP-Discover"><a href="#1）DHCP-Discover" class="headerlink" title="1）DHCP Discover"></a>1）DHCP Discover</h5><p>DHCP客户端请求地址时，并不知道DHCP服务器的位置，因此DHCP客户端会在本地网络内以广播方式发送请求报文，这个报文成为Discover报文，目的是发现网络中的DHCP服务器，所有收到Discover报文的DHCP服务器都会发送回应报文，DHCP客户端据此可以知道网络中存在的DHCP服务器的位置。</p><h5 id="2）DHCP-Offer"><a href="#2）DHCP-Offer" class="headerlink" title="2）DHCP Offer"></a>2）DHCP Offer</h5><p>DHCP服务器收到Discover报文后，就会在所配置的地址池中查找一个合适的IP地址，加上相应的租约期限和其他配置信息(如网关、DNS服务器等)，构造一个Offer报文，发送给用户(可以广播、也可以单播)，告知用户本服务器可以为其提供IP地址。(注意，只是告诉client可以提供，是预分配，还需要client通过ARP检测该IP是否重复)</p><h5 id="3）DHCP-Request"><a href="#3）DHCP-Request" class="headerlink" title="3）DHCP Request"></a>3）DHCP Request</h5><p>客户端会在两种情况下发送DHCP Request</p><p>a）DHCP客户端可能会收到来自DHCP服务器的很多Offer，所以必须在这些回应中选择一个。Client通常选择第一个回应Offer报文的服务器作为自己的目标服务器，并回应一个广播Request报文，通告选择的服务器。注意，”Client通常选择第一个回应Offer报文的服务器作为自己的目标服务器”这里存在一个安全问题，如果我们的伪DHCP服务器能比原始DHCP服务器先发送Offer数据包，就能达到欺骗的目的，从而劫持目标用户的流量</p><p>b）获取DHCP客户端成功获取IP地址后，在地址使用租期过去1/2时，会向DHCP服务器发送单播Request报文续延租期，如果没有收到DHCP ACK报文，在租期过去3/4时，会再次发送广播Request报文续延租期。</p><h5 id="4）DHCP-ACK"><a href="#4）DHCP-ACK" class="headerlink" title="4）DHCP ACK"></a>4）DHCP ACK</h5><p>DHCP服务器收到Request报文后，根据Request报文中携带的用户MAC来查找有没有相应的租约记录(即之前的预分配过程中登记的那个MAC)，如果有则发送ACK报文作为回应，通知用户可以使用分配的IP地址。</p><h5 id="5）-DHCP-NAK"><a href="#5）-DHCP-NAK" class="headerlink" title="5） DHCP NAK"></a>5） DHCP NAK</h5><p>如果DHCP服务器收到Request报文后，没有发现有相应的租约记录或者由于某些原因无法正常分配IP地址，则发送NAK报文作为回应，通知用户无法分配合适的IP地址。</p><h5 id="6）DHCP-Release"><a href="#6）DHCP-Release" class="headerlink" title="6）DHCP Release"></a>6）DHCP Release</h5><p>当用户不再需要使用分配IP地址时，就会”主动”向DHCP服务器发送Release报文，告知服务器用户不再需要分配IP地址，DHCP服务器会释放被绑定的租约(在数据库中清除某个MAC对某个IP的租约记录，这样，这个IP就可以分配给下一个请求租约的MAC)</p><h5 id="7-DHCP-Decline"><a href="#7-DHCP-Decline" class="headerlink" title="\7. DHCP Decline"></a>\7. DHCP Decline</h5><p>DHCP客户端收到DHCP服务器回应的ACK报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送Decline报文，通知服务器所分配的IP地址不可用，我们在手工设置静态IP、或者DHCP分配中有时会遇到”检测到IP冲突”的提示就是因为客户端利用ARP机制来在当前内网中确认当前指定的IP是否已经被占用</p><h5 id="8）DHCP-Inform"><a href="#8）DHCP-Inform" class="headerlink" title="8）DHCP Inform"></a>8）DHCP Inform</h5><p>DHCP客户端如果需要从DHCP服务器端获取更为详细的配置信息，则发送Inform报文向服务器进行请求，服务器收到该报文后，将根据租约进行查找，找到相应的配置信息后，发送ACK报文回应DHCP客户端。</p><h4 id="二、DHCP协议的本质"><a href="#二、DHCP协议的本质" class="headerlink" title="二、DHCP协议的本质"></a>二、DHCP协议的本质</h4><p>DHCP使用UDP进行报文的传输。在主机DHCP获得地址之前，主机并没有有效的IP地址，它是通过受限广播IP地址（全1），当该地址作为目的地址时，子网内的所有主机都能收到该IP数据报。IP层的广播实际上是基于链路层的广播来实现的，所以这里有个前提，即链路层具有广播功能，在以太网中，目的地址为全1的MAC地址可作为链路上的广播地址。只要数据包能够正确到达主机IP层UDP的端口上，则应用程序就能收到该端口上的广播IP包，这正是DHCP设备能正确获得IP地址的本质。</p><p>DHCP客户端使用固定端口号68，而服务器使用固定端口号67。</p><p>DHCP由三种机制分配IP地址：</p><p> 1.自动分配方式：DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器租用到IP地址，就可以永久使用该地址。</p><p> 2.动态分配方式：DHCP服务器给主机指定一个有时间限制的IP地址， 时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。</p><p>  3.手工分配方式：客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。 </p><p>三种地址分配方式中， 只有动态分配方式可以重复使用客户端不再需要的地址</p><h4 id="三、DHCP工作流程"><a href="#三、DHCP工作流程" class="headerlink" title="三、DHCP工作流程"></a>三、DHCP工作流程</h4><p><img src="/2019/09/02/DHCP工作原理/D:/网站文件\personalblog\hexo\source\_posts\DHCP工作原理\DHCP.png" alt=""></p><p>1、客户端以广播的方式发送DHCP_DISCOVER报文，广播的范围的服务器都能接收到该报文。</p><p>2、所有的DHCP服务器都会对该报文进行响应，向DHCP客户端发送DHCP_OFFER报文，报文中的     Your（Client）IP Address字段携带了分配给客户端的IP地址，同时服务器的IP地址放在报文中的option字段中以便客户端可以区分，服务器分配后IP地址给客户端后，会把该地址分配记录下来。</p><p>3、DHCP客户端可能收到多个服务器的DHCP_OFFER报文，但是它只能对其中的一个做响应，通常DHCP客户端处理最先收到的DHCP_OFFER报文并响应。</p><p>4、DHCP客户端从DHCP_OFFER报文中提取可使用的IP地址和服务器IP地址后，会发出个广播的DHCP_REQUST报文，并在选项字段中加入选中的DHCP服务器的IP地址和自己要的IP地址。</p><p>5、DHCP服务器收到DHCP_REQUST报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP服务器不做任何处理，然后清除相应IP地址分配记录；如果相同，DHCP服务器就会向客户端发送一个DHCP_ACK报文，并在报文选项字段中增加IP地址的使用租期信息。</p><p>6、DHCP客户端接收到DHCP_ACK报文后，会检查服务器分配的IP地址是否能够使用（发送一个ARP请求到网络中，如果无主机回应该请求，则表示该地址可用）。如果可以使用，则客户端成功获得IP地址会根据IP地址使用租期自动启动续延过程；如果DHCP客户端发现分配的IP地址已经被使用，则需要向DHCP服务器发出一个DHCP_DECLINE报文，通知DHCP服务器禁用这个IP地址，此后，DHCP客户端重新开始上述地址申请流程。</p><p>7、客户端在使用租期超过50%或87.5%时，会以广播播形式向DHCP服务器发送DHCP_REQUST报文来续租IP地址。如果DHCP客户端成功收到服务器返回的DHCP_ACK报文，则按相应时间延长IP地址租期；如果没有收到服务器返回的的DHCP_ACK报文，则DHCP 客户端继续使用这个IP地址，直到IP地址使用租期到期。当租期到期后，DHCP客户端会向DHCP服务器发送一个DHCP_RELEASE报文来释放这个IP地址，并开始新的IP地址申请过程。</p><p>8、最后需要指出的是，DHCP服务器发送的DHCP_OFFER报文中的IP地址不一定是最后分配给客户端的IP地址，通常情况下，DHCP服务器会保留该地址直到客户端发出DHCP_REQUEST请求。在整个协商过程中，如果DHCP客户端发送的DHCP_REQUEST报文中的地址信息不正确，如客户端已经迁移到新的子网或者租约已经过期，DHCP服务器会发送DHCP_NAK报文给DHCP客户端，让客户端重新发起地址申请过程。</p><h4 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h4><p>DHCP配置：</p><p>R1(config)#ip dhcp pool ccna(dhcp服务器名称）</p><p>R1(dhcp-config)#network 172.16.1.0 255.255.255.0</p><p>R1(dhcp-config)#default-router 172.16.1.1</p><p>R1(dhcp-config)#dns-server 8.8.8.8</p><p>排除地址：</p><p>排除单个地址</p><p>R1(config)#ip dhcp excluded-address 172.16.1.254</p><p>排除一段地址</p><p>R1(config)#ip dhcp excluded-address 172.16.1.100 172.16.1.200</p><p>​                               起始地址   结束地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DHCP 全称Dynamic Host configuration protocol， 动态主机配置协议。 它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数，&lt;/p&gt;
    
    </summary>
    
      <category term="CCNA" scheme="http://soliym.top/categories/CCNA/"/>
    
    
      <category term="DHCP" scheme="http://soliym.top/tags/DHCP/"/>
    
  </entry>
  
  <entry>
    <title>RHCSA-Linux基础命令（一）</title>
    <link href="http://soliym.top/2019/06/17/RHCSA-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://soliym.top/2019/06/17/RHCSA-Linux基础命令（一）/</id>
    <published>2019-06-17T11:21:08.791Z</published>
    <updated>2019-12-24T08:45:13.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux的基本原则"><a href="#Linux的基本原则" class="headerlink" title=">Linux的基本原则"></a>>Linux的基本原则</h4><p>1、由目的单一的小程序组成      </p><p>2、一切皆文件，设备的访问入口也是文件</p><p>3、避免捕获用户接口，尽量不和用户交互</p><p>4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。</p><a id="more"></a><h5 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h5><p>>命令  </p><p>>命令  参数   </p><p>>命令   -选项       </p><p>>命令   -选项    参数   </p><h5 id="修改命令的执行特性"><a href="#修改命令的执行特性" class="headerlink" title="修改命令的执行特性"></a>修改命令的执行特性</h5><p>短选项        -l</p><p>多个选项可以组合</p><p>长格式        –long</p><p>​          参数        指定命令的作用对象</p><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a><strong>基础命令</strong></h4><p><strong>重启：reboot</strong></p><p><strong>关机：shutdown -h now，poweroff</strong></p><p><strong>ip a</strong>  <strong>/ ifconfig</strong>   查看ip地址</p><p><strong>dhclient</strong>  地址请求，打开网络模式</p><p><strong>kill -9 ID</strong>  结束相应的进程（命令   -选项    参数）</p><p><strong>pwd</strong>  指出当前工作环境    print workdoing directory </p><p><strong>su</strong>       切换到root用户并不切换环境（工作目录） switch user </p><p><strong>su - root</strong>    切换到root用户并切换环境(切换了工作目录)</p><p><strong>cd</strong>        切换目录  change directroy</p><p>​        绝对路径        从根开始到目标的路径叫绝对路径</p><p>​        相对路径        相对当前目录开始到目标路径  </p><p>​        /   根</p><p>​        ~   家目录 /root /home/redhat  </p><p>​        ~ USERNAME(root用户有权限)        直接切换到指定用户的家目录</p><p>​        -        在上一个目录和当前目录来回切换</p><p>​        .   当前目录</p><p>​        ..  上一级目录</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a><strong>passwd</strong></h4><ol><li>修改密码：<strong>passwd</strong> <strong>用户名</strong>    直接输入passwd修改当前用户的密码</li><li><p>删除密码：<strong>passwd -d</strong> <strong>用户名</strong></p></li><li><p>root用户：不需要输入原密码，可以不符合密码复杂性规则，可以给任何人修改密码</p></li><li><p>普通用户：需要输入原密码，必须符合密码复杂性规则，passwd修改密码无法指定用户 </p></li><li><p>[student@localhost ~]$ <strong>su -c passwd</strong>普通用户给root用户修改密码</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Linux的基本原则&quot;&gt;&lt;a href=&quot;#Linux的基本原则&quot; class=&quot;headerlink&quot; title=&quot;&gt;Linux的基本原则&quot;&gt;&lt;/a&gt;&gt;Linux的基本原则&lt;/h4&gt;&lt;p&gt;1、由目的单一的小程序组成      &lt;/p&gt;
&lt;p&gt;2、一切皆文件，设备的访问入口也是文件&lt;/p&gt;
&lt;p&gt;3、避免捕获用户接口，尽量不和用户交互&lt;/p&gt;
&lt;p&gt;4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://soliym.top/categories/Linux/"/>
    
    
      <category term="Rhcsa" scheme="http://soliym.top/tags/Rhcsa/"/>
    
  </entry>
  
  <entry>
    <title>RHCSA-Linux简介</title>
    <link href="http://soliym.top/2019/06/17/RHCSA-Linux%E7%AE%80%E4%BB%8B/"/>
    <id>http://soliym.top/2019/06/17/RHCSA-Linux简介/</id>
    <published>2019-06-17T11:17:36.958Z</published>
    <updated>2019-12-24T08:44:54.274Z</updated>
    
    <content type="html"><![CDATA[<h5 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h5><p>操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。</p><p>操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。</p><a id="more"></a><p>>&gt;硬件：框架</p><h5 id="冯诺依曼体系结构："><a href="#冯诺依曼体系结构：" class="headerlink" title="冯诺依曼体系结构："></a>冯诺依曼体系结构：</h5><p>1946年美籍凶牙利科学家冯诺依曼提出存储程序原理，把程序本身当做数据来对待，程序和该程序处理数据用同样的方式存储，并确定了存储程序计算机的五大组成部分和基本工作方法。</p><p>特点：</p><p>（1）计算机处理数据和指令一律用二进制数表示</p><p>（2）顺序执行程序</p><p>计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序 从主存储器中取出指令一条一条的执行，这一概念称为顺序执行程序。</p><p>（3）计算机硬件由运算器、控制器、存储器、输入设备、输出设备五大部分组成。</p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.jpg" alt="img"></p><p>memory：编址存储设备</p><p>假设我们的存储器为一个长条，其中每八位（bit）作为一个单元，我们把它称为字节byte，字节又称为cell。</p><p>机器语言：二进制指令 （但是对于编程 人员来说二进制语言太难懂（太简陋，太底层），但是程序员想用简单点的语言去描述计算机又不懂所以两者之间不能耦合可以加一个中间层–编译器）</p><p>   汇编语言： 仅是将二进制转为人类语言想接近的语言或者是与人类语言符号相同的类型（+ and/plus）</p><p>   所以任何一款芯片制造商他们都把机器的代码也就是机器语言提供一个较为简单的稍微向上一点的但任然很简陋的编程接口叫做汇编语言（微码编程语言）</p><h5 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h5><p>​     —-汇编语言： （低级语言）   </p><p>​            应用：驱动程序</p><p>汇编语言（assembly language）是一种用于<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA/191373" target="_blank" rel="noopener">电子计算机</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/104320" target="_blank" rel="noopener">微处理器</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8/6688343" target="_blank" rel="noopener">微控制器</a>或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用<a href="https://baike.baidu.com/item/%E5%8A%A9%E8%AE%B0%E7%AC%A6/489287" target="_blank" rel="noopener">助记符</a>（Mnemonics）代替<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/8553126" target="_blank" rel="noopener">机器指令</a>的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%A0%81/3220418" target="_blank" rel="noopener">操作码</a>，用地址符号（Symbol）或标号（Label）代替指令或<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0/7658270" target="_blank" rel="noopener">操作数</a>的地址。在不同的设备中，汇编语言对应着不同的机器语言<a href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86/238130" target="_blank" rel="noopener">指令集</a>，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。</p><p>​    eg：操作：寄存器BX的内容送到AX中</p><p>​     1000100111011000              机器指令</p><p>​      mov ax,bx                    汇编指令</p><p>（注意：最终识别的还是01二进制数所以还需要将汇编语言转换为二进语言所以需要用到汇编器）</p><p>​      —-(高级语言)：比较接近人类的思维逻辑    —-(编译器)    </p><p>​               系统级：  c    c++  </p><p>​                     适用场合大型的对性能要求比较高的服务类程序   如：oracle  mysql linux windows /</p><p>​               应用级：java  python  ruby         </p><h5 id="系统调用的层级关系-系统组成结构"><a href="#系统调用的层级关系-系统组成结构" class="headerlink" title="系统调用的层级关系(系统组成结构)"></a><strong>系统调用的层级关系(系统组成结构</strong>)</h5><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image002.jpg" alt="应 用 程 序  用 户 宁 间  庄 》 ib r 地  系 铳 啁 用  内 核 窄 间  安 全 功 能  进 程 管 理  文 件 管 理  0 百 理  网 络 管 理  内 存 一 百 理  件 抽 层 "></p><h5 id="操作系统内核的功能："><a href="#操作系统内核的功能：" class="headerlink" title="操作系统内核的功能："></a>操作系统内核的功能：</h5><p>系统调用接口</p><p>程序管理</p><p>内存管理，虚拟内存—内存交换    </p><p>文件系统管理    </p><p>设备驱动</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;操作系统是什么？&quot;&gt;&lt;a href=&quot;#操作系统是什么？&quot; class=&quot;headerlink&quot; title=&quot;操作系统是什么？&quot;&gt;&lt;/a&gt;操作系统是什么？&lt;/h5&gt;&lt;p&gt;操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。&lt;/p&gt;
&lt;p&gt;操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://soliym.top/categories/Linux/"/>
    
    
      <category term="Rhcsa" scheme="http://soliym.top/tags/Rhcsa/"/>
    
  </entry>
  
  <entry>
    <title>c关于堆栈的划定</title>
    <link href="http://soliym.top/2019/05/14/c%E5%85%B3%E4%BA%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%88%92%E5%AE%9A/"/>
    <id>http://soliym.top/2019/05/14/c关于堆栈的划定/</id>
    <published>2019-05-14T13:41:59.467Z</published>
    <updated>2019-05-14T13:51:36.365Z</updated>
    
    <content type="html"><![CDATA[<h4 id="c语言-全局变量与局部变量的划分"><a href="#c语言-全局变量与局部变量的划分" class="headerlink" title="c语言 全局变量与局部变量的划分"></a>c语言 全局变量与局部变量的划分</h4><p>在做背包问题的时候遇到这样的问题，定义一个二维数组变量，该变量的大小为1000*1000，但是在运行时报错，显示“Stack overflow ”，说明在此处超过了栈的空间。</p><a id="more"></a><p><img src="/2019/05/14/c关于堆栈的划定/D:/网站文件\personalblog\hexo\source\_posts\c关于堆栈的划定\溢出.png" alt=""></p><h5 id="c-c-内存分配"><a href="#c-c-内存分配" class="headerlink" title="c/c++内存分配"></a>c/c++内存分配</h5><h6 id="栈区-stack-sagment"><a href="#栈区-stack-sagment" class="headerlink" title="栈区(stack sagment)"></a>栈区(stack sagment)</h6><p>由编译器自动分配释放，存放函数的参数的值，局部变量的值等。在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M(也有的是1M，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><h6 id="堆区-heap-sagment"><a href="#堆区-heap-sagment" class="headerlink" title="堆区(heap sagment)"></a>堆区(heap sagment)</h6><p> 一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收 。它与数据结构中的堆是两回事。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><h6 id="全局区-静态区-data-sagment"><a href="#全局区-静态区-data-sagment" class="headerlink" title="全局区(静态区)(data sagment)"></a>全局区(静态区)(data sagment)</h6><p>全局变量和静态变量的存储区域是在一起的，程序结束后由系统释放。数据区的大小由系统限定，一般很大。</p><p>因为栈区的大小是编译器分配好的，如果变量的空间过大就会有栈的溢出问题，因此变量的类型是局部变量还是全局变量要根据变量大小选择，一版来说只有用到数组要考虑溢出问题，比如long、double都是固定长度大小的。如果数组的大小大于1000*1000就要考虑溢出问题，而全局变量的大小是有系统规定的，一般都很大。全局变量大小可达G以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;c语言-全局变量与局部变量的划分&quot;&gt;&lt;a href=&quot;#c语言-全局变量与局部变量的划分&quot; class=&quot;headerlink&quot; title=&quot;c语言 全局变量与局部变量的划分&quot;&gt;&lt;/a&gt;c语言 全局变量与局部变量的划分&lt;/h4&gt;&lt;p&gt;在做背包问题的时候遇到这样的问题，定义一个二维数组变量，该变量的大小为1000*1000，但是在运行时报错，显示“Stack overflow ”，说明在此处超过了栈的空间。&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="http://soliym.top/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="堆栈" scheme="http://soliym.top/tags/%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>2n皇后</title>
    <link href="http://soliym.top/2019/04/11/2n%E7%9A%87%E5%90%8E/"/>
    <id>http://soliym.top/2019/04/11/2n皇后/</id>
    <published>2019-04-11T12:37:08.115Z</published>
    <updated>2019-04-11T12:39:37.505Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。</p><a id="more"></a><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>　　输入的第一行为一个整数n，表示棋盘的大小。<br>　　接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>　　输出一个整数，表示总共有多少种放法。</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><p>4<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1</p><p>样例输出</p><p>2</p><p>样例输入</p><p>4<br>1 0 1 1<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1</p><p>样例输出</p><p>0</p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>2n皇后问题是在n皇后的问题上扩展而来，涉及搜索、模拟、n皇后问题，要解决2n皇后问题先要解决n皇后问题，n皇后在前面已经写了，现在来解决2n皇后的问题。</p><p>2n皇后实际是在在棋盘上先放一种皇后，然后再放另一种皇后，已经放过皇后的位置就不能再放皇后，所以首先记录白皇后的位置，然后再放黑皇后，需要一个二维数组来模拟棋盘，初始时，这个棋盘上是0或1，0表示不可以放皇后，1表示可以放皇后的，在开始放白皇后的时候，如果白皇后可以在棋盘上放置，那么记录该位置，将该位置标记为2，代表放置的是白皇后，当所有的白皇后放置完以后，计数器现在为n代表白皇后放置完，然后放置黑皇后，放置黑皇后时，如果放置位置是2那么，则代表位置是白皇后，那么该位置不能再放置黑皇后。按照放置白皇后的方法放置黑皇后。放置方法仍然采用回溯法。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><h5 id="放置位置检查是否合适"><a href="#放置位置检查是否合适" class="headerlink" title="放置位置检查是否合适"></a>放置位置检查是否合适</h5><h6 id="一种皇后算法"><a href="#一种皇后算法" class="headerlink" title="一种皇后算法"></a>一种皇后算法</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//皇后的放置位置是否合适</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//x为行，y为列</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y==a[i]||<span class="built_in">abs</span>(x-i)==<span class="built_in">abs</span>(y-a[i]))</span><br><span class="line"><span class="comment">//判断是否在同一列或同斜行</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="两种皇后算法"><a href="#两种皇后算法" class="headerlink" title="两种皇后算法"></a>两种皇后算法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x, int y,int s)//x为行，y为列</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for (i = 0; i &lt; x; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i])))</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在放置一种的基础上添加标志，当s==2时表示放置白皇后，所用到的是a数组，当s==3时，表示放置黑皇后，所用到的是c数组。a数组用来记录白皇后在各行的位置。c数组表示黑皇后在各行的位置。</p><h5 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h5><h6 id="一种皇后回溯"><a href="#一种皇后回溯" class="headerlink" title="一种皇后回溯"></a>一种皇后回溯</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void king(int k)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if(k==n)//如果n皇后符合位置，合法方案加一</span><br><span class="line">&#123;</span><br><span class="line">count++;//合法方案计数</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/</span><br><span class="line">&#123;</span><br><span class="line">a[k]=i;</span><br><span class="line">king(k+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="两种皇后回溯"><a href="#两种皇后回溯" class="headerlink" title="两种皇后回溯"></a>两种皇后回溯</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void king(int k,int s)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if (k == n)</span><br><span class="line">&#123;</span><br><span class="line">if (s==2)king(0, 3);//s==3时放置黑皇后</span><br><span class="line">else count++;//如果白皇后和黑皇后都等于n则计数器加一</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s))//与放置一种相比，增加两种条件，所放位置上不能等0或不能等2</span><br><span class="line">&#123;</span><br><span class="line">s==2?a[k] = i:c[k] = i;</span><br><span class="line">b[k][i] = s;//记录白皇后、黑皇后的位置</span><br><span class="line">king(k + 1,s);//第一行放置完，开始第二行</span><br><span class="line">b[k][i] = 1;//还原棋盘</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>编译器vs2017</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (y == (s==<span class="number">2</span>?a[i]:c[i]) || <span class="built_in">abs</span>(x - i) == <span class="built_in">abs</span>(y - (s == <span class="number">2</span> ? a[i] : c[i])))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">king</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (k == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s==<span class="number">2</span>)king(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">else</span> count++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b[k][i] != <span class="number">2</span> &amp;&amp; b[k][i] != <span class="number">0</span> &amp;&amp; check(k, i,s))</span><br><span class="line">&#123;</span><br><span class="line">s==<span class="number">2</span>?a[k] = i:c[k] = i;</span><br><span class="line">b[k][i] = s;</span><br><span class="line">king(k + <span class="number">1</span>,s);</span><br><span class="line">b[k][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    scanf_s(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;b[i][j]);</span><br><span class="line">king(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;h5 id=&quot;问题描述-1&quot;&gt;&lt;a href=&quot;#问题描述-1&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h5&gt;&lt;p&gt;给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://soliym.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="http://soliym.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>n皇后</title>
    <link href="http://soliym.top/2019/04/06/n%E7%9A%87%E5%90%8E/"/>
    <id>http://soliym.top/2019/04/06/n皇后/</id>
    <published>2019-04-06T10:10:57.536Z</published>
    <updated>2019-04-06T14:34:57.514Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>​        n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。</p><a id="more"></a><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>​       如果采用枚举法判断每一种情况，需要枚举n^2的组合数，如果n=8;南无需要枚举54502232次，如果n再增大，需要枚举的次数就太过庞大。所以采用回溯法，尽量减少不必要的循环，当问题达到边界时，返回上一层，不必再浪费资源。如果只考虑每一行放置一个皇后、每一列也只放置一个皇后。从第一行开始放置皇后，当第一行的皇后确定后，结束循环，开始从下一行开始放置皇后，且放置皇后的位置不能与前面的皇后在同一列或同一条对角线。需要一个判断函数，判定在该位置能否放置皇后。如果一行的所有位置都不能放置皇后，那么回溯至上一行。</p><h5 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h5><p>按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><h5 id="皇后位置比较算法"><a href="#皇后位置比较算法" class="headerlink" title="皇后位置比较算法"></a>皇后位置比较算法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x,int y)//皇后的放置位置是否合适</span><br><span class="line">&#123;//x为行，y为列</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(y==a[i]||abs(x-i)==abs(y-a[i]))</span><br><span class="line">//判断是否在同一列或同斜行</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>每一行放一个皇后，就解决了不在同行的问题。 </p></li><li><p>在第i行的时候，遍历n列，试探位置。和之前所有行放的位置进行比较。 </p></li><li>比较列：当前列col 不等于 之前 所有列。 即col != arr[i]。</li><li>比较斜线， 因为不再同一斜率为1或者-1的斜线。(row - i) / (col - arr[i]) != 1 或 -1 可以取巧用绝对值函数: abs(row-i) != abs(col-arr[i])。<h5 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h5></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void king(int k)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if(k==n)//如果n皇后符合位置，合法方案加一</span><br><span class="line">&#123;</span><br><span class="line">count++;//合法方案计数</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/</span><br><span class="line">&#123;</span><br><span class="line">a[k]=i;</span><br><span class="line">king(k+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  回溯每行放置一个皇后，记录每个皇后所在的列数，如果递归后的结果不符合，则回退至该位置，从该位置继续遍历。回溯的条件有两种，一种是在一行中没有找到适合放置皇后的位置，另一种是符合放置方案，然后回溯，寻找下一个方案。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y==a[i]||<span class="built_in">abs</span>(x-i)==<span class="built_in">abs</span>(y-a[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">king</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(k==n)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(check(k,i))</span><br><span class="line">&#123;</span><br><span class="line">a[k]=i;</span><br><span class="line">king(k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">king(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;​        n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://soliym.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="http://soliym.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
