<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>OSPF(二)</title>
      <link href="/2019/09/19/OSPF(%E4%BA%8C)/"/>
      <url>/2019/09/19/OSPF(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h5 id="7、OSPF-从邻居建立成为邻接关系的条件"><a href="#7、OSPF-从邻居建立成为邻接关系的条件" class="headerlink" title="7、OSPF 从邻居建立成为邻接关系的条件"></a>7、OSPF 从邻居建立成为邻接关系的条件</h5><h6 id="1、网络类型"><a href="#1、网络类型" class="headerlink" title="1、网络类型"></a>1、网络类型</h6><p>基于接口网络类型来区别：</p><p>接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的</p><a id="more"></a><p>点到点：在一个网段内只能存在两个节点，即便强制连接第三节点，最终也无法正常的通讯</p><p>​       串行链路上，二层封装为ppp或hdlc –没有物理寻址</p><p>MA：多路访问 –在一个网段内的节点数量不限制；</p><p>BMA： 广播型多路访问技术；在一个MA网络中同时存在广播机制；</p><p>​        二层封装技术为以太网；</p><p>NBMA：非广播型多路技术；在一个MA网络中没有广播机制；</p><p>​        二层封装技术为帧中继—串行链路   MGRE–点到点</p><p>在点到点网络中，OSPF协议正常均从邻居关系晋升为邻接关系；</p><p>在MA网络中，若所有邻居皆建立为邻接关系，将导致大量的重复更新；距离矢量路由协议在MA环境中使用了接口水平分割机制；由于OSPF协议是基于数据库同步对比的方式来进行收敛，故不支持接口的水平分割；</p><p>ospf最终将在MA网段进行DR/BDR的选举；非DR/BDR间将维持邻居关系，不建立邻接关系来避免重复更新；</p><h6 id="2、选举规则"><a href="#2、选举规则" class="headerlink" title="2、选举规则"></a>2、选举规则</h6><p>比较接口优先级  0-255 大优   </p><p> 默认点到点链路接口不行进行DR/BDR选举，故cisco 优先级为0-不参选  </p><p>MA网络中所有参选接口默认优选级为1，在优先级一致的情况必须参选设备的route-id数值大优；</p><p>干涉选举：修改参选接口的优先级</p><p>[r1-GigabitEthernet0/0/0]ospf dr-priority 2</p><p>因为选举非抢占，故修改优先级后，必须重启ospf协议进程</p><p><r1>reset ospf 1 process </r1></p><p>Warning: The OSPF process will be reset. Continue? [Y/N]:y</p><p>建议：网络存在DR/BDR后，其他设备修改为0，不参选；不需要重启设备的进程；</p><h6 id="8、OSPFlsa类型"><a href="#8、OSPFlsa类型" class="headerlink" title="8、OSPFlsa类型"></a>8、OSPFlsa类型</h6><p>1、OSPF的数据库表—LSDB 链路状态数据库</p><p>数据库表中装载OSPF的不同类型的LSA；</p><p>[r1]display  ospf lsdb  router   1.1.1.1     具体某条LSA</p><p>类别名   link-id</p><p>每条LSA均存在以下信息</p><p>  Type      : Router  类别名</p><p>  Ls id     : 1.1.1.1    link-id  在目录中番号</p><p>  Adv rtr   : 1.1.1.1    通告者的RID</p><p>  Ls age    : 532     老化时间 正常1800周期刷新，触发更新导致刷新；最大老化3609</p><p>  Len       : 60     长度</p><p>  Options   :  E      选项</p><p>  seq#      : 80000003   序列号</p><p>  chksum    : 0xb2ee     校验和码</p><p>OSPF的LSA是1800会更新一次序列号会加一</p><p>LSA的新旧比较</p><p>1、会先比较序列号，序列号越大越优，</p><p>2、如果序列号相同，会比较校验值（checksum)越大越优</p><p>3、如果校验值也相同，会比较LSA Age时间，是否等于MAX-age时间（3600）</p><p>4、如果age时间不等于max-age时间，会比较他们的差值，如果差值大15分钟（900秒），小的优</p><p>5、如果age时间不等于max-age时间，会比较他们的差值，如果差值小于15分钟，说明是同一条LSA，忽略其中一条</p><p>2、什么情况下LSA会更新：</p><p>1、1800到期会更新</p><p>2、触发更新（接口地址变化（增加，或删除），修改接口开销值，删除接口，或者删除通告）</p><p>[r4-ospf-1]import-route rip 1   将RIP进程1重发布到OSPF的进程1</p><p>[r5]display ospf lsdb ase originate-router  查看5类LSA</p><p>ASBR—自治系统边界路由器—协议边界路由器</p><p>3、LSA类型</p><p>LSA类别                 传播范围                         通告者                                    携带信息</p><p>LSA-1 router         本地设备所在区域     该区域每台设备的RID   每台设备本地所在区域的直连    拓扑</p><p>LSA-2 Network     本地设备所在区域                DR                     单个MA网段的拓扑</p><p>LSA-3 summary     整个OSPF域                       ABR                    域间路由</p><p>LSA-4 asbr             除ASBR所在的区域             ABR                   ASBR位置</p><p>​                              外的整个ospf域；               asbr                   所在区域基于1类交代位置</p><p>LSA-5 external      整个OSPF域                       ASBR                  域外路由</p><p>LSA-7 NSSA          本地的NSSA区域                ASBR                  域外路由</p><p>​                </p><p>LSA类别                    link-id                         通告者</p><p>LSA-1 router         通告者的RID                本区域内每台设备必须发送</p><p>LSA-2 Network      DR的接口ip地址          每个MA网段中的DR</p><p>LSA-3 summary     域间路由目标网络号     ABR，在经过下一台ABR时，修改为新的ABR的RID</p><p>LSA-4 asbr             ASBR的RID                 和ASBR同一区域的ABR，在经过下一台ABR时，修改为新的ABR的RID</p><p>LSA-5 external       域外路由目标网络号            ASBR</p><p>LSA-7 NSSA           域外路由目标网络号            ASBR；  离开本地NSSA区域时转换为5类</p><p>OSPF协议正常学习到的路由条目优先级为10；重发布进入的路由为150；</p><h6 id="9、LSA优化"><a href="#9、LSA优化" class="headerlink" title="9、LSA优化"></a>9、LSA优化</h6><p>优化OSPF协议，减少LSA的更新量；正常1类LSA是一台设备一条，2类lsa是一个网段的DR一条；3类和5类是一条路由一条LSA；4类是一台ASBR产生一条；</p><p>1、汇总—减少骨干区域的更新量</p><p>1）域间路由汇总—将非骨干区域汇总到骨干区域</p><p>在ABR上进行配置</p><p>[r1]ospf 1</p><p>[r1-ospf-1]area 2   只能汇总本地通过该区域1、2类LSA产生的路由</p><p>[r1-ospf-1-area-0.0.0.2]abr-summary 5.5.4.0 255.255.252.0 </p><p>注：汇总配置完成后，需要手工添加空接口防环路由</p><p>2）域外路由汇总；因为域外路由由ASBR重发布导入；故在导入的ASBR上进行配置</p><p>[r4]ospf 1</p><p>[r4-ospf-1]asbr-summary 99.1.0.0 255.255.252.0</p><p>2、特殊区域-减少非骨干区域的更新量—不能是骨干区域，不能存在的虚链路；</p><p>①不能存在ASBR</p><p>1、末梢区域 stub   拒绝4/5类的LSA；生成一条3类的缺省路由指向骨干区域</p><p>[r5]ospf 1   </p><p>[r5-ospf-1]area 2</p><p>[r5-ospf-1-area-0.0.0.2]stub</p><p>切记:该区域所有设备均需要定义为末梢区域；</p><p>2、完全末梢区域 在末梢区域的基础上，进一步拒绝3类lsa，仅保留一条3类的缺省；</p><p>先将该区域配置为末梢，区域然后仅在abr上定义完全即可；</p><p>[r1-ospf-1-area-0.0.0.2]stub no-summary</p><p>②存在ASBR</p><p>1、NSSA 非完全末梢区域—该区域拒绝其他区域的ASBR产生的4/5LSA；本地区域内ASBR产生的5类LSA，以7类在本区域传播，从本区域进入骨干区域时由ABR（新的ASBR）转换为5类，同时自动产生一条7的缺省指向骨干区域；</p><p>[r4]ospf</p><p>[r4-ospf-1]are 1</p><p>[r4-ospf-1-area-0.0.0.1]nssa  </p><p>本区域内所有设备均需配置</p><p>2、完全NSSA –在NSSA的基础上，进一步拒绝3的LSA；生成一条3类缺省指向骨干区域；</p><p>先将该区域配置为NSSA区域，然后仅在ABR上定义完全即可</p><p>[r3-ospf-1-area-0.0.0.1]nssa  no-summary</p><p>切记:考虑到ISP连接网络后，产生的缺省路由与OSPF特殊区域产生的缺省可能导致环路；</p><p>​     ISP连接到的哪个区域，那么该区域不能设定为任何的特殊区域；</p>]]></content>
      
      
      <categories>
          
          <category> CCNP/HCNP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSPF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OSPF(一)</title>
      <link href="/2019/09/19/OSPF(%E4%B8%80)/"/>
      <url>/2019/09/19/OSPF(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h4 id="一、动态路由协议"><a href="#一、动态路由协议" class="headerlink" title="一、动态路由协议"></a>一、动态路由协议</h4><p>1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。</p><a id="more"></a><p>2、动态路由协议分类：</p><p>​                   1、基于AS将路由协议分为IGP和EGP</p><p>​                         AS-自治系统    </p><p>​                                   0-65535  标准为2个字节   扩展为4个字节</p><p>​                                                   1-64511          公有</p><p>​                                                    64512-65535 私有</p><p>​                         IGP—内部网关路由协议（as之内使用）</p><p>​                                   RIP/OSPF/EIGRP(Cisco)/isis</p><p>​                                 EGP—外部网关路由协议（as之间使用）</p><p>​                                    BGP/EGP</p><p>​                   2、内部网关路由协议—IGP分类</p><p>​                         ①更新时是否携带子网掩码：有类别—不携带</p><p>​                                                                     无类别—携带</p><p>​                         ②工作特点：距离适量—RIP/EIGRP</p><p>​                                                                基于路由条目收敛</p><p>​                                             链路状态—OSPF/ISIS</p><p>​                                                               基于LSA收敛</p><h4 id="二、开放式最短路径优先协议"><a href="#二、开放式最短路径优先协议" class="headerlink" title="二、开放式最短路径优先协议"></a>二、开放式最短路径优先协议</h4><h5 id="1、OSPF协议特点"><a href="#1、OSPF协议特点" class="headerlink" title="1、OSPF协议特点"></a>1、OSPF协议特点</h5><p>适用范围：IGP</p><p>类型：链路状态型动态路由协议</p><p>算法：SPF算法  </p><p>封装：基于IP封装，协议号为89—跨层封装</p><p>版本：OSPFV2—IPV4、OSPFV3—IPV6</p><p>更新方式：组播或单播—224.0.0.5/224.0.0.6</p><p>​                      触发更新/周期更新—周期更新时间是30min</p><p>区域划分：OSPF需要合理规划IP地址和区域划分</p><p>​                 —目的：减少lsa数量、减少lsa传播范围、减少对资源的消耗</p><p>​                 —原因：OSPF需要消耗大量的路由器资源</p><p>metric计算：OSPF使用cost计算metric</p><p>​                    cost=参考带宽/链路实际带宽</p><p>​                    每条路由信息的metric值=该条路径上每段链路的cost值的总和</p><p>router-id：在网络内唯一标识一台路由器</p><h5 id="2、区域划分"><a href="#2、区域划分" class="headerlink" title="2、区域划分"></a>2、区域划分</h5><p>​     1、区域内传拓扑：</p><p>​          —用于每台路由器计算到达所有未知路径的最短路径</p><p>​          —拓扑信息：路由器之间的连接关系</p><p>​    2、 区域间传路由：</p><p>​           —区域间传递计算完成的路由信息</p><p>​           —路由信息：包含的接口的路由信息</p><p>​     3、区域标识：使用十进制或类似于ip地址的32位二进制</p><p>​     4、区域划分：基于链路（接口）</p><p>​     5、区域类型：骨干区域</p><p>​                            —区域0，必须存在且唯一</p><p>​                                  非骨干区域</p><p>​                           —非0区域</p><p>​     6、 路由器的角色：        </p><p>​           —骨干路由器：一个路由器的所有接口都在area 0中</p><p>​            —非骨干路由器：一个路由器的所有接口都不在area 0 中</p><p>​            —ABR：区域边界路由器：能够产生3类LSA的路由器既有接口属于area 0 又有接口属        于非area 0</p><p>​            —ASBR：自治系统边界路由器，能够产生5类或7类LSA的路由器，连接ospf网络和非ospf网络，并且将非ospf引入到ospf网络中</p><p>​       7、区域划分规则</p><p>​          ①OSPF网络中必须存在并唯一的骨干区域（若OSPF仅仅存在一个区域可以为非0区域）</p><p>​          ②非骨干区域必须与骨干区域直接相连（非骨干不能非骨干直接相连）</p><p>​     8、不规则区域：1.不连续的0区域     2.非骨干没有挂靠在骨干区域之上</p><h5 id="3、OSPF数据报"><a href="#3、OSPF数据报" class="headerlink" title="3、OSPF数据报"></a>3、OSPF数据报</h5><p>   OSPF数据包跨层封装于三层报头</p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="img"></p><p>五类数据报：</p><p>1、hello（224.0.0.5）：发现、建立、保活邻居关系、邻接关系</p><p>2、DBD-数据库描述包：本地链路状态数据库的目录</p><p>3、LSR-链路状态查询：根据DBD中的描述，对未知的lsa请求</p><p>4、LSU-链路状态更新：对请求的LSR的回复，携带lsa信息</p><p>5、LSACK-链路状态确认：确认包，保证lsa传递的可靠性</p><p>DBD：数据库描述数据包  使用隐式确认，分为两种：1.主从选举DBD-包含mtu，若不一致则停留在预启动   2.发送LSA头部摘要信息（LSA目录）</p><p>由于IP数据报不可靠，所以除hello外，其他数据包需要确认</p><p>DBD—序列号，显示或隐式确认</p><p>LSR—LSU</p><p>LSU—LSACK</p><h5 id="4、OSPF状态机"><a href="#4、OSPF状态机" class="headerlink" title="4、OSPF状态机"></a>4、OSPF状态机</h5><p>down：一旦收发hello，则进入下一状态</p><p>init—初始化：当接收到的hello中携带自己的router-id，则进入下一状态</p><p>2way—双发通信：邻居关系建立的标志</p><p>​             点到点网络直接进入下一状态，ma网路进行DR/BDR选举</p><p>​             条件匹配：若条件匹配成功，进入下一状态</p><p>​                              若条件匹配失败，停留在当前状态，依靠hello保活邻居关系</p><p>Exstart预启动:通过类hello包DBD进行主从关系选举，router-id大的为主，优先进入下一状态</p><p>​                 （通过主从选举确定先发送DBD的一方，确保传输的可靠性和对链路带宽的占用小）          如果mtu不相同则停留在该阶段</p><p>exchange准交换：使用真正的DBD包进行数据库目录的共享</p><p>loading 加载：使用LSR/LSU/LSack来获取未知的LSA信息</p><p>lsr–请求列表-针对每一条发送lsu</p><p>lsu–重传列表-对方收到lsu后发送ack确认，如果没收到，则重发</p><p>full转发:邻接关系建立的标志</p><h5 id="5、OSPF工作方式"><a href="#5、OSPF工作方式" class="headerlink" title="5、OSPF工作方式"></a>5、OSPF工作方式</h5><p>启动宣告配置完成后，路由器开始组播（224.0.0.5）收发OSPF的hello包；若接收到的hello包中存在本地的route-id，建立邻居关系，生成邻居表；</p><p>之后基于表格中所有的邻居进行条件的匹配，匹配失败将维持邻居关系，仅hello包周期保活即可；</p><p>匹配成功者间可以建立邻接关系；邻居间使用DBD进行数据库目录的比对；之后使用LSR查询目录中未知的LSA信息，对端使用LSU来携带传递LSA，最终需要LSack进行接收确认；</p><p>当本地收集到区域内所有设备的LSA后，生成LSDB—链路状态数据库表；</p><p>本地基于LSDB启用SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表内；</p><p>收敛完成，仅hello包周期保活所有的邻居和邻接关系；每30MIN周期进行DBD包的收发来进行纠错；</p><p>结构突变：</p><p>新增网段—直连新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛</p><p>断开网段—断开新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛</p><p>无法沟通—-dead time 和最大老化来解决</p><p>正常邻居间存在hello包，若超过dead time依然没有hello包，断开邻居关系，删除从该邻居处学习到的所有信息</p><p>若邻居关系依然正常，但每30min的周期没有正常进行，每条lsa后方存在一个老化时间，默认最大为3609s；到达最大老化时删除该LSA信息即可；</p><p>名词：</p><p>Router-ID：路由器标示符，用于标识该路由器在OSPF网络中的唯一性</p><p>选举规则：1.手工指定最优先    2.最大的环回接口地址  3.最大的物理接口</p><p>hello时间、dead时间：默认10、40或 30、120s</p><p>DR优先级 ：</p><p>DR：指定路由器</p><p>BDR：备份指定路由器</p><p>LSA：链路状态通告；在不同条件下存在不同类别的LSA，用于携带拓扑或路由</p><p>LSDB：链路状态数据库；所有LSA的集合</p><p>OSPF收敛行为—OSPF的LSA洪泛</p><p>​                           OSPF的LSDB同步</p><p>OSPF邻居关系建立条件：</p><p>1.router-ID必须不同    </p><p>2.area-ID必须一致</p><p>3.认证类型和认证型数据都一致   </p><p>4.hello时间、dead时间都一致  </p><p>5.特殊区域标识必须一致  </p><p>6.若在MA网络中，network mask必须一致</p><p>7.必须同时使用单播或组播</p><h5 id="6、OSPF基础配置"><a href="#6、OSPF基础配置" class="headerlink" title="6、OSPF基础配置"></a>6、OSPF基础配置</h5><h6 id="（一）cisco"><a href="#（一）cisco" class="headerlink" title="（一）cisco"></a>（一）cisco</h6><p>r1(config)#router ospf 1   启动时需要配置进程号，仅具有本地意义</p><p>r1(config-router)#router-id 1.1.1.1   配置RID，要求为全网唯一</p><p>​                              手工—环回接口最大数字—物理接口最大数字</p><p>宣告：1、激活  2、路由或拓扑   3、区域划分</p><p>r1(config-router)#network 1.1.1.1 0.0.0.0 area 0</p><p>r1(config-router)#network 12.1.1.0 0.0.0.255 area 0</p><p>​                                   反掩码</p><p>启动配置完成后，所有设备间使用hello包，发现并建立邻居关系，生成邻居表：</p><p>Hello time 为10s，dead time 为 hello time 的4倍；</p><p>r2#show ip ospf neighbor </p><p>Neighbor ID     Pri   State           Dead Time   Address         Interface</p><p>1.1.1.1           0   FULL/  -        00:00:34    12.1.1.1        Serial1/0</p><p>3.3.3.3           0   FULL/  -        00:00:39    23.1.1.2        Serial1/1</p><p>邻居关系建立后，邻居间进行条件匹配，匹配成功者间进入邻接关系；基于DBD/LSR/LSU/LSack获取未知LSA信息，生成LSDB–数据库表；</p><p>r2#show ip ospf database </p><p>LSDB同步完成后，本地使用SPF最短路径选路规则，将到达未知网段的路由加载路由表：</p><p>使用字母O标识通过OSPF学习的路由；</p><p>O      本地区域内的路由，是本地通过拓扑计算所得</p><p>O IA    域间路由，其他区域的路由，通过ABR共享进入的</p><p>管理距离为110；度量为cost值=开销值=参考带宽/接口带宽</p><p>默认参考带宽为100M；整段路径cost值之和最小为最佳路径；</p><p>注：当接口带宽大于参考带宽时，cost值为1；将可能导致选路不佳，建议修改参考带宽</p><p>r1(config)#router ospf 1 </p><p>r1(config-router)#auto-cost reference-bandwidth ?    </p><p>  <1-4294967>  The reference bandwidth in terms of Mbits per second</1-4294967></p><p>r1(config-router)#auto-cost reference-bandwidth 1000</p><p>切记：整个网络所有设备均需要修改一致；</p><p>【5】OSPF建立成为邻接关系的条件—-关注网络类型</p><p>点到点–在一个网段内只能存在两个节点</p><p>MA网络—在一个网段内节点数量不限制</p><p>在点到点网络ospf只能直接建立邻接关系；</p><p>在MA网络中为避免重复的更新，将进行DR/BDR选举，所有的非DR/BDR间仅建立邻居关系；DR/BDR与其他非DR/BDR建立邻接关系，基于224.0.0.6沟通；</p><p>选举规则：</p><p>比较接口优先级  0-255 大优  默认为1；</p><p>接口优先级若相同，比较RID；</p><p>r1(config)#interface fastEthernet 0/0</p><p>r1(config-if)#ip ospf priority 3  修改接口优先级</p><p>注：ospf选择非抢占的，因此在人为修改了优先级后，必须重启所有设备的OSPF进程</p><p>r1#clear ip ospf process </p><p>Reset ALL OSPF processes? [no]: yes</p><p>可以将设备的参选接口优先级修改为0,—-不参选；但至少留一台设备参选，否则将无DR,网络无法通行；</p><h6 id="（二）华为"><a href="#（二）华为" class="headerlink" title="（二）华为"></a>（二）华为</h6><p>[r1]ospf 1 router-id 1.1.1.1  启动时需要定义进程号，仅具有本地意义；  建议同时配置ROUTER-ID；</p><p>​                      手工—环回最大数值IP地址—物理接口最大数值IP地址</p><p>宣告：</p><p>[r2]ospf 1 router-id 2.2.2.2</p><p> [r2-ospf-1]area 0</p><p> [r2-ospf-1-area-0.0.0.0]network 12.1.1.2 0.0.0.0</p><p> [r2-ospf-1]area 1 </p><p> [r2-ospf-1-area-0.0.0.1]network 23.1.1.1 0.0.0.0</p><p>OSPF的区域划分规则：</p><p>星型结构—所有的非骨干区域必须连接到的骨干区域，否则不能进行区域间路由共享</p><p>ABR—区域边界路由器  同时工作的多个区域间；合法ABR必须同时工作在骨干区域，否则不能进行区域间的路由共享；</p><p>启动配置完成后，路由器间使用hello包收发建立邻居关系，生成邻居表：</p><p>[r2]display ospf peer</p><p>Area 0.0.0.0 interface 12.1.1.2(GigabitEthernet0/0/0)’s neighbors</p><p> Router ID: 1.1.1.1          Address: 12.1.1.1        </p><p>   State: Full  Mode:Nbr is  Slave  Priority: 1</p><p>   DR: 12.1.1.1  BDR: 12.1.1.2  MTU: 0    </p><p>   Dead timer due in 35  sec </p><p>   Retrans timer interval: 5 </p><p>   Neighbor is up for 00:18:48     </p><p>   Authentication Sequence: [ 0 ]</p><p>邻居关系建立后，邻居间进行条件的匹配；匹配成功建立邻接关系，同步LSDB完成后，本地生成LSDB—数据库表；</p><p>[r2]display ospf lsdb   查看数据库的目录；内部存在各种类别的信息，需要具体查看</p><p>LSDB同步完成后，本地基于SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表中；</p><p>[r3]display  ip routing-table  查看路由表</p><p>Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</p><p>​        1.1.1.1/32  OSPF    10   2           D   23.1.1.1        GigabitEthernet0/0/0</p><p>​        2.2.2.2/32  OSPF    10   1           D   23.1.1.1        GigabitEthernet0/0/0</p><p>[r3]display ip routing-table protocol ospf  查看本地所有通过OSPF协议学习到的路由</p><p>[r1]display ospf routing    查看本地工作OSPF的直连，及本地通过OSPF学习到的路由</p><p>Destination        Cost  Type       NextHop         AdvRouter       Area</p><p> 1.1.1.1/32         0     Stub       1.1.1.1         1.1.1.1         0.0.0.0</p><p> 12.1.1.0/24        1     Transit     12.1.1.1        1.1.1.1         0.0.0.0</p><p> 2.2.2.2/32         1     Stub       12.1.1.2        2.2.2.2         0.0.0.0</p><p> 3.3.3.3/32         2     Inter-area  12.1.1.2        2.2.2.2         0.0.0.0</p><p> 23.1.1.0/24        2     Inter-area  12.1.1.2        2.2.2.2         0.0.0.0</p><p>  类型标记为Inter-area 代表其他区域产生的路由条目</p><p>OSPF的度量值为cost=开销值=参考带宽/接口带宽</p><p>默认的参考带宽为100M；OSPF默认优选整段路径cost之和最小；</p><p>若接口带宽大于参考带宽，cost值为1；将可能导致选路的不佳，建议修改默认的参考带宽；</p><p>[r1]ospf 1</p><p>[r1-ospf-1]bandwidth-reference 1000</p><p>切记：一旦修改，全网所有设备均需修改为一致；</p><p>​             </p><p>​     </p><p>​      </p>]]></content>
      
      
      <categories>
          
          <category> CCNP/HCNP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSPF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EIGRP增强内部网关路由协议简述</title>
      <link href="/2019/09/02/EIGRP%E5%A2%9E%E5%BC%BA%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
      <url>/2019/09/02/EIGRP%E5%A2%9E%E5%BC%BA%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>EIGRP：增强内部网关路由协议</strong> <strong>— cisco</strong>私有的协议</p><p>无类别距离矢量协议，协议号88；组播更新：224.0.0.10</p><p>增量更新—仅触发、无周期更新—–可靠性、更新量小</p><p>支持非等开销负载均衡</p> <a id="more"></a><p>AD        本地下一跳到达目标的度量</p><p>FD       本地到达目标的度量</p><p>S         最佳路径的下一跳路由器</p><p>FS       备份路径的下一跳路由器</p><p>FC       可行性条件，成为备份路径的条件</p><p>【1】EIGRP的数据包</p><p>Hello 包       用于邻居发现、建立、保活   hello time  5s</p><p>Update包         路由条目–目标网络号+度量值</p><p>查询包                    查询路径，最佳路径和备份路径—-非等开销负载均衡</p><p>应答包         查询确认</p><p>ACK            </p><p>【2】EIGRP的4大组件 组建</p><p>Hello机制—-认识所有邻居</p><p>PDM —-支持多种网络层协议 （协议有关单元） 协议无关单元 IPX appletalk</p><p>RTP–可靠传输协议—-借鉴TCP的4种可靠机制–确认、重传、排序、流控（不能超过链路带宽的百分之50）</p><p>DUAL—扩散更新（弥散更新）算法</p><p>【3】EIGRP的工作过程</p><p>启动配置后，运行EIGRP协议的路由器，通过组播224.0.0.10向所有的邻居发送hello包；收到邻居的hello包后及表示认识了邻居，生成邻居表；</p><p>邻居关系建立后，邻居间使用更新包进行路由信息的共享；</p><p>收集到所有的路由条目后，本地生成–拓扑表；—装载所有的最佳和备份路径；</p><p>本地默认将拓扑表中的最佳路径全部加载到路由表内；—收敛完成</p><p>结构突变：</p><p>新增网段—直连新增网段的设备，使用更新包告知所有邻居即可</p><p>断开网段—-直连断开网段的设备，发出查询包，通过DUAL，收集应答包来重新收敛</p><p>无法沟通—-hello time 5s   hold time 15s</p><p>更新包、查询包、应答包–均被RTP服务    </p><p>接收到这三种包时，需要ACK来确认，若未进行确认将单播重传，最大16次，若依然失败断开邻居关系；RTP在转发这三种包时，还会对其进行排序和流控；</p><p>【4】EIGRP的配置</p><p>r1(config)#router eigrp ?    启动时需要配置AS号</p><p>  <1-65535>  Autonomous system number</1-65535></p><p>r1(config)#router eigrp 90   此处理解为全网一致的进程号；</p><p>r1(config-router)#   </p><p>r1(config-router)#no auto-summary   关闭自动汇总</p><p>宣告：激活     路由</p><p>r1(config-router)#network 1.0.0.0</p><p>r1(config-router)#network 124.1.1.1 0.0.0.0</p><p>EIGRP宣告时，可以向rip一样直接配置主类，也可以像OSPF一样使用反掩码进行匹配</p><p>启动配置完成后，邻居间使用hello包建立邻居关系，生成邻居表：</p><p>r2#show ip eigrp neighbors </p><p>IP-EIGRP neighbors for process 90</p><p>H   Address                 Interface       Hold Uptime   SRTT   RTO  Q  Seq</p><p>​                                            (sec)         (ms)       Cnt Num</p><p>2   124.1.1.4               Fa0/0             10 00:01:59   28   200  0  11</p><p>1   23.1.1.2                Se1/1             13 00:02:14   39   234  0  11</p><p>0   124.1.1.1               Fa0/0             13 00:02:19  389  2334  0  7</p><p>邻居关系建立后，邻居间使用更新包收敛路由信息，生成拓扑表：</p><p>本地到达邻居的最佳和备份路径；</p><p>r3(config)#interface s1/1</p><p>r3(config-if)#bandwidth 800   修改接口参考带宽</p><p>一个接口的实际传输带宽—-硬件、QOS；参考带宽并不影响实际传输带宽，只影响路由协议的选路；</p><p>r3#show ip eigrp topology </p><p>IP-EIGRP Topology Table for AS(90)/ID(3.3.3.3)</p><p>Codes: P - Passive, A - Active, U - Update, Q - Query, R - Reply,</p><p>​       r - reply Status, s - sia Status </p><p>P 1.1.1.0/24, 1 successors, FD is 2300416</p><p>​        via 23.1.1.1 (2300416/156160), Serial1/0   最佳</p><p>​        via 34.1.1.2 (3842560/156160), Serial1/1   备份</p><p>​                    FD      AD</p><p>FD可行距离 —- 本地通过该路径到达目标的度量</p><p>AD可行后继距离（通告距离）—-本地的下一跳到达目标的度量值</p><p>FC可行条件—-成为备份路径的条件  备份的AD小于不等于最佳路径的FD值</p><p>备份路径的意义在于可以和最佳路径一起完成非等开销负载均衡；</p><p>非等开销负载均衡：当到达一个目标地址时，若存在两条开销相近的路径时，可以让设备将流量按比例延这些路径同时传输，提高链路的利用率；</p><p>差异值：备份的FD/最佳路径的FD=向上取整</p><p>设备默认的差异值规定为1，标示仅支持等开销负载均衡</p><p>r3#show ip protocols </p><p>  EIGRP maximum metric variance 1</p><p>可以通过修改差异值，来实现非等开销负载均衡</p><p>r3(config)#router eigrp 90</p><p>r3(config-router)#variance 2</p><p>r3#show ip route 1.1.1.0</p><p>默认设备将最佳路径加载于路由表中：</p><p>D - EIGRP, EX - EIGRP external</p><p>使用字母D标示正常EIGRP学习的路由；</p><p>管理距离为90；</p><p>度量：复合度量—–各种参数</p><p>度量计算公式：存在权重值  </p><p>Formula with default K values (K1 = 1, K2 = 0, K3 = 1, K4 = 0, K5 = 0):</p><p>当K5为0时：</p><p>Metric = [K1 <em> BW + ((K2 </em> BW) / (256 – load)) + K3 * delay]</p><p>当K5大于0时:</p><p>Metric = [K1 <em> BW + ((K2 </em> BW) / (256 – load)) + K3 <em> delay]</em> [K5 / (reliability + K4)]</p><p>带宽 可靠性 延迟 负载 MTU</p><p>默认k值下度量计算为带宽+延时：</p><p>带宽=（10^7/整路径最小带宽）*256</p><p>延时=（整段路径入口的延时之和/10）*256</p><p>256为放大因子—-1、放大参数便于比较  2、兼容IGRP</p><p>【5】EIGRP的扩展配置</p><p>认证</p><p>r2(config)#key chain a</p><p>r2(config-keychain)#key 1</p><p>r2(config-keychain-key)#key-string cisco123</p><p>r2(config)#interface s1/1</p><p>r2(config-if)#ip authentication key-chain eigrp 90 a</p><p>r2(config-if)#ip authentication mode eigrp 90 md5 </p><p>注：EIGRP仅支持MD5认证，故在没有修改模式前，认证是无意义的</p><p>手工汇总–在更新源路由器上，所有更新发出接口上进行配置</p><p>r3(config)#interface s1/0</p><p>r3(config-if)#ip summary-address eigrp 90 3.3.2.0 255.255.254.0 </p><p>汇总配置完成后，在汇总设备上将自动产生指向汇总地址的空接口防环路由</p><p>被动接口–只接收不发送路由协议信息</p><p>​            用于连接用户的接口，不能用于连接邻居的接口</p><p>r3(config)#router eigrp 90</p><p>r3(config-router)#passive-interface loopback 0</p><p>加快收敛  hello 5s     hold time15s</p><p>r3(config)#interface s1/1</p><p>r3(config-if)#ip hello-interval eigrp 90 5</p><p>r3(config-if)#ip hold-time eigrp 90 15</p><p>缺省路由—在边界路由器上向所有直连内网的接口上进行汇总配置，汇总地址0.0.0.0/0；</p><p>​             但边界路由器需要静态缺省指向ISP</p><p>r1(config)#interface fastEthernet 0/0</p><p>r1(config-if)#ip summary-address eigrp 90 0.0.0.0 0.0.0.0</p>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EIGRP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OSPF开放最短路径优先协议简述</title>
      <link href="/2019/09/02/OSPF%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/"/>
      <url>/2019/09/02/OSPF%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="一、开放式最短路径优先协议"><a href="#一、开放式最短路径优先协议" class="headerlink" title="一、开放式最短路径优先协议"></a>一、开放式最短路径优先协议</h5><p> OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。</p><a id="more"></a><p>OSPFv2用于ipv4网络，OSPFv3用在ipv6网络。可用于大型网络。</p><h5 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h5><p><strong>链路状态</strong></p><p>OSPF路由器收集其所在网络区域上各路由器的连接状态信息，即链路状态信息（Link-State），生成链路状态数据库(Link-State Database)。路由器掌握了该区域上所有路由器的链路状态信息，也就等于了解了整个网络的拓扑状况。OSPF路由器利用“最短路径优先算法(Shortest Path First, SPF)”，独立地计算出到达任意目的地的路由。</p><p><strong>区域</strong></p><p>OSPF协议引入“分层路由”的概念，将网络分割成一个“主干”连接的一组相互独立的部分，这些相互独立的部分被称为“区域”(Area)，“主干”的部分称为“主干区域”。每个区域就如同一个独立的网络，该区域的OSPF路由器只保存该区域的链路状态。每个路由器的链路状态数据库都可以保持合理的大小，路由计算的时间、报文数量都不会过大。</p><p><strong>共有五种区域的主要区别在于它们和外部路由器间的关系：</strong></p><p><strong>标准区域</strong>: 一个标准区域可以接收链路更新信息和路由总结。</p><p><strong>主干区域</strong>(传递区域):主干区域是连接各个区域的中心实体。主干区域始终是“区域0”，所有其他的区域都要连接到这个区域上交换路由信息。主干区域拥有标准区域的所有性质。</p><p><strong>存根区域</strong>（stub Area）：存根区域是不接受自治系统以外的路由信息的区域。如果需要自治系统以外的路由，它使用默认路由0.0.0.0。</p><p><strong>完全存根区域</strong>：它不接受外部自治系统的路由以及自治系统内其他区域的路由总结。需要发送到区域外的报文则使用默认路由：0.0.0.0。完全存根区域是Cisco自己定义的。 </p><p><strong>不完全存根区域**</strong>(NSAA)**: 它类似于存根区域，但是允许接收以LSA Type 7发送的外部路由信息，并且要把LSA Type 7转换成LSA Type 5。</p><p>OSPF中的四种路由器</p><p>在OSPF多区域网络中，路由器可以按不同的需要同时成为以下四种路由器中的几种： </p><p>\1. 内部路由器：所有端口在同一区域的路由器，维护一个链路状态数据库。 </p><p>\2. 主干路由器：具有连接主干区域端口的路由器。 </p><p>\3. 区域边界路由器(ABR)：具有连接多区域端口的路由器，一般作为一个区域的出口。ABR为每一个所连接的区域建立链路状态数据库，负责将所连接区域的路由摘要信息发送到主干区域，而主干区域上的ABR则负责将这些信息发送到各个区域。 </p><p>\4. 自治域系统边界路由器(ASBR)：至少拥有一个连接外部自治域网络（如非OSPF的网络）端口的路由器，负责将非OSPF网络信息传入OSPF网络。</p><p>OSPF路由器之间交换链路状态公告(LSA)信息。OSPF的LSA中包含连接的接口、使用的Metric及其他变量信息。OSPF路由器收集链接状态信息并使用SPF算法来计算到各节点的最短路径。</p><p><strong>协议类型</strong></p><p>Hello报文，通过周期性地发送来发现和维护邻接关系；     </p><p>​            存在router ID—-RID 全网唯一的编号，使用ip地址</p><p>DBD(链路状态数据库描述)报文，描述本地路由器保存的LSDB(链路状态数据库)；</p><p>LSR(LS Request)报文，向邻居请求本地没有的LSA；</p><p>LSU(LS Update)报文，向邻居发送其请求或更新的LSA；</p><p>LSAck(LS ACK)报文，收到邻居发送的LSA后发送的确认报文。</p><p>OSPF网络类型</p><p>根据路由器所连接的物理网络不同，OSPF将网络划分为四种类型：广播多路访问型（Broadcast multiAccess）、非广播多路访问型（None Broadcast MultiAccess，NBMA）、点到点型（Point-to-Point）、点到多点型（Point-to-MultiPoint）。 </p><p>指派路由器（DR）和备份指派路由器（BDR）</p><p>在多路访问网络上可能存在多个路由器，为了避免路由器之间建立完全相邻关系而引起的大量开销，OSPF要求在区域中选举一个DR。每个路由器都与之建立完全相邻关系。DR负责收集所有的链路状态信息，并发布给其他路由器。选举DR的同时也选举出一个BDR，在DR失效的时候，BDR担负起DR的职责。 </p><p>点对点型网络不需要DR，因为只存在两个节点，彼此间完全相邻。 协议组成OSPF协议由Hello协议、交换协议、扩散协议组成。</p><p>当路由器开启一个端口的OSPF路由时，将会从这个端口发出一个Hello报文，以后它也将以一定的间隔周期性地发送Hello报文。OSPF路由器用Hello报文来初始化新的相邻关系以及确认相邻的路由器邻居之间的通信状态。 </p><p>对广播型网络和非广播型多路访问网络，路由器使用Hello协议选举出一个DR。在广播型网络里，Hello报文使用多播地址224.0.0.5周期性广播，并通过这个过程自动发现路由器邻居。在MA网络中，DR负责向其他路由器逐一发送Hello报文。</p><h5 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h5><p>一般用于同一个路由域内。在这里，路由域是指一个自治系统（Autonomous System），即AS，它是指一组通过统一的路由政策或路由协议互相交换路由信息的网络。在这个AS中，所有的OSPF路由器都维护一个相同的描述这个AS结构的数据库，该数据库中存放的是路由域中相应链路的状态信息，OSPF路由器正是通过这个数据库计算出其OSPF路由表的。</p><h5 id="四、工作工程"><a href="#四、工作工程" class="headerlink" title="四、工作工程"></a>四、工作工程</h5><h6 id="1、数据包"><a href="#1、数据包" class="headerlink" title="1、数据包"></a>1、数据包</h6><p>5种基本数据包</p><p>HELLO—邻居的发现、建立、保活</p><p>DBD—–数据库描述包—数据库目录信息</p><p>LSR—–链路状态请求</p><p>LSU—–链路状态更新—携带各种LSA</p><p>LSACK—链路状态确认</p><h5 id="2、OSPF的状态机–描述接口状态"><a href="#2、OSPF的状态机–描述接口状态" class="headerlink" title="2、OSPF的状态机–描述接口状态"></a>2、OSPF的状态机–描述接口状态</h5><p>Down：本地一旦发出hello包，进入下一状态</p><p>Init–初始化：本地接收到的hello包中若存在本地的RID，进入下一状态</p><p>2way–双向通信：邻居关系建立的标志</p><p>条件匹配：点到点网络直接进入下一个状态；MA网络将进行DR/BDR选举（40s），非DR/BDR间不能进入下一个状态；</p><p>Exstart–预启动：使用类hello的BDB包进行主从关系选举，RID数值大为主，主从优先进入下一个状态。</p><p>Exchange–准交换：使用真正的BDB进行数据库目录的共享，需要ACK；</p><p>LOding–加载：使用LSR/LSU/LSack来获取未知的LSA信息；</p><p>Full–转发：邻接关系建立的标志；</p><h6 id="3、工作过程"><a href="#3、工作过程" class="headerlink" title="3、工作过程"></a>3、工作过程</h6><p>1、启动配置完成后，本地收发hello包，建立邻居关系，生成邻居表；</p><p>2、再进行条件的匹配，匹配失败将停留于邻居关系，仅hello包保活即可；</p><p>3、匹配成功者之间建立邻接关系，需要DBD共享数据库目录，LSR/LSU/LSack来获取未知的LSA信息，当收集完网络中所有的LSA后，生成数据表–LSDB</p><p>4、LSDB建立完成后，本地基于OSPF选路规则，计算本地到达所有未知网段的最短路径，然后将其加载到路由表中，完成收敛。</p><p>5、收敛完成后–hello包周期保活–30分钟周期的BDB比对，若不一致将会使用LSR/LSU/LSack重新获取</p><h6 id="4、配置"><a href="#4、配置" class="headerlink" title="4、配置"></a>4、配置</h6><p>配置</p><p>R1(config)#router ospf 100                    创建/进入OSPF进程100</p><p>R1(config-router)#router-id 1.1.1.1              指定Router-id，不指定则为环回地址，没有环回则为物理接                          口地址</p><p>R1(config-router)#network 12.1.1.1 0.0.0.0 area 0  可在接口内配置，IP ospd 100 area 0</p><p>​                    1、路由 2、激活 3、区域</p><p>OSPF三种表</p><p>邻居表</p><p>R2#show ip ospf neighbor</p><p>Neighbor ID     Pri   State           Dead Time   Address         Interface</p><p>1.1.1.1           1   FULL/DR         00:00:39    12.1.1.1        FastEthernet1/0</p><p>拓扑表</p><p>R2#show ip ospf database</p><p>​            OSPF Router with ID (2.2.2.2) (Process ID 100)</p><p>​                Router Link States (Area 0)</p><p>Link ID         ADV Router      Age         Seq#       Checksum Link count</p><p>1.1.1.1         1.1.1.1         90          0x80000005 0x00BF34 2</p><p>2.2.2.2         2.2.2.2         458         0x80000003 0x00BA04 3</p><p>​                Net Link States (Area 0)</p><p>Link ID         ADV Router      Age         Seq#       Checksum</p><p>12.1.1.1        1.1.1.1         470         0x80000001 0x004AD0</p><p> 路由表</p><p>R2#show ip ospf route</p><p>​            OSPF Router with ID (2.2.2.2) (Process ID 100)</p><p>​    Area BACKBONE(0)</p><p>​    Intra-area Route List</p><p>*   12.1.1.0/24, Intra, cost 1, area 0, Connected</p><p>​      via 12.1.1.2, FastEthernet1/0</p><p>*   23.1.1.0/24, Intra, cost 1, area 0, Connected</p><p>​      via 23.1.1.2, FastEthernet1/1</p><p>*&gt;  1.1.1.1/32, Intra, cost 2, area 0</p><p>​      via 12.1.1.1, FastEthernet1/0</p><p>*   2.2.2.2/32, Intra, cost 1, area 0, Connected</p><p>​      via 2.2.2.2, Loopback0</p><p>R2#show ip route ospf</p><p>​     1.0.0.0/32 is subnetted, 1 subnets</p><p>O       1.1.1.1 [110/2] via 12.1.1.1, 00:01:50, FastEthernet1/0</p><p>区域划分的规则：</p><p>星型结构 其他区域要和骨干域相连 </p><p>需要存在ABR 区域边界路由器</p><p>​                  通告者             内容</p><p>1类LSA  router  路由器本身         链路状态</p><p>2类LSA  network   DR             描述MA网络</p><p>3类LSA  sumary   ABR             路由条目</p><p>成为邻接关系的条件</p><p>1、如果在串行链路上 直接形成邻接关系</p><p>2、如果是以太网环境 只和DR/BDR形成邻接关系</p><p>选举规则</p><p>先比较优先级  越大越优先</p><p>比较Router-ID 越大越优先</p><p>非抢占性</p><p>修改优先级</p><p>R1(config)#int f0/0</p><p>R1(config-if)#ip ospf priority 2</p><p>干涉选择方法：</p><p>修改DR优先级最大，BDR次大；该选举非抢占，故必须手动重启所有设备进程</p><p>R2#clear ip ospf process </p><p>Reset ALL OSPF processes? [no]: y</p><p>修改DR优先级最大，BDR次大；将其他路由器修改为0</p><p>扩展配置：</p><p>认证</p><p>明文认证：</p><p>R2(config)#int s1/0</p><p>R2(config-if)#ip ospf authentication</p><p>R2(config-if)#ip ospf authentication-key 1 cisco</p><p>密文认证：</p><p>R2(config)#int f0/0</p><p>R2(config-if)#ip ospf authentication message-digest </p><p>R2(config-if)#ip ospf message-digest-key 1 md5 cisco</p><p>区域明文认证：</p><p>R3(config)#router ospf 100</p><p>R3(config-router)#area 0 authentication </p><p>区域密文认证：</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#area 1 authentication message-digest </p><p>被动接口</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#passive-interface loopback 0</p><p>加快收敛速度</p><p>R1(config)#int s1/1</p><p>R1(config-if)#ip ospf hello-interval 5     修改hello时间为5s dead time自动四倍关系</p><p>R1(config-if)#ip ospf dead-interval 20</p><p>链路两端必须一致</p><p>缺省路由</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#default-information originate </p><p>需要有缺省路由指向ISP</p><p>R1(config)#ip route 0.0.0.0 0.0.0.0 loopback 10</p><p>强制下放缺省</p><p>R1(config)#router ospf 100</p><p>R1(config-router)#default-information originate always</p>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSPF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RIP路由信息简述</title>
      <link href="/2019/09/02/RIP%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E7%AE%80%E8%BF%B0/"/>
      <url>/2019/09/02/RIP%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="RIP：路由信息协议"><a href="#RIP：路由信息协议" class="headerlink" title="RIP：路由信息协议"></a>RIP：路由信息协议</h4> <a id="more"></a><h5 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a><strong>1.</strong> <strong>定义：</strong></h5><p>路由信息协议（英语：Routing Information Protocol，缩写：RIP）是一种内部网关协议（IGP），为最早出现的距离向量路由协议。属于网络层，可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等。</p><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议， RIP协议要求网络中每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。RIP协议将“距离”定义为：从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为每经过一个路由器则距离加1。“距离”也称为“跳数”。RIP允许一条路径最多只能包含15个路由器，因此，距离等于16时即为不可达。可见 RIP协议只适用于小型互联网，并不适用于复杂网络的情况。</p><h5 id="2-特点："><a href="#2-特点：" class="headerlink" title="2. 特点："></a>2. 特点：</h5><p>（1）仅和相邻的路由器交换信息。如果两个路由器之间的通信不经过另外一个路由器，那么这两个路由器是相邻的。RIP协议规定，不相邻的路由器之间不交换信息。</p><p>（2）路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。</p><p>（3）按固定时间交换路由信息，如，每隔30秒，然后路由器根据收到的路由信息更新路由表。（也可进行相应配置使其触发更新）</p><h5 id="3-版本："><a href="#3-版本：" class="headerlink" title="3.版本："></a>3.版本：</h5><h6 id="（1）版本"><a href="#（1）版本" class="headerlink" title="（1）版本"></a>（1）版本</h6><p>​       RIPv1:使用有类路由，在它的路由更新(Routing Updates)中并不带有子网的资讯，因此它无法支援可变长度子网掩码。这个限制造成在RIPv1的网络中，在同级网络下无法使用不同的子网掩码。换句话说，在同一个网络下所有的子网络数目都是相同的。另外，它也不支援对路由过程时的认证，使得RIPv1有一些轻微的弱点，有机会遭受到可能的攻击。</p><p>​       RIPv2：因为RIPv1的缺陷，RIPv2在1994年被提出，与RIP1最大的不同是RIP2为一个无类别路由协议，其更新消息中携带子网掩码，它支持VLSM、CIDR、认证和多播。另外针对安全性的问题，RIPv2也提供一套方法，未透过加密来达到认证的效果。而之后[RFC 2082]也定义了利用MD5来达到认证的方法。</p><p>​       RIPng：主要是针对IPv6做一些延伸的规范。与RIPv2相比下其最主要的差异是：RIPv2支援RIP更新认证, RIPng 则不支持，因为IPv6路由器理应会使用IPsec来进行身份验证；RIPv2 容许给路由器附上任何标签， RIPng 则不容许；</p><p>RIPv2 在每个路由表项中都保存下一跳的信息，RIPng是对一组路由表项指定下一跳信息；RIPv2 使用UDP端口520和多播地址224.0.0.9通信，RIPng 则使用UDP端口521和多播地址FF02::9通信。</p><h6 id="（2）总结RIPv1和RIPv2的区别"><a href="#（2）总结RIPv1和RIPv2的区别" class="headerlink" title="（2）总结RIPv1和RIPv2的区别"></a>（2）总结RIPv1和RIPv2的区别</h6><p>1.RIPv1是有类路由协议（不携带掩码），RIPv2是无类路由协议（携带掩码）</p><p>2.RIPv1不能支持VLSM，RIPv2可以支持VLSM</p><p>3.RIPv1没有认证的功能，RIPv2可以支持认证，并且有明文和MD5两种认证</p><p>4.RIPv1没有手工汇总的功能，RIPv2可以在关闭自动汇总的前提下，进行手工汇总</p><p>5.RIPv1是广播更新，RIPv2是组播更新，</p><p>6.RIPv1对路由没有标记的功能，RIPv2可以对路由打标记（tag），用于过滤和做策略</p><p>7.RIPv1发送的updata最多可以携带25条路由条目，RIPv2在有认证的情况下最多只能携带24条路由</p><p>8.RIPv1发送的updata包里面没有next-hop属性，RIPv2有next-hop属性，可以用与路由更新的重定</p><h5 id="4-工作原理："><a href="#4-工作原理：" class="headerlink" title="4. 工作原理："></a>4. 工作原理：</h5><p>​       （1）初始化——RIP[1]初始化时，会从每个参与工作的接口上发送请求数据包。该请求数据包会向所有的RIP路由器请求一份完整的路由表。该请求通过LAN上的广播形式发送LAN或者在点到点链路发送到下一跳地址来完成。这是一个特殊的请求，向相邻设备请求完整的路由更新。 　　</p><p>​       （2）接收请求——RIP有两种类型的消息，响应和接收消息。请求数据包中的每个路由条目都会被处理，从而为路由建立度量以及路径。RIP采用跳数度量，值为1的意为着一个直连的网络，16，为网络不可达。路由器会把整个路由表作为接收消息的应答返回。 　　</p><p>​       （3）接收到响应——路由器接收并处理响应，它会通过对路由表项进行添加，删除或者修改作出更新。 　　</p><p>​       （4）常规路由更新和定时——路由器以30秒一次地将整个路由表以应答消息地形式发送到邻居路由器。路由器收到新路由或者现有路由地更新信息时，会设置一个180秒地超时时间。如果180秒没有任何更新信息，路由的跳数设为16。路由器以度量值16宣告该路由，直到刷新计时器从路由表中删除该路由。刷新计时器的时间设为240秒，或者比过期计时器时间多60秒。Cisco还用了第三个计时器，称为抑制计时器。接收到一个度量更高的路由之后的180秒时间就是抑制计时器的时间，在此期间，路由器不会用它接收到的新信息对路由表进行更新，这样能够为网路的收敛提供一段额外的时间。 　　</p><p>​       （5）触发路由更新——当某个路由度量发生改变时，路由器只发送与改变有关的路由，并不发送完整的路由表。</p><h5 id="5-RIP防环机制"><a href="#5-RIP防环机制" class="headerlink" title="5. RIP防环机制"></a>5. RIP防环机制</h5><p>5.1 记数最大值（maximum hop count）：定义最大跳数（最大为15跳），当跳数为16跳时,目标为不可达。</p><p>5.2 水平分割（split horizon）：从一个接口学习到的路由不会再广播回该接口。</p><p>5.3 毒性逆转水平分割（poison reverse）：从一个接口学习的路由会发送回该接口，但是已经被毒化，跳数设置为16跳，不可达。</p><p>5.4 触发更新（trigger update）：一旦检测到路由崩溃，立即广播路由刷新报文，而不等到下一刷新周期。</p><p>5.5 抑制计时器（holddown timer）：防止路由表频繁翻动，增加了网络的稳定性。</p><h5 id="6-RIP路由更新机制"><a href="#6-RIP路由更新机制" class="headerlink" title="6. RIP路由更新机制"></a>6. RIP路由更新机制</h5><p>RIP协议有两种更新机制：一是定期更新，二是触发更新。“定期更新”是根据设置的更新计时器定期发送RIP路由通告。该通告报文中携带了除“水平分割”机制抑制的RIP路由之外本地路由器中的所有RIP路由信息。而“触发更新”则是RIP路由器仅在有路由表项发生变化时发送的RIP路由通告，仅携带本地路由表中有变化的路由信息。RIP路由器一旦察觉到网络变化，就尽快甚至是立即发送更新报文，而不等待更新周期结束。只要触发更新的速度足够快，就可以大大地防止“计数到无穷大”的发生，但是这一现象还是有可能发生的。</p><p>无论是定期更新，还是触发更新，RIP路由的更新规则如下：</p><p>l  如果更新的某路由表项在路由表中没有，则直接在路由表中添加该路由表项；</p><p>l  如果路由表中已有相同目的网络的路由表项，且来源端口相同，那么无条件根据最新的路由信息更新其路由表；</p><p>l  如果路由表中已有相同目的网络的路由表项，但来源端口不同，则要比较它们的度量值，将度量值较小的一个作为自己的路由表项；</p><p>l  如果路由表中已有相同目的网络的路由表项，且度量值相等，保留原来的路由表项。</p><h5 id="7、Rip基础配置"><a href="#7、Rip基础配置" class="headerlink" title="7、Rip基础配置"></a>7、Rip基础配置</h5><p>1）RIPV1</p><p>r1(config)#router rip    启动协议</p><p>r1(config-router)#version 1   选择版本1，若不进行版本选举，默认为升级版本1；</p><p>r1(config-router)#network 1.0.0.0 主类地址—-RIP在宣告时，只能定义主类的范围</p><p>clear ip route *  刷新路由表</p><p>2）RIPV2</p><p>r1(config)#router rip</p><p>r1(config-router)#version 2选择版本2</p><p>r1(config-router)#no auto-summary 关闭自动汇总；</p><p>r1(config-router)#network 12.0.0.0</p><h5 id="8、RIP扩展配置"><a href="#8、RIP扩展配置" class="headerlink" title="8、RIP扩展配置"></a>8、RIP扩展配置</h5><h6 id="1、RIPV2的认证"><a href="#1、RIPV2的认证" class="headerlink" title="1、RIPV2的认证"></a>1、RIPV2的认证</h6><p>​        运行了RIP协议的邻居间，进行身份的核实</p><p>先定制key，再在同邻居直连的接口上调用</p><p><strong>指令：</strong></p><p>r1(config)#key chain xxx</p><p>r1(config-keychain)#key 1</p><p>r1(config-keychain-key)#key-string cisco123   邻居间必须一致</p><p>r1(config)#interface s1/1</p><p>r1(config-if)#ip rip authentication key-chain xxx</p><p>r1(config-if)#ip rip authentication mode md5   模式也必须一致</p><h6 id="2、RIPV2的手工汇总"><a href="#2、RIPV2的手工汇总" class="headerlink" title="2、RIPV2的手工汇总"></a>2、RIPV2的手工汇总</h6><p>在更新源路由器上向所有更新发出的接口上配置</p><p>r2(config)#interface s1/0</p><p>r2(config-if)#ip summary-address rip 2.2.2.0 255.255.254.0 如果在接口中汇总多个路由，则选择掩码短的</p><h6 id="3、被动接口"><a href="#3、被动接口" class="headerlink" title="3、被动接口"></a>3、被动接口</h6><p>仅接收不发送路由协议信息；只能用于连接用户的接口，不得用于连接邻居的接口</p><p>r1(config)#router rip            </p><p>r1(config-router)#passive-interface loopback 0</p><h6 id="4、加快收敛"><a href="#4、加快收敛" class="headerlink" title="4、加快收敛"></a>4、加快收敛</h6><p>RIP计时器    30s 更新  180s失效   180s抑制  240s刷新</p><p>​      适当的修改计时器，可以加快设备的收敛速度</p><p>​      建议修改时维持原有的倍数关系，且不易修改的过小；全网所有设备均修改</p><p>r1(config)#router rip</p><p>r1(config-router)#timers basic 15 90 90 120</p><h6 id="5、缺省路由"><a href="#5、缺省路由" class="headerlink" title="5、缺省路由"></a>5、缺省路由</h6><p>在边界路由器上配置RIP缺省后，内部的路由器将自动生成缺省路由指向边界路由器；边界路由器到达ISP的缺省路由，宣告手工静态配置</p><p>r3(config)#router rip</p><p>r3(config-router)#default-information originate </p>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DHCP工作原理</title>
      <link href="/2019/09/02/DHCP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2019/09/02/DHCP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>DHCP 全称Dynamic Host configuration protocol， 动态主机配置协议。 它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数，</p> <a id="more"></a><h4 id="一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上-UDP头，IP头、链路层头-也有一些差别"><a href="#一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上-UDP头，IP头、链路层头-也有一些差别" class="headerlink" title="一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上(UDP头，IP头、链路层头)也有一些差别"></a>一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上(UDP头，IP头、链路层头)也有一些差别</h4><p>​      </p><h5 id="1）DHCP-Discover"><a href="#1）DHCP-Discover" class="headerlink" title="1）DHCP Discover"></a>1）DHCP Discover</h5><p>DHCP客户端请求地址时，并不知道DHCP服务器的位置，因此DHCP客户端会在本地网络内以广播方式发送请求报文，这个报文成为Discover报文，目的是发现网络中的DHCP服务器，所有收到Discover报文的DHCP服务器都会发送回应报文，DHCP客户端据此可以知道网络中存在的DHCP服务器的位置。</p><h5 id="2）DHCP-Offer"><a href="#2）DHCP-Offer" class="headerlink" title="2）DHCP Offer"></a>2）DHCP Offer</h5><p>DHCP服务器收到Discover报文后，就会在所配置的地址池中查找一个合适的IP地址，加上相应的租约期限和其他配置信息(如网关、DNS服务器等)，构造一个Offer报文，发送给用户(可以广播、也可以单播)，告知用户本服务器可以为其提供IP地址。(注意，只是告诉client可以提供，是预分配，还需要client通过ARP检测该IP是否重复)</p><h5 id="3）DHCP-Request"><a href="#3）DHCP-Request" class="headerlink" title="3）DHCP Request"></a>3）DHCP Request</h5><p>客户端会在两种情况下发送DHCP Request</p><p>a）DHCP客户端可能会收到来自DHCP服务器的很多Offer，所以必须在这些回应中选择一个。Client通常选择第一个回应Offer报文的服务器作为自己的目标服务器，并回应一个广播Request报文，通告选择的服务器。注意，”Client通常选择第一个回应Offer报文的服务器作为自己的目标服务器”这里存在一个安全问题，如果我们的伪DHCP服务器能比原始DHCP服务器先发送Offer数据包，就能达到欺骗的目的，从而劫持目标用户的流量</p><p>b）获取DHCP客户端成功获取IP地址后，在地址使用租期过去1/2时，会向DHCP服务器发送单播Request报文续延租期，如果没有收到DHCP ACK报文，在租期过去3/4时，会再次发送广播Request报文续延租期。</p><h5 id="4）DHCP-ACK"><a href="#4）DHCP-ACK" class="headerlink" title="4）DHCP ACK"></a>4）DHCP ACK</h5><p>DHCP服务器收到Request报文后，根据Request报文中携带的用户MAC来查找有没有相应的租约记录(即之前的预分配过程中登记的那个MAC)，如果有则发送ACK报文作为回应，通知用户可以使用分配的IP地址。</p><h5 id="5）-DHCP-NAK"><a href="#5）-DHCP-NAK" class="headerlink" title="5） DHCP NAK"></a>5） DHCP NAK</h5><p>如果DHCP服务器收到Request报文后，没有发现有相应的租约记录或者由于某些原因无法正常分配IP地址，则发送NAK报文作为回应，通知用户无法分配合适的IP地址。</p><h5 id="6）DHCP-Release"><a href="#6）DHCP-Release" class="headerlink" title="6）DHCP Release"></a>6）DHCP Release</h5><p>当用户不再需要使用分配IP地址时，就会”主动”向DHCP服务器发送Release报文，告知服务器用户不再需要分配IP地址，DHCP服务器会释放被绑定的租约(在数据库中清除某个MAC对某个IP的租约记录，这样，这个IP就可以分配给下一个请求租约的MAC)</p><h5 id="7-DHCP-Decline"><a href="#7-DHCP-Decline" class="headerlink" title="\7. DHCP Decline"></a>\7. DHCP Decline</h5><p>DHCP客户端收到DHCP服务器回应的ACK报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送Decline报文，通知服务器所分配的IP地址不可用，我们在手工设置静态IP、或者DHCP分配中有时会遇到”检测到IP冲突”的提示就是因为客户端利用ARP机制来在当前内网中确认当前指定的IP是否已经被占用</p><h5 id="8）DHCP-Inform"><a href="#8）DHCP-Inform" class="headerlink" title="8）DHCP Inform"></a>8）DHCP Inform</h5><p>DHCP客户端如果需要从DHCP服务器端获取更为详细的配置信息，则发送Inform报文向服务器进行请求，服务器收到该报文后，将根据租约进行查找，找到相应的配置信息后，发送ACK报文回应DHCP客户端。</p><h4 id="二、DHCP协议的本质"><a href="#二、DHCP协议的本质" class="headerlink" title="二、DHCP协议的本质"></a>二、DHCP协议的本质</h4><p>DHCP使用UDP进行报文的传输。在主机DHCP获得地址之前，主机并没有有效的IP地址，它是通过受限广播IP地址（全1），当该地址作为目的地址时，子网内的所有主机都能收到该IP数据报。IP层的广播实际上是基于链路层的广播来实现的，所以这里有个前提，即链路层具有广播功能，在以太网中，目的地址为全1的MAC地址可作为链路上的广播地址。只要数据包能够正确到达主机IP层UDP的端口上，则应用程序就能收到该端口上的广播IP包，这正是DHCP设备能正确获得IP地址的本质。</p><p>DHCP客户端使用固定端口号68，而服务器使用固定端口号67。</p><p>DHCP由三种机制分配IP地址：</p><p> 1.自动分配方式：DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器租用到IP地址，就可以永久使用该地址。</p><p> 2.动态分配方式：DHCP服务器给主机指定一个有时间限制的IP地址， 时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。</p><p>  3.手工分配方式：客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。 </p><p>三种地址分配方式中， 只有动态分配方式可以重复使用客户端不再需要的地址</p><h4 id="三、DHCP工作流程"><a href="#三、DHCP工作流程" class="headerlink" title="三、DHCP工作流程"></a>三、DHCP工作流程</h4><p><img src="/2019/09/02/DHCP工作原理/D:/网站文件\personalblog\hexo\source\_posts\DHCP工作原理\DHCP.png" alt=""></p><p>1、客户端以广播的方式发送DHCP_DISCOVER报文，广播的范围的服务器都能接收到该报文。</p><p>2、所有的DHCP服务器都会对该报文进行响应，向DHCP客户端发送DHCP_OFFER报文，报文中的     Your（Client）IP Address字段携带了分配给客户端的IP地址，同时服务器的IP地址放在报文中的option字段中以便客户端可以区分，服务器分配后IP地址给客户端后，会把该地址分配记录下来。</p><p>3、DHCP客户端可能收到多个服务器的DHCP_OFFER报文，但是它只能对其中的一个做响应，通常DHCP客户端处理最先收到的DHCP_OFFER报文并响应。</p><p>4、DHCP客户端从DHCP_OFFER报文中提取可使用的IP地址和服务器IP地址后，会发出个广播的DHCP_REQUST报文，并在选项字段中加入选中的DHCP服务器的IP地址和自己要的IP地址。</p><p>5、DHCP服务器收到DHCP_REQUST报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP服务器不做任何处理，然后清除相应IP地址分配记录；如果相同，DHCP服务器就会向客户端发送一个DHCP_ACK报文，并在报文选项字段中增加IP地址的使用租期信息。</p><p>6、DHCP客户端接收到DHCP_ACK报文后，会检查服务器分配的IP地址是否能够使用（发送一个ARP请求到网络中，如果无主机回应该请求，则表示该地址可用）。如果可以使用，则客户端成功获得IP地址会根据IP地址使用租期自动启动续延过程；如果DHCP客户端发现分配的IP地址已经被使用，则需要向DHCP服务器发出一个DHCP_DECLINE报文，通知DHCP服务器禁用这个IP地址，此后，DHCP客户端重新开始上述地址申请流程。</p><p>7、客户端在使用租期超过50%或87.5%时，会以广播播形式向DHCP服务器发送DHCP_REQUST报文来续租IP地址。如果DHCP客户端成功收到服务器返回的DHCP_ACK报文，则按相应时间延长IP地址租期；如果没有收到服务器返回的的DHCP_ACK报文，则DHCP 客户端继续使用这个IP地址，直到IP地址使用租期到期。当租期到期后，DHCP客户端会向DHCP服务器发送一个DHCP_RELEASE报文来释放这个IP地址，并开始新的IP地址申请过程。</p><p>8、最后需要指出的是，DHCP服务器发送的DHCP_OFFER报文中的IP地址不一定是最后分配给客户端的IP地址，通常情况下，DHCP服务器会保留该地址直到客户端发出DHCP_REQUEST请求。在整个协商过程中，如果DHCP客户端发送的DHCP_REQUEST报文中的地址信息不正确，如客户端已经迁移到新的子网或者租约已经过期，DHCP服务器会发送DHCP_NAK报文给DHCP客户端，让客户端重新发起地址申请过程。</p><h4 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h4><p>DHCP配置：</p><p>R1(config)#ip dhcp pool ccna(dhcp服务器名称）</p><p>R1(dhcp-config)#network 172.16.1.0 255.255.255.0</p><p>R1(dhcp-config)#default-router 172.16.1.1</p><p>R1(dhcp-config)#dns-server 8.8.8.8</p><p>排除地址：</p><p>排除单个地址</p><p>R1(config)#ip dhcp excluded-address 172.16.1.254</p><p>排除一段地址</p><p>R1(config)#ip dhcp excluded-address 172.16.1.100 172.16.1.200</p><p>​                               起始地址   结束地址</p>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RHCSA-Linux基础命令（一）</title>
      <link href="/2019/06/17/RHCSA-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/06/17/RHCSA-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="Linux的基本原则"><a href="#Linux的基本原则" class="headerlink" title=">Linux的基本原则"></a>>Linux的基本原则</h4><p>1、由目的单一的小程序组成      </p><p>2、一切皆文件，设备的访问入口也是文件</p><p>3、避免捕获用户接口，尽量不和用户交互</p><p>4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。</p><a id="more"></a><h5 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h5><p>>命令  </p><p>>命令  参数   </p><p>>命令   -选项       </p><p>>命令   -选项    参数   </p><h5 id="修改命令的执行特性"><a href="#修改命令的执行特性" class="headerlink" title="修改命令的执行特性"></a>修改命令的执行特性</h5><p>短选项        -l</p><p>多个选项可以组合</p><p>长格式        –long</p><p>​          参数        指定命令的作用对象</p><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a><strong>基础命令</strong></h4><p><strong>重启：reboot</strong></p><p><strong>关机：shutdown -h now，poweroff</strong></p><p><strong>ip a</strong>  <strong>/ ifconfig</strong>   查看ip地址</p><p><strong>dhclient</strong>  地址请求，打开网络模式</p><p><strong>kill -9 ID</strong>  结束相应的进程（命令   -选项    参数）</p><p><strong>pwd</strong>  指出当前工作环境    print workdoing directory </p><p><strong>su</strong>       切换到root用户并不切换环境（工作目录） switch user </p><p><strong>su - root</strong>    切换到root用户并切换环境(切换了工作目录)</p><p><strong>cd</strong>        切换目录  change directroy</p><p>​        绝对路径        从根开始到目标的路径叫绝对路径</p><p>​        相对路径        相对当前目录开始到目标路径  </p><p>​        /   根</p><p>​        ~   家目录 /root /home/redhat  </p><p>​        ~ USERNAME(root用户有权限)        直接切换到指定用户的家目录</p><p>​        -        在上一个目录和当前目录来回切换</p><p>​        .   当前目录</p><p>​        ..  上一级目录</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a><strong>passwd</strong></h4><ol><li>修改密码：<strong>passwd</strong> <strong>用户名</strong>    直接输入passwd修改当前用户的密码</li><li><p>删除密码：<strong>passwd -d</strong> <strong>用户名</strong></p></li><li><p>root用户：不需要输入原密码，可以不符合密码复杂性规则，可以给任何人修改密码</p></li><li><p>普通用户：需要输入原密码，必须符合密码复杂性规则，passwd修改密码无法指定用户 </p></li><li><p>[student@localhost ~]$ <strong>su -c passwd</strong>普通用户给root用户修改密码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> RHCSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RHCSA-Linux简介</title>
      <link href="/2019/06/17/RHCSA-Linux%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/06/17/RHCSA-Linux%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h5><p>操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。</p><p>操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。</p><a id="more"></a><p>>&gt;硬件：框架</p><h5 id="冯诺依曼体系结构："><a href="#冯诺依曼体系结构：" class="headerlink" title="冯诺依曼体系结构："></a>冯诺依曼体系结构：</h5><p>1946年美籍凶牙利科学家冯诺依曼提出存储程序原理，把程序本身当做数据来对待，程序和该程序处理数据用同样的方式存储，并确定了存储程序计算机的五大组成部分和基本工作方法。</p><p>特点：</p><p>（1）计算机处理数据和指令一律用二进制数表示</p><p>（2）顺序执行程序</p><p>计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序 从主存储器中取出指令一条一条的执行，这一概念称为顺序执行程序。</p><p>（3）计算机硬件由运算器、控制器、存储器、输入设备、输出设备五大部分组成。</p><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.jpg" alt="img"></p><p>memory：编址存储设备</p><p>假设我们的存储器为一个长条，其中每八位（bit）作为一个单元，我们把它称为字节byte，字节又称为cell。</p><p>机器语言：二进制指令 （但是对于编程 人员来说二进制语言太难懂（太简陋，太底层），但是程序员想用简单点的语言去描述计算机又不懂所以两者之间不能耦合可以加一个中间层–编译器）</p><p>   汇编语言： 仅是将二进制转为人类语言想接近的语言或者是与人类语言符号相同的类型（+ and/plus）</p><p>   所以任何一款芯片制造商他们都把机器的代码也就是机器语言提供一个较为简单的稍微向上一点的但任然很简陋的编程接口叫做汇编语言（微码编程语言）</p><h5 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h5><p>​     —-汇编语言： （低级语言）   </p><p>​            应用：驱动程序</p><p>汇编语言（assembly language）是一种用于<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA/191373" target="_blank" rel="noopener">电子计算机</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/104320" target="_blank" rel="noopener">微处理器</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8/6688343" target="_blank" rel="noopener">微控制器</a>或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用<a href="https://baike.baidu.com/item/%E5%8A%A9%E8%AE%B0%E7%AC%A6/489287" target="_blank" rel="noopener">助记符</a>（Mnemonics）代替<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/8553126" target="_blank" rel="noopener">机器指令</a>的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%A0%81/3220418" target="_blank" rel="noopener">操作码</a>，用地址符号（Symbol）或标号（Label）代替指令或<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0/7658270" target="_blank" rel="noopener">操作数</a>的地址。在不同的设备中，汇编语言对应着不同的机器语言<a href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86/238130" target="_blank" rel="noopener">指令集</a>，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。</p><p>​    eg：操作：寄存器BX的内容送到AX中</p><p>​     1000100111011000              机器指令</p><p>​      mov ax,bx                    汇编指令</p><p>（注意：最终识别的还是01二进制数所以还需要将汇编语言转换为二进语言所以需要用到汇编器）</p><p>​      —-(高级语言)：比较接近人类的思维逻辑    —-(编译器)    </p><p>​               系统级：  c    c++  </p><p>​                     适用场合大型的对性能要求比较高的服务类程序   如：oracle  mysql linux windows /</p><p>​               应用级：java  python  ruby         </p><h5 id="系统调用的层级关系-系统组成结构"><a href="#系统调用的层级关系-系统组成结构" class="headerlink" title="系统调用的层级关系(系统组成结构)"></a><strong>系统调用的层级关系(系统组成结构</strong>)</h5><p><img src="file:///C:/Users/ASUS/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image002.jpg" alt="应 用 程 序  用 户 宁 间  庄 》 ib r 地  系 铳 啁 用  内 核 窄 间  安 全 功 能  进 程 管 理  文 件 管 理  0 百 理  网 络 管 理  内 存 一 百 理  件 抽 层 "></p><h5 id="操作系统内核的功能："><a href="#操作系统内核的功能：" class="headerlink" title="操作系统内核的功能："></a>操作系统内核的功能：</h5><p>系统调用接口</p><p>程序管理</p><p>内存管理，虚拟内存—内存交换    </p><p>文件系统管理    </p><p>设备驱动</p>]]></content>
      
      
      <categories>
          
          <category> RHCSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见排序算法（1）</title>
      <link href="/2019/05/16/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
      <url>/2019/05/16/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>排序算法是算法中最重要、最基础的算法，也是编程中用到最多的算法。不论是竞赛还是面试时，排序算法都是最常见的考点，下面根据排序思想不同，给出常见的几种排序算法。</p><a id="more"></a><h4 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h4><p>基本思想：在一个已排好序的基础上，每一步将下个待排序的记录有序插入到已排好的记录子集中，直到所有的待排序记录全部插入到序列中。</p><h5 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h5><p>算法思想：将第i个数据插到前面i-1个以排好的数据中。</p><p>例如：48 62 35 77 55 14 35* 98</p><p>a  ｛48｝ 62 35 77 55 14 35* 98</p><p>b  ｛48 62｝ 35 77 55 14 35* 98</p><p>c    ｛35 48 62｝77 55 14 35* 98</p><p>。。。。。。。。。。。。。。。</p><p>算法过程：保留第i个数据，将第i个数据依次和前面i-1个数据比较，如果大于其中某一个数据，则停止，将第I个数据插入到此数据后一位，在每次比较中，较大的数据向后移动一位（排序为从小到大）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void InsSort(int r[],int length)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=2;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r[0]=r[j];//采用首地址保存第i个元素,并且防止数组越界</span><br><span class="line">        int j=i-1;</span><br><span class="line">        while(r[0]&lt;r[j])&#123;</span><br><span class="line">            r[j+1]=r[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        r[j+1]=r[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序的时间复杂度为T(n)=O(n^2),空间复杂度，空间复杂度为S（n）=O(1);</p><p>直接插入排序是稳定的排序方法。当有两个相同元素时，他们的相对位置不发生改变。</p><h5 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h5><p>算法思想：在直接插入的思想中加入折半查找的思想，提高查找效率。</p><p>基本的排序方法不变，只是在查找的过程中做出改变，前面的查找为顺序查找，从第i-1个元素按顺序查找到第1个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void BinSort（int r[],int length）</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=2;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int r[0]=r[i];</span><br><span class="line">        int low=1,high=i-1;</span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=(low+high)/2;</span><br><span class="line">            if(r[0]&lt;r[mid]) high=mid-1;</span><br><span class="line">            else low=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=i-1;j&gt;=low;j--)</span><br><span class="line">          r[j+1]=r[j];</span><br><span class="line">        r[low]=r[0];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半插入排序是由直接插入排序改良而来，在原有的基础上加入折半查找，折半查找是一种非常重要的计算机思维，在很多地方都有应用。</p><p>虽然折半插入是由直接插入改进而来，但是时间复杂度并没用改变多少，仍然为0（n^2）;</p><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><p>在插入排序中，希尔排序是最佳的排序算法，也是比较难理解的算法。</p><p>例：</p><p> 初始             46  55  13   42  94  17  05  70 </p><p>d=4               <strong><em>46</em></strong>  17  05   42  <strong><em>94</em></strong>   55 13  70</p><p>d=2               05  17  13   42  46   55  94 70 </p><p>d=1               05  13   17  42  46   55  70 94 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void   shellInSort(int r[],int length,int delta)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1+delta;i&lt;=length,i++)//delta为增量d</span><br><span class="line">    &#123;</span><br><span class="line">        if(r[i]&lt;r[i-delta])//子序列最后一个元素和第一个元素比较</span><br><span class="line">        ｛</span><br><span class="line">        r[0]=r[i];</span><br><span class="line">        for(int j=i-delta;j&gt;0&amp;&amp;r[0]&lt;r[j];j-=delta)</span><br><span class="line">           r[j+delta]=r[j];</span><br><span class="line">          r[j+delta]=r[0];</span><br><span class="line">        ｝</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void shellSort(int r[],int length,int delta[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;=n-1;i++)</span><br><span class="line">      shellInSort(r,length,delta[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于增量d的选取：</p><p>shell  ： d=n/2;d=d/2……..d=1;</p><p>knuth:    d=d/3+1;</p><p>时间复杂度：O（n^1.5）;</p><p>注意：希尔排序是一种不稳定的排序；</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.5)</td><td>O(1)</td><td>不稳定</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c关于堆栈的划定</title>
      <link href="/2019/05/14/c%E5%85%B3%E4%BA%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%88%92%E5%AE%9A/"/>
      <url>/2019/05/14/c%E5%85%B3%E4%BA%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%88%92%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h4 id="c语言-全局变量与局部变量的划分"><a href="#c语言-全局变量与局部变量的划分" class="headerlink" title="c语言 全局变量与局部变量的划分"></a>c语言 全局变量与局部变量的划分</h4><p>在做背包问题的时候遇到这样的问题，定义一个二维数组变量，该变量的大小为1000*1000，但是在运行时报错，显示“Stack overflow ”，说明在此处超过了栈的空间。</p><a id="more"></a><p><img src="/2019/05/14/c关于堆栈的划定/D:/网站文件\personalblog\hexo\source\_posts\c关于堆栈的划定\溢出.png" alt=""></p><h5 id="c-c-内存分配"><a href="#c-c-内存分配" class="headerlink" title="c/c++内存分配"></a>c/c++内存分配</h5><h6 id="栈区-stack-sagment"><a href="#栈区-stack-sagment" class="headerlink" title="栈区(stack sagment)"></a>栈区(stack sagment)</h6><p>由编译器自动分配释放，存放函数的参数的值，局部变量的值等。在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M(也有的是1M，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><h6 id="堆区-heap-sagment"><a href="#堆区-heap-sagment" class="headerlink" title="堆区(heap sagment)"></a>堆区(heap sagment)</h6><p> 一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收 。它与数据结构中的堆是两回事。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><h6 id="全局区-静态区-data-sagment"><a href="#全局区-静态区-data-sagment" class="headerlink" title="全局区(静态区)(data sagment)"></a>全局区(静态区)(data sagment)</h6><p>全局变量和静态变量的存储区域是在一起的，程序结束后由系统释放。数据区的大小由系统限定，一般很大。</p><p>因为栈区的大小是编译器分配好的，如果变量的空间过大就会有栈的溢出问题，因此变量的类型是局部变量还是全局变量要根据变量大小选择，一版来说只有用到数组要考虑溢出问题，比如long、double都是固定长度大小的。如果数组的大小大于1000*1000就要考虑溢出问题，而全局变量的大小是有系统规定的，一般都很大。全局变量大小可达G以上。</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>open vswitch</title>
      <link href="/2019/04/19/open-vswitch/"/>
      <url>/2019/04/19/open-vswitch/</url>
      
        <content type="html"><![CDATA[<h3 id="open-vswitch实验"><a href="#open-vswitch实验" class="headerlink" title="open vswitch实验"></a>open vswitch实验</h3><p>在Terminal下对ovs交换机进行测试；</p><p>对ovs交换机和端口的创建；对端口号的修改，配置完ovs以后查看交换机的状态，以及两个端口号的测试。</p><a id="more"></a><h4 id="ovs各模块"><a href="#ovs各模块" class="headerlink" title="ovs各模块"></a>ovs各模块</h4><table><thead><tr><th>ovs-vswitched</th><th>主要模块</th></tr></thead><tbody><tr><td>ovsdb-server</td><td>轻量级数据库服务器</td></tr><tr><td>ovs-dpctl</td><td>配置switch内核</td></tr><tr><td>ovs-vsctl</td><td>c查询和更新交换机配置</td></tr><tr><td>ovs-appctl</td><td>f发送命令消息</td></tr></tbody></table><h4 id="ovs常用操作"><a href="#ovs常用操作" class="headerlink" title="ovs常用操作"></a>ovs常用操作</h4><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>添加网桥</td><td>ovs-vsctl add-br 交换机名</td></tr><tr><td>删除网桥</td><td>ovs-vsctl del-br 交换机名</td></tr><tr><td>添加端口</td><td>ovs-vsctl add-port 交换机名  端口号</td></tr><tr><td>删除端口</td><td>ovs-vsctl del-port 交换机名  端口号</td></tr><tr><td>连接控制器</td><td>ovs-vsctl set-controller 交换机名 tcp:ip 地址：端口号</td></tr><tr><td>断开控制器</td><td>ovs-vsctl del-controller 交换机名</td></tr><tr><td>列出所有网桥（交换机）</td><td>ovs-vsctl list-br</td></tr><tr><td>列出网桥中的所有端口</td><td>ovs-vsctl list-port 交换机名</td></tr><tr><td>列出所有连接到网卡的网桥</td><td>ovs-vsctl port-to-br 端口号</td></tr><tr><td>查看ovs网络状态</td><td>ovs-vsctl show</td></tr><tr><td>查看ovs端口信息</td><td>ovs-vsctl show 交换机名</td></tr><tr><td>修改端口号</td><td>ovs-vsctl set Interface 端口名 ofport_request=新端口号</td></tr></tbody></table><p>以上为ovs经常用到的操作，也是最基础的操作。下面开始ovs的测试实验。</p><h4 id="open-vswitch"><a href="#open-vswitch" class="headerlink" title="open vswitch"></a>open vswitch</h4><h5 id="ovs交换机创建"><a href="#ovs交换机创建" class="headerlink" title="ovs交换机创建"></a>ovs交换机创建</h5><p>创建一个名为ovs-switch的交换机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ovs-vsctl add-br ovs-switch</span><br></pre></td></tr></table></figure><h5 id="端口的配置"><a href="#端口的配置" class="headerlink" title="端口的配置"></a>端口的配置</h5><p>配置一个端口号，名为p0,并设置网络接口为;intrenal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ovs-vsctl set Interface p0 type=internal</span><br></pre></td></tr></table></figure><p>设置端口号，如果不自己设置，端口号由系统随机设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ovs-vsctl set Interface 端口名 ofport_request=新端口号</span><br></pre></td></tr></table></figure><h5 id="虚拟网络空间配置"><a href="#虚拟网络空间配置" class="headerlink" title="虚拟网络空间配置"></a>虚拟网络空间配置</h5><p>避免与本地网络地址发生冲突，需要创建一个虚拟网络空间，将接口放入当中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns add ns0</span><br><span class="line">sudo ip link set p0 netns ns0</span><br><span class="line">sudo ip netns exec ip addr add 192.168.1.100/24dev p0</span><br><span class="line">sudoip netns ecev ns0 ifconfig p0 promisc up</span><br></pre></td></tr></table></figure><p>创建一个名为ns0的虚拟网络空间，并将端口p0放入其中，给端口p0配置ip 192.168..1.100</p><h5 id="查看ovs交换机"><a href="#查看ovs交换机" class="headerlink" title="查看ovs交换机"></a>查看ovs交换机</h5><p>查看ovs交换机的各个接口属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ovs-vsctl show</span><br></pre></td></tr></table></figure><h5 id="测试端口"><a href="#测试端口" class="headerlink" title="测试端口"></a>测试端口</h5><p>两个端口之间相互测试，需要创建两个端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns exec ns0 ping 192.168.1.101</span><br></pre></td></tr></table></figure><p>192.168.1.101为第二个端口的ip</p>]]></content>
      
      
      <categories>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vswitch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2n皇后</title>
      <link href="/2019/04/11/2n%E7%9A%87%E5%90%8E/"/>
      <url>/2019/04/11/2n%E7%9A%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。</p><a id="more"></a><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>　　输入的第一行为一个整数n，表示棋盘的大小。<br>　　接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>　　输出一个整数，表示总共有多少种放法。</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><p>4<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1</p><p>样例输出</p><p>2</p><p>样例输入</p><p>4<br>1 0 1 1<br>1 1 1 1<br>1 1 1 1<br>1 1 1 1</p><p>样例输出</p><p>0</p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>2n皇后问题是在n皇后的问题上扩展而来，涉及搜索、模拟、n皇后问题，要解决2n皇后问题先要解决n皇后问题，n皇后在前面已经写了，现在来解决2n皇后的问题。</p><p>2n皇后实际是在在棋盘上先放一种皇后，然后再放另一种皇后，已经放过皇后的位置就不能再放皇后，所以首先记录白皇后的位置，然后再放黑皇后，需要一个二维数组来模拟棋盘，初始时，这个棋盘上是0或1，0表示不可以放皇后，1表示可以放皇后的，在开始放白皇后的时候，如果白皇后可以在棋盘上放置，那么记录该位置，将该位置标记为2，代表放置的是白皇后，当所有的白皇后放置完以后，计数器现在为n代表白皇后放置完，然后放置黑皇后，放置黑皇后时，如果放置位置是2那么，则代表位置是白皇后，那么该位置不能再放置黑皇后。按照放置白皇后的方法放置黑皇后。放置方法仍然采用回溯法。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><h5 id="放置位置检查是否合适"><a href="#放置位置检查是否合适" class="headerlink" title="放置位置检查是否合适"></a>放置位置检查是否合适</h5><h6 id="一种皇后算法"><a href="#一种皇后算法" class="headerlink" title="一种皇后算法"></a>一种皇后算法</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//皇后的放置位置是否合适</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//x为行，y为列</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y==a[i]||<span class="built_in">abs</span>(x-i)==<span class="built_in">abs</span>(y-a[i]))</span><br><span class="line"><span class="comment">//判断是否在同一列或同斜行</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="两种皇后算法"><a href="#两种皇后算法" class="headerlink" title="两种皇后算法"></a>两种皇后算法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x, int y,int s)//x为行，y为列</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for (i = 0; i &lt; x; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i])))</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在放置一种的基础上添加标志，当s==2时表示放置白皇后，所用到的是a数组，当s==3时，表示放置黑皇后，所用到的是c数组。a数组用来记录白皇后在各行的位置。c数组表示黑皇后在各行的位置。</p><h5 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h5><h6 id="一种皇后回溯"><a href="#一种皇后回溯" class="headerlink" title="一种皇后回溯"></a>一种皇后回溯</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void king(int k)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if(k==n)//如果n皇后符合位置，合法方案加一</span><br><span class="line">&#123;</span><br><span class="line">count++;//合法方案计数</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/</span><br><span class="line">&#123;</span><br><span class="line">a[k]=i;</span><br><span class="line">king(k+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="两种皇后回溯"><a href="#两种皇后回溯" class="headerlink" title="两种皇后回溯"></a>两种皇后回溯</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void king(int k,int s)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if (k == n)</span><br><span class="line">&#123;</span><br><span class="line">if (s==2)king(0, 3);//s==3时放置黑皇后</span><br><span class="line">else count++;//如果白皇后和黑皇后都等于n则计数器加一</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s))//与放置一种相比，增加两种条件，所放位置上不能等0或不能等2</span><br><span class="line">&#123;</span><br><span class="line">s==2?a[k] = i:c[k] = i;</span><br><span class="line">b[k][i] = s;//记录白皇后、黑皇后的位置</span><br><span class="line">king(k + 1,s);//第一行放置完，开始第二行</span><br><span class="line">b[k][i] = 1;//还原棋盘</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>编译器vs2017</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (y == (s==<span class="number">2</span>?a[i]:c[i]) || <span class="built_in">abs</span>(x - i) == <span class="built_in">abs</span>(y - (s == <span class="number">2</span> ? a[i] : c[i])))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">king</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (k == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s==<span class="number">2</span>)king(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">else</span> count++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b[k][i] != <span class="number">2</span> &amp;&amp; b[k][i] != <span class="number">0</span> &amp;&amp; check(k, i,s))</span><br><span class="line">&#123;</span><br><span class="line">s==<span class="number">2</span>?a[k] = i:c[k] = i;</span><br><span class="line">b[k][i] = s;</span><br><span class="line">king(k + <span class="number">1</span>,s);</span><br><span class="line">b[k][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    scanf_s(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;b[i][j]);</span><br><span class="line">king(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>n皇后</title>
      <link href="/2019/04/06/n%E7%9A%87%E5%90%8E/"/>
      <url>/2019/04/06/n%E7%9A%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>​        n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。</p><a id="more"></a><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>​       如果采用枚举法判断每一种情况，需要枚举n^2的组合数，如果n=8;南无需要枚举54502232次，如果n再增大，需要枚举的次数就太过庞大。所以采用回溯法，尽量减少不必要的循环，当问题达到边界时，返回上一层，不必再浪费资源。如果只考虑每一行放置一个皇后、每一列也只放置一个皇后。从第一行开始放置皇后，当第一行的皇后确定后，结束循环，开始从下一行开始放置皇后，且放置皇后的位置不能与前面的皇后在同一列或同一条对角线。需要一个判断函数，判定在该位置能否放置皇后。如果一行的所有位置都不能放置皇后，那么回溯至上一行。</p><h5 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h5><p>按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><h5 id="皇后位置比较算法"><a href="#皇后位置比较算法" class="headerlink" title="皇后位置比较算法"></a>皇后位置比较算法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool check(int x,int y)//皇后的放置位置是否合适</span><br><span class="line">&#123;//x为行，y为列</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(y==a[i]||abs(x-i)==abs(y-a[i]))</span><br><span class="line">//判断是否在同一列或同斜行</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>每一行放一个皇后，就解决了不在同行的问题。 </p></li><li><p>在第i行的时候，遍历n列，试探位置。和之前所有行放的位置进行比较。 </p></li><li>比较列：当前列col 不等于 之前 所有列。 即col != arr[i]。</li><li>比较斜线， 因为不再同一斜率为1或者-1的斜线。(row - i) / (col - arr[i]) != 1 或 -1 可以取巧用绝对值函数: abs(row-i) != abs(col-arr[i])。<h5 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h5></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void king(int k)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if(k==n)//如果n皇后符合位置，合法方案加一</span><br><span class="line">&#123;</span><br><span class="line">count++;//合法方案计数</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/</span><br><span class="line">&#123;</span><br><span class="line">a[k]=i;</span><br><span class="line">king(k+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  回溯每行放置一个皇后，记录每个皇后所在的列数，如果递归后的结果不符合，则回退至该位置，从该位置继续遍历。回溯的条件有两种，一种是在一行中没有找到适合放置皇后的位置，另一种是符合放置方案，然后回溯，寻找下一个方案。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y==a[i]||<span class="built_in">abs</span>(x-i)==<span class="built_in">abs</span>(y-a[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">king</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(k==n)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(check(k,i))</span><br><span class="line">&#123;</span><br><span class="line">a[k]=i;</span><br><span class="line">king(k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">king(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贪心算法</title>
      <link href="/2019/03/30/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/30/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="贪心算法概述："><a href="#贪心算法概述：" class="headerlink" title="贪心算法概述："></a>贪心算法概述：</h3><p>贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。</p><p>注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。</p><a id="more"></a><h4 id="完美的代价"><a href="#完美的代价" class="headerlink" title="完美的代价"></a>完美的代价</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。<br>　　交换的定义是：交换两个相邻的字符<br>　　例如mamad<br>　　第一次交换 ad : mamda<br>　　第二次交换 md : madma<br>　　第三次交换 ma : madam (回文！完美！)</p><p>输入格式</p><p>　　第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000)<br>　　第二行是一个字符串，长度为N.只包含小写字母</p><p>输出格式</p><p>　　如果可能，输出最少的交换次数。<br>　　否则输出Impossible</p><p>样例输入</p><p>5<br>mamad</p><p>样例输出</p><p>3</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>​       在输入的字符串中不匹配的字母可能是一个或零，所以可以先找出这个字母，创建一个包含26个空间是数组，分别表示字符串中字母的个数，然后遍历这个数组，如果字母的个数为奇数，则表示该字母为不匹配字母。首先从首字母开始，找到与它匹配的字符，再将它与最后一个字母交换，这样一对匹配的字母就交换完了，如果遇到不匹配的字母，则将它与中间的字母交换，然后在开始遍历。但是问题要求的是相邻的交换，所以这种方法不符合要求。</p><p>​        我们需要相邻交换，所以要找到交换的起点和终点。求解方法和上面类似，先从首字母开始，在从与字符串的另一方向开始，遍历找到与首字母匹配的字母，记录它的位置，从该位置起，将后一个字母向前一个位置移动，直到与最后，记录交换次数，再将首字母元素赋值给最后一个元素，这样一趟交换完成。</p><p>全局循环次数：1 to n/2;      </p><p>每次循环需判断是否为不匹配元素</p><p>匹配元素循环次数：n-i-1 to j(当字母为匹配字母时)</p><p>匹配元素移动次数：j to n-i-1</p><p>不匹配元素循环次数：i to j(当字母为匹配字母时)</p><p>不匹配元素移动次数：j to i</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//交换次数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hunwen</span><span class="params">(<span class="keyword">char</span> x,<span class="keyword">int</span> y,<span class="keyword">char</span> *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;y/<span class="number">2</span>;i++) &#123;</span><br><span class="line"> <span class="keyword">if</span>(z[i]!=x)&#123;<span class="comment">//匹配字母情况 </span></span><br><span class="line"> j=y-i<span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">while</span>(j!=i&amp;&amp;(z[j]!=z[i]))j--;</span><br><span class="line"> <span class="keyword">for</span>(k=j;k&lt;y-i<span class="number">-1</span>;k++)</span><br><span class="line">   &#123; z[k]=z[k+<span class="number">1</span>];</span><br><span class="line">        count++;</span><br><span class="line">  &#125;</span><br><span class="line"> z[k]=z[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不匹配字母情况 </span></span><br><span class="line">    j=i;</span><br><span class="line">    <span class="keyword">while</span>(j!=y-i<span class="number">-1</span>&amp;&amp;(z[j]!=z[y-i<span class="number">-1</span>]))</span><br><span class="line">    j++;</span><br><span class="line">    <span class="keyword">for</span>(k=j;k&gt;i;k--) &#123;</span><br><span class="line">     z[k]=z[k<span class="number">-1</span>];</span><br><span class="line">     count++;  &#125;</span><br><span class="line">         z[k]=z[y-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> i,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> w;<span class="comment">//记录不匹配字符 </span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">801</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">getchar();<span class="comment">//清除缓存 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> b[a[i]<span class="number">-97</span>]++; <span class="comment">//对字母个数计数 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(b[i]%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">  &#123; w=i+<span class="number">97</span>; j++; &#125;<span class="comment">//遍历找到不匹配字母 </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span>(j&gt;=<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"impossible"</span>);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> hunwen(w,n,a);<span class="comment">//交换函数 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d"</span>,count);&#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次循环都使字符串两边的字母匹配，达到局部最优的方案，贪心算法没有固定的算法模式，只有固定的算法思想：局部最优，从而全局最优。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>建站分享</title>
      <link href="/2018/11/26/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/11/26/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Github-Pages-Hexo"><a href="#Github-Pages-Hexo" class="headerlink" title="Github Pages + Hexo"></a>Github Pages + Hexo</h2><p>  我的博客是Github Pages + Hexo在github上搭建的。<br>  下面是我对搭建博客过程中的一些分享<br><a id="more"></a></p><h3 id="一、-Git、node-js"><a href="#一、-Git、node-js" class="headerlink" title="一、 Git、node.js"></a>一、 Git、node.js</h3><p>  先下载安装好<strong>Git、node.js</strong>，具体的过程参照了网上很多的帖子，很多都不是很详细，对于我这种小白来说就是一种折磨（完全看不懂，虽然学了一点前端的HTML、css、js，但这里完全用不上，到是在后面修改主题的时候到是能看明白了。。。。）这些博客里有一个挺详细的，按照他的过程，很容易就弄出来了（其实也不容易。。。。。出现好多问题，当时就很崩溃，明明按照他的步骤完成的，为啥就不通过呢，只能靠着百度一一解决了。。。<br>  <strong>这个帖子有点小错误，可能是环境和版本不同的原因吧</strong>（我搭建的时候有些地方会出错，需要自己去改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%B8%80)/</span><br></pre></td></tr></table></figure><h3 id="二、Github"><a href="#二、Github" class="headerlink" title="二、Github"></a>二、Github</h3><p>  在github上申请免费的空间来搭建网页，以前西部数码上购买过一个虚拟主机，很贵，一年要几百大洋，主要是国内的主要备案很麻烦，后来就放弃了。在github上可以搭建一个简单的静态网页，虽然是静态的，但是也可以加入很多功能，比如评论、分享系统。用来写写博客或作为个人的自我接受很好用。没有繁琐的管理，搭建好以后只管写博客就好。<br>  <strong>注册GitHub的时候最好是在chrome浏览器中</strong>，因为可以翻译网页，像我这种还没过四级的渣渣，看见这些英文网站就头疼。。。。<br>  具体的注册步骤就不说了，反正我也是看着别人的帖子弄的。。。这个很容易网上就能找到（我忘了我是在按照那个弄的了）</p><h3 id="三、hexo"><a href="#三、hexo" class="headerlink" title="三、hexo"></a>三、hexo</h3><p>配置完hexo本地就算配置完成了，接下来就是将hexo托管到github。<br>  那个_config.yml有两个，<strong>一个是在hexo文件夹下的，另一个是在主题文件夹下的</strong>，一定要分清楚这两个，后面修改主题配置的时候会对这两个文件进行修改。<br>  到这基础的就弄完了，可以说有个简单的博客就搭建完了，不过这时候页面有点丑（太low而且没啥功能），接下来就是对博客的美化-主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g  </span><br><span class="line">hexo s  </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="四、主题"><a href="#四、主题" class="headerlink" title="四、主题"></a>四、主题</h3><p>我使用的是Material X作为博客的主题，想弄的话可以在我们博客的最下面点<strong>Material X</strong>连接，里面有关于这个主题的修改方法，在最下方有主题的源代码，下载后将文件放在主题文件夹中，上传就Ok了，具体的方法可以百度（有时间是话我会写篇文章来详细说一下我是怎样修改的和遇到的问题）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xaoxuu.com/blog/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wushile.top/</span><br></pre></td></tr></table></figure><h2 id="关于搭建博客"><a href="#关于搭建博客" class="headerlink" title="关于搭建博客"></a>关于搭建博客</h2><p>  博客搭建花了大概四天多的时间才完成对博客的简单搭建，第一次弄博客，遇到了很多很多的问题，几乎都快要放弃了，但想想已经花费的很多的时间去做这个博客，就该把它弄完，从无到有，很庆幸坚持到了最后，从一无所知的小白到完成搭建这个博客，学到了很多知识，在网上查找解决问题的时候也见识到了很多。很久都没有这么专注的去做一件事情，每天就想着一件事，就想把这个博客建好，现在终于把基础搭建完了，不足的地方以后再去修改，千里之行始于足下。这是第一次写博客，很多格式都不动，写的很low，没办法，这会已经快一点，也没时间去学了，明天还有课。这两周可能不会对博客再进行大的修改了，还有两周考数据结构，没时间去美化了，等考完试再去博客进行修改吧    </p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/25/hello-world/"/>
      <url>/2018/11/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><a id="more"></a><h3 id="first-personalblog"><a href="#first-personalblog" class="headerlink" title="first personalblog"></a>first personalblog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，世界！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
