<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[open vswitch]]></title>
    <url>%2F2019%2F04%2F19%2Fopen-vswitch%2F</url>
    <content type="text"><![CDATA[open vswitch实验在Terminal下对ovs交换机进行测试； 对ovs交换机和端口的创建；对端口号的修改，配置完ovs以后查看交换机的状态，以及两个端口号的测试。 ovs各模块 ovs-vswitched 主要模块 ovsdb-server 轻量级数据库服务器 ovs-dpctl 配置switch内核 ovs-vsctl c查询和更新交换机配置 ovs-appctl f发送命令消息 ovs常用操作 操作 命令 添加网桥 ovs-vsctl add-br 交换机名 删除网桥 ovs-vsctl del-br 交换机名 添加端口 ovs-vsctl add-port 交换机名 端口号 删除端口 ovs-vsctl del-port 交换机名 端口号 连接控制器 ovs-vsctl set-controller 交换机名 tcp:ip 地址：端口号 断开控制器 ovs-vsctl del-controller 交换机名 列出所有网桥（交换机） ovs-vsctl list-br 列出网桥中的所有端口 ovs-vsctl list-port 交换机名 列出所有连接到网卡的网桥 ovs-vsctl port-to-br 端口号 查看ovs网络状态 ovs-vsctl show 查看ovs端口信息 ovs-vsctl show 交换机名 修改端口号 ovs-vsctl set Interface 端口名 ofport_request=新端口号 以上为ovs经常用到的操作，也是最基础的操作。下面开始ovs的测试实验。 open vswitchovs交换机创建创建一个名为ovs-switch的交换机 1sudo ovs-vsctl add-br ovs-switch 端口的配置配置一个端口号，名为p0,并设置网络接口为;intrenal 1sudo ovs-vsctl set Interface p0 type=internal 设置端口号，如果不自己设置，端口号由系统随机设置 1sudo ovs-vsctl set Interface 端口名 ofport_request=新端口号 虚拟网络空间配置避免与本地网络地址发生冲突，需要创建一个虚拟网络空间，将接口放入当中 1234sudo ip netns add ns0sudo ip link set p0 netns ns0sudo ip netns exec ip addr add 192.168.1.100/24dev p0sudoip netns ecev ns0 ifconfig p0 promisc up 创建一个名为ns0的虚拟网络空间，并将端口p0放入其中，给端口p0配置ip 192.168..1.100 查看ovs交换机查看ovs交换机的各个接口属性 1sudo ovs-vsctl show 测试端口两个端口之间相互测试，需要创建两个端口 1sudo ip netns exec ns0 ping 192.168.1.101 192.168.1.101为第二个端口的ip]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>vswitch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2n皇后]]></title>
    <url>%2F2019%2F04%2F11%2F2n%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[问题描述问题描述给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 输入格式 输入的第一行为一个整数n，表示棋盘的大小。 接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 输出格式 输出一个整数，表示总共有多少种放法。 样例输入41 1 1 11 1 1 11 1 1 11 1 1 1 样例输出 2 样例输入 41 0 1 11 1 1 11 1 1 11 1 1 1 样例输出 0 问题分析2n皇后问题是在n皇后的问题上扩展而来，涉及搜索、模拟、n皇后问题，要解决2n皇后问题先要解决n皇后问题，n皇后在前面已经写了，现在来解决2n皇后的问题。 2n皇后实际是在在棋盘上先放一种皇后，然后再放另一种皇后，已经放过皇后的位置就不能再放皇后，所以首先记录白皇后的位置，然后再放黑皇后，需要一个二维数组来模拟棋盘，初始时，这个棋盘上是0或1，0表示不可以放皇后，1表示可以放皇后的，在开始放白皇后的时候，如果白皇后可以在棋盘上放置，那么记录该位置，将该位置标记为2，代表放置的是白皇后，当所有的白皇后放置完以后，计数器现在为n代表白皇后放置完，然后放置黑皇后，放置黑皇后时，如果放置位置是2那么，则代表位置是白皇后，那么该位置不能再放置黑皇后。按照放置白皇后的方法放置黑皇后。放置方法仍然采用回溯法。 算法设计放置位置检查是否合适一种皇后算法1234567891011bool check(int x,int y)//皇后的放置位置是否合适&#123;//x为行，y为列 int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) //判断是否在同一列或同斜行 return false; &#125; return true;&#125; 两种皇后算法12345678910bool check(int x, int y,int s)//x为行，y为列&#123; int i; for (i = 0; i &lt; x; i++) &#123; if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i]))) return false; &#125; return true;&#125; 在放置一种的基础上添加标志，当s==2时表示放置白皇后，所用到的是a数组，当s==3时，表示放置黑皇后，所用到的是c数组。a数组用来记录白皇后在各行的位置。c数组表示黑皇后在各行的位置。 回溯算法一种皇后回溯1234567891011121314151617void king(int k)&#123; int i; if(k==n)//如果n皇后符合位置，合法方案加一 &#123; count++;//合法方案计数 return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/ &#123; a[k]=i; king(k+1); &#125; &#125;&#125; 两种皇后回溯123456789101112131415161718192021void king(int k,int s)&#123; int i; if (k == n) &#123; if (s==2)king(0, 3);//s==3时放置黑皇后 else count++;//如果白皇后和黑皇后都等于n则计数器加一 return; &#125; for (i = 0; i &lt; n; i++) &#123; if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s))//与放置一种相比，增加两种条件，所放位置上不能等0或不能等2 &#123; s==2?a[k] = i:c[k] = i; b[k][i] = s;//记录白皇后、黑皇后的位置 king(k + 1,s);//第一行放置完，开始第二行 b[k][i] = 1;//还原棋盘 &#125; &#125;&#125; 源代码编译器vs2017 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n ;int count = 0;int a[10];int c[10];int b[10][10];bool check(int x, int y,int s)&#123; int i; for (i = 0; i &lt; x; i++) &#123; if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i]))) return false; &#125; return true;&#125;void king(int k,int s)&#123; int i; if (k == n) &#123; if (s==2)king(0, 3); else count++; return; &#125; for (i = 0; i &lt; n; i++) &#123; if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s)) &#123; s==2?a[k] = i:c[k] = i; b[k][i] = s; king(k + 1,s); b[k][i] = 1; &#125; &#125;&#125;int main(void)&#123; int i, j; scanf_s("%d",&amp;n); for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) scanf_s("%d", &amp;b[i][j]); king(0,2); printf("%d", count); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n皇后]]></title>
    <url>%2F2019%2F04%2F06%2Fn%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[问题描述​ n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。 问题分析​ 如果采用枚举法判断每一种情况，需要枚举n^2的组合数，如果n=8;南无需要枚举54502232次，如果n再增大，需要枚举的次数就太过庞大。所以采用回溯法，尽量减少不必要的循环，当问题达到边界时，返回上一层，不必再浪费资源。如果只考虑每一行放置一个皇后、每一列也只放置一个皇后。从第一行开始放置皇后，当第一行的皇后确定后，结束循环，开始从下一行开始放置皇后，且放置皇后的位置不能与前面的皇后在同一列或同一条对角线。需要一个判断函数，判定在该位置能否放置皇后。如果一行的所有位置都不能放置皇后，那么回溯至上一行。 回溯法按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的。 算法设计皇后位置比较算法1234567891011bool check(int x,int y)//皇后的放置位置是否合适&#123;//x为行，y为列 int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) //判断是否在同一列或同斜行 return false; &#125; return true;&#125; 每一行放一个皇后，就解决了不在同行的问题。 在第i行的时候，遍历n列，试探位置。和之前所有行放的位置进行比较。 比较列：当前列col 不等于 之前 所有列。 即col != arr[i]。 比较斜线， 因为不再同一斜率为1或者-1的斜线。(row - i) / (col - arr[i]) != 1 或 -1 可以取巧用绝对值函数: abs(row-i) != abs(col-arr[i])。回溯算法 1234567891011121314151617void king(int k)&#123; int i; if(k==n)//如果n皇后符合位置，合法方案加一 &#123; count++;//合法方案计数 return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/ &#123; a[k]=i; king(k+1); &#125; &#125;&#125; 回溯每行放置一个皇后，记录每个皇后所在的列数，如果递归后的结果不符合，则回退至该位置，从该位置继续遍历。回溯的条件有两种，一种是在一行中没有找到适合放置皇后的位置，另一种是符合放置方案，然后回溯，寻找下一个方案。 源代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n=8;int count=0;int a[10];bool check(int x,int y)&#123; int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) return false; &#125; return true;&#125;void king(int k)&#123; int i; if(k==n) &#123; count++; return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i)) &#123; a[k]=i; king(k+1); &#125; &#125;&#125;int main(void)&#123; king(0); printf("%d",count); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法概述：贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。 注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。 完美的代价问题描述 回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 交换的定义是：交换两个相邻的字符 例如mamad 第一次交换 ad : mamda 第二次交换 md : madma 第三次交换 ma : madam (回文！完美！) 输入格式 第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000) 第二行是一个字符串，长度为N.只包含小写字母 输出格式 如果可能，输出最少的交换次数。 否则输出Impossible 样例输入 5mamad 样例输出 3 问题分析​ 在输入的字符串中不匹配的字母可能是一个或零，所以可以先找出这个字母，创建一个包含26个空间是数组，分别表示字符串中字母的个数，然后遍历这个数组，如果字母的个数为奇数，则表示该字母为不匹配字母。首先从首字母开始，找到与它匹配的字符，再将它与最后一个字母交换，这样一对匹配的字母就交换完了，如果遇到不匹配的字母，则将它与中间的字母交换，然后在开始遍历。但是问题要求的是相邻的交换，所以这种方法不符合要求。 ​ 我们需要相邻交换，所以要找到交换的起点和终点。求解方法和上面类似，先从首字母开始，在从与字符串的另一方向开始，遍历找到与首字母匹配的字母，记录它的位置，从该位置起，将后一个字母向前一个位置移动，直到与最后，记录交换次数，再将首字母元素赋值给最后一个元素，这样一趟交换完成。 全局循环次数：1 to n/2; 每次循环需判断是否为不匹配元素 匹配元素循环次数：n-i-1 to j(当字母为匹配字母时) 匹配元素移动次数：j to n-i-1 不匹配元素循环次数：i to j(当字母为匹配字母时) 不匹配元素移动次数：j to i 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;int count=0;//交换次数 void hunwen(char x,int y,char *z)&#123; int i,j,k; for(i=0;i&lt;y/2;i++) &#123; if(z[i]!=x) &#123;//匹配字母情况 j=y-i-1; while(j!=i&amp;&amp;(z[j]!=z[i]))j--; for(k=j;k&lt;y-i-1;k++) &#123; z[k]=z[k+1]; count++; &#125; z[k]=z[i]; &#125; else &#123;//不匹配字母情况 j=i; while(j!=y-i-1&amp;&amp;(z[j]!=z[y-i-1])) j++; for(k=j;k&gt;i;k--) &#123; z[k]=z[k-1]; count++; &#125; z[k]=z[y-i-1]; &#125; &#125;&#125;int main(void)&#123; int n; int i,j=0; char w;//记录不匹配字符 int b[26]=&#123;0&#125;; char a[801]; scanf("%d",&amp;n); getchar();//清除缓存 for(i=0;i&lt;n;i++) scanf("%c",&amp;a[i]); for(i=0;i&lt;n;i++) b[a[i]-97]++; //对字母个数计数 for(i=0;i&lt;26;i++) &#123; if(b[i]%2!=0) &#123; w=i+97; j++; &#125;//遍历找到不匹配字母 &#125; if(j&gt;=2)printf("impossible"); else &#123; hunwen(w,n,a);//交换函数 printf("%d",count);&#125; return 0; &#125; 每一次循环都使字符串两边的字母匹配，达到局部最优的方案，贪心算法没有固定的算法模式，只有固定的算法思想：局部最优，从而全局最优。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站分享]]></title>
    <url>%2F2018%2F11%2F26%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Github Pages + Hexo 我的博客是Github Pages + Hexo在github上搭建的。 下面是我对搭建博客过程中的一些分享 一、 Git、node.js 先下载安装好Git、node.js，具体的过程参照了网上很多的帖子，很多都不是很详细，对于我这种小白来说就是一种折磨（完全看不懂，虽然学了一点前端的HTML、css、js，但这里完全用不上，到是在后面修改主题的时候到是能看明白了。。。。）这些博客里有一个挺详细的，按照他的过程，很容易就弄出来了（其实也不容易。。。。。出现好多问题，当时就很崩溃，明明按照他的步骤完成的，为啥就不通过呢，只能靠着百度一一解决了。。。 这个帖子有点小错误，可能是环境和版本不同的原因吧（我搭建的时候有些地方会出错，需要自己去改） 1http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%B8%80)/ 二、Github 在github上申请免费的空间来搭建网页，以前西部数码上购买过一个虚拟主机，很贵，一年要几百大洋，主要是国内的主要备案很麻烦，后来就放弃了。在github上可以搭建一个简单的静态网页，虽然是静态的，但是也可以加入很多功能，比如评论、分享系统。用来写写博客或作为个人的自我接受很好用。没有繁琐的管理，搭建好以后只管写博客就好。 注册GitHub的时候最好是在chrome浏览器中，因为可以翻译网页，像我这种还没过四级的渣渣，看见这些英文网站就头疼。。。。 具体的注册步骤就不说了，反正我也是看着别人的帖子弄的。。。这个很容易网上就能找到（我忘了我是在按照那个弄的了） 三、hexo配置完hexo本地就算配置完成了，接下来就是将hexo托管到github。 那个_config.yml有两个，一个是在hexo文件夹下的，另一个是在主题文件夹下的，一定要分清楚这两个，后面修改主题配置的时候会对这两个文件进行修改。 到这基础的就弄完了，可以说有个简单的博客就搭建完了，不过这时候页面有点丑（太low而且没啥功能），接下来就是对博客的美化-主题 123hexo g hexo s hexo d 四、主题我使用的是Material X作为博客的主题，想弄的话可以在我们博客的最下面点Material X连接，里面有关于这个主题的修改方法，在最下方有主题的源代码，下载后将文件放在主题文件夹中，上传就Ok了，具体的方法可以百度（有时间是话我会写篇文章来详细说一下我是怎样修改的和遇到的问题） 1https://xaoxuu.com/blog/ 1https://www.wushile.top/ 关于搭建博客 博客搭建花了大概四天多的时间才完成对博客的简单搭建，第一次弄博客，遇到了很多很多的问题，几乎都快要放弃了，但想想已经花费的很多的时间去做这个博客，就该把它弄完，从无到有，很庆幸坚持到了最后，从一无所知的小白到完成搭建这个博客，学到了很多知识，在网上查找解决问题的时候也见识到了很多。很久都没有这么专注的去做一件事情，每天就想着一件事，就想把这个博客建好，现在终于把基础搭建完了，不足的地方以后再去修改，千里之行始于足下。这是第一次写博客，很多格式都不动，写的很low，没办法，这会已经快一点，也没时间去学了，明天还有课。这两周可能不会对博客再进行大的修改了，还有两周考数据结构，没时间去美化了，等考完试再去博客进行修改吧]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[hello world first personalblog1你好，世界！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
