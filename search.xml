<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RHCSA-Linux基础命令（一）]]></title>
    <url>%2F2019%2F06%2F17%2FRHCSA-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[>Linux的基本原则1、由目的单一的小程序组成 2、一切皆文件，设备的访问入口也是文件 3、避免捕获用户接口，尽量不和用户交互 4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。 命令格式>命令 >命令 参数 >命令 -选项 >命令 -选项 参数 修改命令的执行特性短选项 -l 多个选项可以组合 长格式 –long ​ 参数 指定命令的作用对象 基础命令重启：reboot 关机：shutdown -h now，poweroff ip a / ifconfig 查看ip地址 dhclient 地址请求，打开网络模式 kill -9 ID 结束相应的进程（命令 -选项 参数） pwd 指出当前工作环境 print workdoing directory su 切换到root用户并不切换环境（工作目录） switch user su - root 切换到root用户并切换环境(切换了工作目录) cd 切换目录 change directroy ​ 绝对路径 从根开始到目标的路径叫绝对路径 ​ 相对路径 相对当前目录开始到目标路径 ​ / 根 ​ ~ 家目录 /root /home/redhat ​ ~ USERNAME(root用户有权限) 直接切换到指定用户的家目录 ​ - 在上一个目录和当前目录来回切换 ​ . 当前目录 ​ .. 上一级目录 passwd 修改密码：passwd 用户名 直接输入passwd修改当前用户的密码 删除密码：passwd -d 用户名 root用户：不需要输入原密码，可以不符合密码复杂性规则，可以给任何人修改密码 普通用户：需要输入原密码，必须符合密码复杂性规则，passwd修改密码无法指定用户 [student@localhost ~]$ su -c passwd普通用户给root用户修改密码]]></content>
      <categories>
        <category>RHCSA</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RHCSA-Linux简介]]></title>
    <url>%2F2019%2F06%2F17%2FRHCSA-Linux%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[操作系统是什么？操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。 操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。 >&gt;硬件：框架 冯诺依曼体系结构：1946年美籍凶牙利科学家冯诺依曼提出存储程序原理，把程序本身当做数据来对待，程序和该程序处理数据用同样的方式存储，并确定了存储程序计算机的五大组成部分和基本工作方法。 特点： （1）计算机处理数据和指令一律用二进制数表示 （2）顺序执行程序 计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序 从主存储器中取出指令一条一条的执行，这一概念称为顺序执行程序。 （3）计算机硬件由运算器、控制器、存储器、输入设备、输出设备五大部分组成。 memory：编址存储设备 假设我们的存储器为一个长条，其中每八位（bit）作为一个单元，我们把它称为字节byte，字节又称为cell。 机器语言：二进制指令 （但是对于编程 人员来说二进制语言太难懂（太简陋，太底层），但是程序员想用简单点的语言去描述计算机又不懂所以两者之间不能耦合可以加一个中间层–编译器） 汇编语言： 仅是将二进制转为人类语言想接近的语言或者是与人类语言符号相同的类型（+ and/plus） 所以任何一款芯片制造商他们都把机器的代码也就是机器语言提供一个较为简单的稍微向上一点的但任然很简陋的编程接口叫做汇编语言（微码编程语言） 软件：​ —-汇编语言： （低级语言） ​ 应用：驱动程序 汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。 ​ eg：操作：寄存器BX的内容送到AX中 ​ 1000100111011000 机器指令 ​ mov ax,bx 汇编指令 （注意：最终识别的还是01二进制数所以还需要将汇编语言转换为二进语言所以需要用到汇编器） ​ —-(高级语言)：比较接近人类的思维逻辑 —-(编译器) ​ 系统级： c c++ ​ 适用场合大型的对性能要求比较高的服务类程序 如：oracle mysql linux windows / ​ 应用级：java python ruby 系统调用的层级关系(系统组成结构) 操作系统内核的功能：系统调用接口 程序管理 内存管理，虚拟内存—内存交换 文件系统管理 设备驱动]]></content>
      <categories>
        <category>RHCSA</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法（1）]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[排序算法是算法中最重要、最基础的算法，也是编程中用到最多的算法。不论是竞赛还是面试时，排序算法都是最常见的考点，下面根据排序思想不同，给出常见的几种排序算法。 插入类排序基本思想：在一个已排好序的基础上，每一步将下个待排序的记录有序插入到已排好的记录子集中，直到所有的待排序记录全部插入到序列中。 直接插入排序算法思想：将第i个数据插到前面i-1个以排好的数据中。 例如：48 62 35 77 55 14 35* 98 a ｛48｝ 62 35 77 55 14 35* 98 b ｛48 62｝ 35 77 55 14 35* 98 c ｛35 48 62｝77 55 14 35* 98 。。。。。。。。。。。。。。。 算法过程：保留第i个数据，将第i个数据依次和前面i-1个数据比较，如果大于其中某一个数据，则停止，将第I个数据插入到此数据后一位，在每次比较中，较大的数据向后移动一位（排序为从小到大）。 12345678910111213void InsSort(int r[],int length)&#123; for(int i=2;i&lt;=length;i++) &#123; r[0]=r[j];//采用首地址保存第i个元素,并且防止数组越界 int j=i-1; while(r[0]&lt;r[j])&#123; r[j+1]=r[j]; j--; &#125; r[j+1]=r[0]; &#125;&#125; 直接插入排序的时间复杂度为T(n)=O(n^2),空间复杂度，空间复杂度为S（n）=O(1); 直接插入排序是稳定的排序方法。当有两个相同元素时，他们的相对位置不发生改变。 折半插入排序算法思想：在直接插入的思想中加入折半查找的思想，提高查找效率。 基本的排序方法不变，只是在查找的过程中做出改变，前面的查找为顺序查找，从第i-1个元素按顺序查找到第1个元素。 1234567891011121314151617void BinSort（int r[],int length）&#123; for(int i=2;i&lt;=length;i++) &#123; int r[0]=r[i]; int low=1,high=i-1; while(low&lt;=high) &#123; int mid=(low+high)/2; if(r[0]&lt;r[mid]) high=mid-1; else low=mid+1; &#125; for(int j=i-1;j&gt;=low;j--) r[j+1]=r[j]; r[low]=r[0]; &#125;&#125; 折半插入排序是由直接插入排序改良而来，在原有的基础上加入折半查找，折半查找是一种非常重要的计算机思维，在很多地方都有应用。 虽然折半插入是由直接插入改进而来，但是时间复杂度并没用改变多少，仍然为0（n^2）; 希尔排序在插入排序中，希尔排序是最佳的排序算法，也是比较难理解的算法。 例： 初始 46 55 13 42 94 17 05 70 d=4 46 17 05 42 94 55 13 70 d=2 05 17 13 42 46 55 94 70 d=1 05 13 17 42 46 55 70 94 123456789101112131415161718void shellInSort(int r[],int length,int delta)&#123; for(int i=1+delta;i&lt;=length,i++)//delta为增量d &#123; if(r[i]&lt;r[i-delta])//子序列最后一个元素和第一个元素比较 ｛ r[0]=r[i]; for(int j=i-delta;j&gt;0&amp;&amp;r[0]&lt;r[j];j-=delta) r[j+delta]=r[j]; r[j+delta]=r[0]; ｝ &#125;&#125;void shellSort(int r[],int length,int delta[],int n)&#123; for(int i=0;i&lt;=n-1;i++) shellInSort(r,length,delta[i]);&#125; 关于增量d的选取： shell ： d=n/2;d=d/2……..d=1; knuth: d=d/3+1; 时间复杂度：O（n^1.5）; 注意：希尔排序是一种不稳定的排序； 总结 排序算法 时间复杂度 空间复杂度 稳定性 直接插入 O(n^2) O(1) 稳定 折半插入 O(n^2) O(1) 稳定 希尔排序 O(n^1.5) O(1) 不稳定]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c关于堆栈的划定]]></title>
    <url>%2F2019%2F05%2F14%2Fc%E5%85%B3%E4%BA%8E%E5%A0%86%E6%A0%88%E7%9A%84%E5%88%92%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[c语言 全局变量与局部变量的划分在做背包问题的时候遇到这样的问题，定义一个二维数组变量，该变量的大小为1000*1000，但是在运行时报错，显示“Stack overflow ”，说明在此处超过了栈的空间。 c/c++内存分配栈区(stack sagment)由编译器自动分配释放，存放函数的参数的值，局部变量的值等。在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M(也有的是1M，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆区(heap sagment) 一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收 。它与数据结构中的堆是两回事。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 全局区(静态区)(data sagment)全局变量和静态变量的存储区域是在一起的，程序结束后由系统释放。数据区的大小由系统限定，一般很大。 因为栈区的大小是编译器分配好的，如果变量的空间过大就会有栈的溢出问题，因此变量的类型是局部变量还是全局变量要根据变量大小选择，一版来说只有用到数组要考虑溢出问题，比如long、double都是固定长度大小的。如果数组的大小大于1000*1000就要考虑溢出问题，而全局变量的大小是有系统规定的，一般都很大。全局变量大小可达G以上。]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[open vswitch]]></title>
    <url>%2F2019%2F04%2F19%2Fopen-vswitch%2F</url>
    <content type="text"><![CDATA[open vswitch实验在Terminal下对ovs交换机进行测试； 对ovs交换机和端口的创建；对端口号的修改，配置完ovs以后查看交换机的状态，以及两个端口号的测试。 ovs各模块 ovs-vswitched 主要模块 ovsdb-server 轻量级数据库服务器 ovs-dpctl 配置switch内核 ovs-vsctl c查询和更新交换机配置 ovs-appctl f发送命令消息 ovs常用操作 操作 命令 添加网桥 ovs-vsctl add-br 交换机名 删除网桥 ovs-vsctl del-br 交换机名 添加端口 ovs-vsctl add-port 交换机名 端口号 删除端口 ovs-vsctl del-port 交换机名 端口号 连接控制器 ovs-vsctl set-controller 交换机名 tcp:ip 地址：端口号 断开控制器 ovs-vsctl del-controller 交换机名 列出所有网桥（交换机） ovs-vsctl list-br 列出网桥中的所有端口 ovs-vsctl list-port 交换机名 列出所有连接到网卡的网桥 ovs-vsctl port-to-br 端口号 查看ovs网络状态 ovs-vsctl show 查看ovs端口信息 ovs-vsctl show 交换机名 修改端口号 ovs-vsctl set Interface 端口名 ofport_request=新端口号 以上为ovs经常用到的操作，也是最基础的操作。下面开始ovs的测试实验。 open vswitchovs交换机创建创建一个名为ovs-switch的交换机 1sudo ovs-vsctl add-br ovs-switch 端口的配置配置一个端口号，名为p0,并设置网络接口为;intrenal 1sudo ovs-vsctl set Interface p0 type=internal 设置端口号，如果不自己设置，端口号由系统随机设置 1sudo ovs-vsctl set Interface 端口名 ofport_request=新端口号 虚拟网络空间配置避免与本地网络地址发生冲突，需要创建一个虚拟网络空间，将接口放入当中 1234sudo ip netns add ns0sudo ip link set p0 netns ns0sudo ip netns exec ip addr add 192.168.1.100/24dev p0sudoip netns ecev ns0 ifconfig p0 promisc up 创建一个名为ns0的虚拟网络空间，并将端口p0放入其中，给端口p0配置ip 192.168..1.100 查看ovs交换机查看ovs交换机的各个接口属性 1sudo ovs-vsctl show 测试端口两个端口之间相互测试，需要创建两个端口 1sudo ip netns exec ns0 ping 192.168.1.101 192.168.1.101为第二个端口的ip]]></content>
      <categories>
        <category>SDN</category>
      </categories>
      <tags>
        <tag>vswitch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2n皇后]]></title>
    <url>%2F2019%2F04%2F11%2F2n%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[问题描述问题描述给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 输入格式 输入的第一行为一个整数n，表示棋盘的大小。 接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 输出格式 输出一个整数，表示总共有多少种放法。 样例输入41 1 1 11 1 1 11 1 1 11 1 1 1 样例输出 2 样例输入 41 0 1 11 1 1 11 1 1 11 1 1 1 样例输出 0 问题分析2n皇后问题是在n皇后的问题上扩展而来，涉及搜索、模拟、n皇后问题，要解决2n皇后问题先要解决n皇后问题，n皇后在前面已经写了，现在来解决2n皇后的问题。 2n皇后实际是在在棋盘上先放一种皇后，然后再放另一种皇后，已经放过皇后的位置就不能再放皇后，所以首先记录白皇后的位置，然后再放黑皇后，需要一个二维数组来模拟棋盘，初始时，这个棋盘上是0或1，0表示不可以放皇后，1表示可以放皇后的，在开始放白皇后的时候，如果白皇后可以在棋盘上放置，那么记录该位置，将该位置标记为2，代表放置的是白皇后，当所有的白皇后放置完以后，计数器现在为n代表白皇后放置完，然后放置黑皇后，放置黑皇后时，如果放置位置是2那么，则代表位置是白皇后，那么该位置不能再放置黑皇后。按照放置白皇后的方法放置黑皇后。放置方法仍然采用回溯法。 算法设计放置位置检查是否合适一种皇后算法1234567891011bool check(int x,int y)//皇后的放置位置是否合适&#123;//x为行，y为列 int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) //判断是否在同一列或同斜行 return false; &#125; return true;&#125; 两种皇后算法12345678910bool check(int x, int y,int s)//x为行，y为列&#123; int i; for (i = 0; i &lt; x; i++) &#123; if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i]))) return false; &#125; return true;&#125; 在放置一种的基础上添加标志，当s==2时表示放置白皇后，所用到的是a数组，当s==3时，表示放置黑皇后，所用到的是c数组。a数组用来记录白皇后在各行的位置。c数组表示黑皇后在各行的位置。 回溯算法一种皇后回溯1234567891011121314151617void king(int k)&#123; int i; if(k==n)//如果n皇后符合位置，合法方案加一 &#123; count++;//合法方案计数 return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/ &#123; a[k]=i; king(k+1); &#125; &#125;&#125; 两种皇后回溯123456789101112131415161718192021void king(int k,int s)&#123; int i; if (k == n) &#123; if (s==2)king(0, 3);//s==3时放置黑皇后 else count++;//如果白皇后和黑皇后都等于n则计数器加一 return; &#125; for (i = 0; i &lt; n; i++) &#123; if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s))//与放置一种相比，增加两种条件，所放位置上不能等0或不能等2 &#123; s==2?a[k] = i:c[k] = i; b[k][i] = s;//记录白皇后、黑皇后的位置 king(k + 1,s);//第一行放置完，开始第二行 b[k][i] = 1;//还原棋盘 &#125; &#125;&#125; 源代码编译器vs2017 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n ;int count = 0;int a[10];int c[10];int b[10][10];bool check(int x, int y,int s)&#123; int i; for (i = 0; i &lt; x; i++) &#123; if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i]))) return false; &#125; return true;&#125;void king(int k,int s)&#123; int i; if (k == n) &#123; if (s==2)king(0, 3); else count++; return; &#125; for (i = 0; i &lt; n; i++) &#123; if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s)) &#123; s==2?a[k] = i:c[k] = i; b[k][i] = s; king(k + 1,s); b[k][i] = 1; &#125; &#125;&#125;int main(void)&#123; int i, j; scanf_s("%d",&amp;n); for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) scanf_s("%d", &amp;b[i][j]); king(0,2); printf("%d", count); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n皇后]]></title>
    <url>%2F2019%2F04%2F06%2Fn%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[问题描述​ n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。 问题分析​ 如果采用枚举法判断每一种情况，需要枚举n^2的组合数，如果n=8;南无需要枚举54502232次，如果n再增大，需要枚举的次数就太过庞大。所以采用回溯法，尽量减少不必要的循环，当问题达到边界时，返回上一层，不必再浪费资源。如果只考虑每一行放置一个皇后、每一列也只放置一个皇后。从第一行开始放置皇后，当第一行的皇后确定后，结束循环，开始从下一行开始放置皇后，且放置皇后的位置不能与前面的皇后在同一列或同一条对角线。需要一个判断函数，判定在该位置能否放置皇后。如果一行的所有位置都不能放置皇后，那么回溯至上一行。 回溯法按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的。 算法设计皇后位置比较算法1234567891011bool check(int x,int y)//皇后的放置位置是否合适&#123;//x为行，y为列 int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) //判断是否在同一列或同斜行 return false; &#125; return true;&#125; 每一行放一个皇后，就解决了不在同行的问题。 在第i行的时候，遍历n列，试探位置。和之前所有行放的位置进行比较。 比较列：当前列col 不等于 之前 所有列。 即col != arr[i]。 比较斜线， 因为不再同一斜率为1或者-1的斜线。(row - i) / (col - arr[i]) != 1 或 -1 可以取巧用绝对值函数: abs(row-i) != abs(col-arr[i])。回溯算法 1234567891011121314151617void king(int k)&#123; int i; if(k==n)//如果n皇后符合位置，合法方案加一 &#123; count++;//合法方案计数 return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/ &#123; a[k]=i; king(k+1); &#125; &#125;&#125; 回溯每行放置一个皇后，记录每个皇后所在的列数，如果递归后的结果不符合，则回退至该位置，从该位置继续遍历。回溯的条件有两种，一种是在一行中没有找到适合放置皇后的位置，另一种是符合放置方案，然后回溯，寻找下一个方案。 源代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n=8;int count=0;int a[10];bool check(int x,int y)&#123; int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) return false; &#125; return true;&#125;void king(int k)&#123; int i; if(k==n) &#123; count++; return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i)) &#123; a[k]=i; king(k+1); &#125; &#125;&#125;int main(void)&#123; king(0); printf("%d",count); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法概述：贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。 注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。 完美的代价问题描述 回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 交换的定义是：交换两个相邻的字符 例如mamad 第一次交换 ad : mamda 第二次交换 md : madma 第三次交换 ma : madam (回文！完美！) 输入格式 第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000) 第二行是一个字符串，长度为N.只包含小写字母 输出格式 如果可能，输出最少的交换次数。 否则输出Impossible 样例输入 5mamad 样例输出 3 问题分析​ 在输入的字符串中不匹配的字母可能是一个或零，所以可以先找出这个字母，创建一个包含26个空间是数组，分别表示字符串中字母的个数，然后遍历这个数组，如果字母的个数为奇数，则表示该字母为不匹配字母。首先从首字母开始，找到与它匹配的字符，再将它与最后一个字母交换，这样一对匹配的字母就交换完了，如果遇到不匹配的字母，则将它与中间的字母交换，然后在开始遍历。但是问题要求的是相邻的交换，所以这种方法不符合要求。 ​ 我们需要相邻交换，所以要找到交换的起点和终点。求解方法和上面类似，先从首字母开始，在从与字符串的另一方向开始，遍历找到与首字母匹配的字母，记录它的位置，从该位置起，将后一个字母向前一个位置移动，直到与最后，记录交换次数，再将首字母元素赋值给最后一个元素，这样一趟交换完成。 全局循环次数：1 to n/2; 每次循环需判断是否为不匹配元素 匹配元素循环次数：n-i-1 to j(当字母为匹配字母时) 匹配元素移动次数：j to n-i-1 不匹配元素循环次数：i to j(当字母为匹配字母时) 不匹配元素移动次数：j to i 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;int count=0;//交换次数 void hunwen(char x,int y,char *z)&#123; int i,j,k; for(i=0;i&lt;y/2;i++) &#123; if(z[i]!=x) &#123;//匹配字母情况 j=y-i-1; while(j!=i&amp;&amp;(z[j]!=z[i]))j--; for(k=j;k&lt;y-i-1;k++) &#123; z[k]=z[k+1]; count++; &#125; z[k]=z[i]; &#125; else &#123;//不匹配字母情况 j=i; while(j!=y-i-1&amp;&amp;(z[j]!=z[y-i-1])) j++; for(k=j;k&gt;i;k--) &#123; z[k]=z[k-1]; count++; &#125; z[k]=z[y-i-1]; &#125; &#125;&#125;int main(void)&#123; int n; int i,j=0; char w;//记录不匹配字符 int b[26]=&#123;0&#125;; char a[801]; scanf("%d",&amp;n); getchar();//清除缓存 for(i=0;i&lt;n;i++) scanf("%c",&amp;a[i]); for(i=0;i&lt;n;i++) b[a[i]-97]++; //对字母个数计数 for(i=0;i&lt;26;i++) &#123; if(b[i]%2!=0) &#123; w=i+97; j++; &#125;//遍历找到不匹配字母 &#125; if(j&gt;=2)printf("impossible"); else &#123; hunwen(w,n,a);//交换函数 printf("%d",count);&#125; return 0; &#125; 每一次循环都使字符串两边的字母匹配，达到局部最优的方案，贪心算法没有固定的算法模式，只有固定的算法思想：局部最优，从而全局最优。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站分享]]></title>
    <url>%2F2018%2F11%2F26%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Github Pages + Hexo 我的博客是Github Pages + Hexo在github上搭建的。 下面是我对搭建博客过程中的一些分享 一、 Git、node.js 先下载安装好Git、node.js，具体的过程参照了网上很多的帖子，很多都不是很详细，对于我这种小白来说就是一种折磨（完全看不懂，虽然学了一点前端的HTML、css、js，但这里完全用不上，到是在后面修改主题的时候到是能看明白了。。。。）这些博客里有一个挺详细的，按照他的过程，很容易就弄出来了（其实也不容易。。。。。出现好多问题，当时就很崩溃，明明按照他的步骤完成的，为啥就不通过呢，只能靠着百度一一解决了。。。 这个帖子有点小错误，可能是环境和版本不同的原因吧（我搭建的时候有些地方会出错，需要自己去改） 1http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%B8%80)/ 二、Github 在github上申请免费的空间来搭建网页，以前西部数码上购买过一个虚拟主机，很贵，一年要几百大洋，主要是国内的主要备案很麻烦，后来就放弃了。在github上可以搭建一个简单的静态网页，虽然是静态的，但是也可以加入很多功能，比如评论、分享系统。用来写写博客或作为个人的自我接受很好用。没有繁琐的管理，搭建好以后只管写博客就好。 注册GitHub的时候最好是在chrome浏览器中，因为可以翻译网页，像我这种还没过四级的渣渣，看见这些英文网站就头疼。。。。 具体的注册步骤就不说了，反正我也是看着别人的帖子弄的。。。这个很容易网上就能找到（我忘了我是在按照那个弄的了） 三、hexo配置完hexo本地就算配置完成了，接下来就是将hexo托管到github。 那个_config.yml有两个，一个是在hexo文件夹下的，另一个是在主题文件夹下的，一定要分清楚这两个，后面修改主题配置的时候会对这两个文件进行修改。 到这基础的就弄完了，可以说有个简单的博客就搭建完了，不过这时候页面有点丑（太low而且没啥功能），接下来就是对博客的美化-主题 123hexo g hexo s hexo d 四、主题我使用的是Material X作为博客的主题，想弄的话可以在我们博客的最下面点Material X连接，里面有关于这个主题的修改方法，在最下方有主题的源代码，下载后将文件放在主题文件夹中，上传就Ok了，具体的方法可以百度（有时间是话我会写篇文章来详细说一下我是怎样修改的和遇到的问题） 1https://xaoxuu.com/blog/ 1https://www.wushile.top/ 关于搭建博客 博客搭建花了大概四天多的时间才完成对博客的简单搭建，第一次弄博客，遇到了很多很多的问题，几乎都快要放弃了，但想想已经花费的很多的时间去做这个博客，就该把它弄完，从无到有，很庆幸坚持到了最后，从一无所知的小白到完成搭建这个博客，学到了很多知识，在网上查找解决问题的时候也见识到了很多。很久都没有这么专注的去做一件事情，每天就想着一件事，就想把这个博客建好，现在终于把基础搭建完了，不足的地方以后再去修改，千里之行始于足下。这是第一次写博客，很多格式都不动，写的很low，没办法，这会已经快一点，也没时间去学了，明天还有课。这两周可能不会对博客再进行大的修改了，还有两周考数据结构，没时间去美化了，等考完试再去博客进行修改吧]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[hello world first personalblog1你好，世界！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
