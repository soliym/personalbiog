{"meta":{"title":"soliym","subtitle":null,"description":null,"author":"soliym","url":"http://soliym.top"},"pages":[{"title":"about","date":"2019-03-29T14:17:54.000Z","updated":"2019-03-29T15:33:26.432Z","comments":true,"path":"about/index.html","permalink":"http://soliym.top/about/index.html","excerpt":"","text":"这个人很懒，不想介绍自己~"},{"title":"categories","date":"2019-03-10T06:21:38.000Z","updated":"2019-03-10T06:24:40.167Z","comments":true,"path":"categories/index.html","permalink":"http://soliym.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-04T03:45:41.000Z","updated":"2019-03-10T06:23:45.878Z","comments":true,"path":"tags/index.html","permalink":"http://soliym.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"xss-lab(11-18)详细讲解","slug":"xss-lab(11-18)详细讲解","date":"2020-05-06T08:47:10.339Z","updated":"2020-05-06T09:13:33.692Z","comments":true,"path":"2020/05/06/xss-lab(11-18)详细讲解/","link":"","permalink":"http://soliym.top/2020/05/06/xss-lab(11-18)详细讲解/","excerpt":"xss注入与sql注入有很多相似之处，如果有sql学习的基础，那么学习xss将会很轻松，xss注入的方法总的来说就方面，一方面从js脚本入手，如果js方面的防御机制，可以考虑绕过，或者选择html的标签中的事件属性注入，本文并没有涉及flash xss攻击，flash xss会作为单独一章，而且也没有涉及存储型xss攻击，关于存储型xss会在dvwa中讲到","text":"xss注入与sql注入有很多相似之处，如果有sql学习的基础，那么学习xss将会很轻松，xss注入的方法总的来说就方面，一方面从js脚本入手，如果js方面的防御机制，可以考虑绕过，或者选择html的标签中的事件属性注入，本文并没有涉及flash xss攻击，flash xss会作为单独一章，而且也没有涉及存储型xss攻击，关于存储型xss会在dvwa中讲到 第11关：这一关与上一关一样，需要盲猜注入的变量，通过逐个试探，只有t_sort才可以，回显信息，所以通过T_sort注入 xss注入： 1t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)&quot; type=&quot;text&quot; 通过测试，并没有注入成功，所以T_sort并不是接受的变量 查看源代码： 12345$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_REFERER&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); 通过查看源代码，我们知道所有的变量都是迷惑攻击者的，真正的输入点是在http的头部的 使用bp抓包，然后修改http数据包的报头，注入代码 在http的头部加入referer字段，该字段的值为： 12&quot; accesskey=&quot;x&quot; onload=&quot;alert(1)&quot; type=&quot;text&quot; 然后页面会出现input框，点击后就会出现消息框 本关的防御机制是通过隐藏输入点，如果攻击者不知道源码的情况下很难注入 第12关：这一关是有提示的，在html代码中的input下，变量名t_ua的值，是浏览器的版本，真好对应user-agent字段，所以猜测是通过http头部注入，上一关也应该是有的，不过没有注意到 注入方法与上一关一样：抓包-修改-注入代码 在http的头部修改user-agent字段 12&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot; 本关的防御机制与上一关一样 查看源码： 123$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); 是对尖括号有过滤的，所以采用事件注入 第13关：这一关没有提示，不能确定是否还是通过http注入，所以先试探几个变量是否可用。在试探的过程中发现T_cook是有内容的，所以我们猜测注入点是cookie 通过抓包发现，cookie处的内容确实是t_cookie显示的内容，所以修改cookie的值： 1user=2&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot; 查看源码： 12345$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); 对尖括号有过滤，所以采用事件注入 第14关：这一关，没有注入点，整个页面是一个静态页面 查看源码： 12345&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不会自动跳转。成功者&lt;a href=/xss/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt;&lt;/body&gt; 第15关：第15关html代码很少，找不到注入点，也不知道变量名，也没有提示，所以只能查看源代码 12345&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;?&gt; 可以看到的是，变量名是“src”，这也没有提示，确实猜不到 通过试探，发现所有的输入都会被注视到 ngInclude: 1 之后，所以先了解一下 ngInclude它的作用 ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。 ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。 也就是说它的参数是一个html页面 先输入一个php页面： 1level15.php?src=&apos;level1.php&apos; 发现在该页面会加载level1的页面，我们在15页面里面是没有注入点，但是在1页面里面有，尝试在1里面注入 1src=&apos;level1.php?name=1&lt;script&gt;alert(1)&lt;/script&gt;&apos; 并没有被执行，因为通过htmlspecialchars($str)函数，有些特殊字符被转码了，转为了html实体，所以我们采用其他标签的事件属性触发 1src=&apos;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&apos; 第16关：首先试探输入： 1&lt;script&gt;alert(1)&lt;/script&gt; 其中script被过滤了，然后大小写输入 1&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt; 大小写也被过滤了，嵌套写入 嵌套的部分被替换成了空格 换标签输入 1&lt;img src=1 onerror=alert(1)&gt; 空格也被编码了 空格采用url编码输入 1&lt;img%0Asrc=1%0Aonerror=alert(1)&gt; 查看源码： 123456789$str = strtolower($_GET[&quot;keyword&quot;]);``$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);``$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);``$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);``$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4); 第17关：从这一关开始应该是flash xss注入，但是这一关可以不采用，可以通过闭合注入 1arg01=a&amp;arg02= onmouseover=javascript:alert(1) 查看源码： 1echo &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;; 要注意的是： 1&quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot; 这个语句是可以拆解的， 1&quot;&lt;embed src=xsf01.swf?&quot; &quot; width=100% heigth=100%&gt;&quot; 本身就是闭合的，所以不需要构造闭合，所以可以绕过htmlspecialchars该函数，因此，我们输入的才会被当成独立事件属性，不然就需要去构造闭合，而对于htmlspecialchars来说，双引号是特殊处理的，不能用来闭合，就像19关一样 第18关：与17关是一样的 查看源码： 1echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;; 注：第17、18关都可以通过flash xss注入","categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://soliym.top/categories/Web安全/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://soliym.top/tags/xss/"}]},{"title":"xss-lab(1-10)详细讲解","slug":"xss-lab(1-10)详细讲解","date":"2020-05-06T08:26:38.490Z","updated":"2020-05-06T09:12:45.523Z","comments":true,"path":"2020/05/06/xss-lab(1-10)详细讲解/","link":"","permalink":"http://soliym.top/2020/05/06/xss-lab(1-10)详细讲解/","excerpt":"xss概述​ XSS，全称跨站脚本，XSS跨站脚本（Cross-Site Scripting，XSS（与css-层叠样式表冲突，所以命名为xss）），某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要注意的是，XSS不仅仅扩展JavaScript，还包括flash等其他脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。","text":"xss概述​ XSS，全称跨站脚本，XSS跨站脚本（Cross-Site Scripting，XSS（与css-层叠样式表冲突，所以命名为xss）），某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要注意的是，XSS不仅仅扩展JavaScript，还包括flash等其他脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。 xss-lab​ 通过xss-lab来学习xss攻击，xss-lab是一个用于学习的平台，需要自己搭建平台 1、xss-lab平台搭建 ​ 1.1 xss-lab下载地址： ​ 链接：https://pan.baidu.com/s/1sLh5suCgkNsXKbODJ1T8GA ​ 提取码：zr17 ​ 1.2 搭建平台 ​ 使用linux+apache+linux搭建网站，网站的搭建比较简单就不写了 2、开始学习xss攻击 ​ 首先介绍一下xss-lab，xss-lab是一个用于学习xss注入的平台，使用php编写的后台代码，一共有20关，每一 关都有不同的xss注入漏洞，我们要找出漏洞，并且通过漏洞注入代码，方可以通关。 ​ 虽然每一关都是不同的，但是注入的方法只有几种，不过涉及的知识点是比较多而且广泛的，大多都是与前 端相关的。xss-lab后面会涉及flash xss攻击，后面将会单独作为章节。 ​ 关于涉及到的知识点，会在注入的时候提到 xss攻击实例第一关：get型注，在url中的name字段中输入，输入的内容会在页面回显。显示内容是在html标签之间，所以采用标签注入： 1name=&lt;script&gt;alert(1)&lt;/script&gt; 弹出消息框，存在xss漏洞 查看源码： 12345&lt;?phpini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt; 通过get型，获得name参数，然后在注入js代码 12注入之后：&lt;h2 align=center&gt;欢迎用户&lt;script&gt;alert(1)&lt;/script&gt;&lt;/h2&gt; 这一关没有任何防护措施 ​ 第二关：在网页源代码中，我们输入的数据，是在表单中的value属性内，所以需要先闭合input标签，然后在注入代码，闭合标签： 1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 第一种方法是通过闭合标签，然后使用脚本代码，另一种是闭合value属性，然后在input标签内加入事件属性： 1&quot; onclick=&quot;alert(11) 查看源码： 在h2标签中有.htmlspecialchars($str)，所以在该地方没有xss注入 1&lt;input name=keyword value=&quot;&apos;.$str.&apos;&quot;&gt; 在input标签中，value属性没有过滤，所以有xss注入漏洞 本关在h2标签中有防御机制，但是在input中是没有的，所以可以在input中注入 第三关：输入script,”&lt;”会被转换为html编码，所以这一关无法采用标签，因为标签都是带有”&lt;”的，因此采用事件，需要闭合标签的属性： 1&apos; onclick=&apos;alert(1) 可以通过查看网页的html页面，确定闭合方式，以及是否闭合 查看源码： 12&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt; 所有的地方都被htmlspecialchars函数过滤了，该函数可以过滤“&lt;”“&gt;”““ ”，但是不会过滤单引号，而且value的闭合也是采用单引号，所以会有xss漏洞 本关所有的地方有都防御机制，所以需要绕过该防御机制，因此采用事件方法，并且使用单引号闭合，这样就可以绕过函数的html实体化 第四关：先试探防御机制，发现value值中把“&lt;”过滤了，所以采用事件注入 1&quot; onclick=&quot;alert(1)&quot; 查看源码： 12$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2); 过滤了尖括号 本关的防御机制是过滤了，html标签必须采用的“&lt;”，单号没有考虑事件 第五关：先试探防御机制，这一关把ri转换为r_i，所以考虑绕过该机制 1&lt;scr_ipt&gt;alert(1)&lt;/script&gt; 采用大小写同样会被转换，所以换一个不带ri的标签 1&quot;&gt;&lt;img src=1 o_nerror=alert(1) 然后发现on也被过滤了，而且所有的事件属性都是带有on的，所以在此处无法采用事件 采用其他标签： 1&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot; 点击图片就会触发 查看源码： 123$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); 第一行，将数据转换为小写 第二行，第二行将script转换 第三行，将on转换 本关考虑了标签、及事件的转换，但是没有考虑完整 第六关：通过试探，和上一关很相似，采用上一关的做法，发现href也被过滤了，但是这一关没有过滤大小写，所有的标签都可以用，只要换成大写，或大小写混合就可以了 12&quot;&gt;&lt;a HREF=&quot;javascript:alert(1)&quot;&quot;&gt;&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt; 查看源码： 123456$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5); 本关对标签，事件都有过滤，但是唯一的漏洞就是没有过滤大小写 第七关：通过试探，发现script被过滤了： 1&lt;&gt;alert(1)&lt;/&gt; 所有采用嵌套的方法： 1&lt;scscriptript&gt;alert(1)&lt;/scrscriptipt&gt; 发现可以使用，然后构造闭合： 1&quot;&gt;&lt;scscriptript&gt;alert(1)&lt;/scrscriptipt&gt; 采用事件注入： 1&quot; onclick=&quot;alert(1)&quot; on被过滤，所以嵌套注入 1&quot; oonnclick=&quot;alert(1)&quot; 查看源码： 123456$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5); 本关与上一关的不同，在于转换后的内容不同，虽然添加了大小写转换，但是因为转换后，字符被转换为空字符，所以转换后的字符如何仍可以组合成，那么就可以绕过该防御机制 第8关：通过试探，发现无法构造闭合，采用是采用了htmlspecialchars($str)函数，而且闭合方式是双引号，所以input中无法注入，但是在连接里面是有地方可以注入的，首先是试探是否有防御机制： 1javascr_ipt:alert(1) 发现与第6关一样，做了过滤，采用html实体编码 1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(1) 查看源码： 1234567$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6); 这一关基本过滤了所以关键字和大小写，所以采用html实体编码 第9关：通过试探，这一关与上一关不同的是会在上一关的基础上，加入地址的检查，首先判断会检查哪些内容，这一关会检查输入的数据中是否会有http：//字段，所以需要在输入的字段中加入该字段 1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(&apos;http://&apos;) 查看源码： 1false===strpos($str7,&apos;http://&apos;) 这一关会检查字段的值 第10关：这一没有输入的地方，需要在url地址栏中输入，这一时输入是隐藏的，也就是说keyname并不是要注入的地方，真正注入的地方是三个input，不过这三个被隐藏了，所以需要去试探这三个那个是正确的： 1t_sort=&lt;script&gt;alert(1)&lt;/script&gt; 这一关也会过滤“&lt;”,所以可以绕过，也可以用事件 1t_sort=&quot; onmouseover=&quot;alert(1)&quot; 但是因为input是隐藏的，所以不会触发事件，需要通过其它方法触发 采用html的accesskey属性： 1t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1) 注意：不同的浏览器有不同的触发方式 12火狐是shift+ctrl+x（定义的）Chrome alt+x 采用type属性： 1t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)&quot; type=&quot;text&quot; 查看源码： 1234$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);","categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://soliym.top/categories/Web安全/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://soliym.top/tags/xss/"}]},{"title":"Linux重定向及管道符","slug":"Linux重定向及管道符","date":"2020-02-02T10:35:58.000Z","updated":"2020-02-02T10:44:49.724Z","comments":true,"path":"2020/02/02/Linux重定向及管道符/","link":"","permalink":"http://soliym.top/2020/02/02/Linux重定向及管道符/","excerpt":"一、重定向重定向分为输入重定向和输出重定向,输出重定向又分为标椎重定向和错误重新向，输出重定向有分为两种写入格式，清空写入和追加写入","text":"一、重定向重定向分为输入重定向和输出重定向,输出重定向又分为标椎重定向和错误重新向，输出重定向有分为两种写入格式，清空写入和追加写入 1、重定向分类：输入重定向 &lt; 将文件的内容输入到屏幕中 输出重定向 &gt; 将命令的结果输出到文件中 ​ 标椎输出重定向 &gt; 将命令的正确信息打印到文件中 错误输出重定向 2&gt; 将命令的错误信息打印到文件中 2、写入格式：​ 清空写入 &gt; 追加写入 &gt;&gt; 命令与文件之间桥梁 各种重定向的命令格式： 3、输入重定向： 符号 作用 命令 &lt; 文件 将文件作为命令的标准输入 命令 &lt;&lt; 分界符 从标准输入中读入，直到遇见分界符才停止 命令 &lt; 文件1 &gt; 文件2 将文件1作为命令的标准输入并将标准输出到文件2 例： [root@localhost ~]# wc -l &lt; a 1 统计a文件中的行数 [root@localhost ~]# wc -l &lt; a &gt; b 将上述命令的结果保存到文件b中 4、输出重定向： 符号 作用 命令 &gt; 文件 将标准输出重定向到一个文件中（清空原有文件的数据） 命令 2&gt; 文件 将错误输出重定向到一个文件中（清空原有文件的数据） 命令 &gt;&gt; 文件 将标准输出重定向到一个文件中（追加到原有内容的后面） 命令 2&gt;&gt; 文件 将错误输出重定向到一个文件中（追加到原有内容的后面） 命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） 1）标准重定向-覆盖写入[root@localhost ~]# echo helloworld &gt; a [root@localhost ~]# cat a helloworld 2）标椎重定向-追加写入[root@localhost ~]# echo Linux &gt;&gt; a [root@localhost ~]# cat a helloworld Linux 3）错误重定向-覆盖写入[root@localhost ~]# ll redhat 2&gt; b [root@localhost ~]# cat b ls: cannot access redhat: No such file or directory 4）错误重定向-追加写入[root@localhost ~]# ll root 2&gt;&gt; b [root@localhost ~]# cat b ls: cannot access redhat: No such file or directory ls: cannot access root: No such file or directory 5）输出重定向-追加写入[root@localhost ~]# ll a &amp;&gt;&gt; a [root@localhost ~]# cat a helloworld Linux -rw-r–r–. 1 root root 17 Feb 2 09:24 a [root@localhost ~]# ll c &amp;&gt;&gt; a [root@localhost ~]# cat a helloworld Linux -rw-r–r–. 1 root root 17 Feb 2 09:24 a ls: cannot access c: No such file or directory 二、管道符管道符 | 将前面命令的结果交给后面的命令处理 命令A | 命令B 1）例：[root@localhost ~]# grep root /etc/passwd | wc -l 2 匹配包含root的信息，并统计行数 2）例： [root@localhost ~]# ll | head -n 4 total 16792 -rw-r–r–. 1 root root 106 Feb 2 09:28 a -rw——-. 1 root root 2569 Dec 21 12:14 anaconda-ks.cfg -rw-r–r–. 1 root root 102 Feb 2 09:26 b 如果目录中的文件太多，可以先执行ll命令，然后查看前n行 3）例： [root@localhost ~]# echo redhat | passwd –stdin xixi 修改密码时通常需要输入两次命令，但是该命令可以一次修改密码，echo 后是密码，–stdin后跟修改的用户名 注：管道符在一行命令中可以使用多次，可以是多个命令组合使用 例： [root@localhost ~]# ll | head -n 4 | wc -l 4 三、通配符有时候我们通常会记不清文件的具体名称，但是如果我们知道文件的部分名称，那么我们就可以使用通配符来相似查找文件 例： [root@localhost ~]# ll /dev/sda* brw-rw—-. 1 root disk 8, 0 Feb 2 06:48 /dev/sda brw-rw—-. 1 root disk 8, 1 Feb 2 06:48 /dev/sda1 brw-rw—-. 1 root disk 8, 2 Feb 2 06:48 /dev/sda2 brw-rw—-. 1 root disk 8, 3 Feb 2 06:48 /dev/sda3 查找所有包含sda的文件 例： [root@localhost ~]# ll /dev/sda[0-9] brw-rw—-. 1 root disk 8, 1 Feb 2 06:48 /dev/sda1 brw-rw—-. 1 root disk 8, 2 Feb 2 06:48 /dev/sda2 brw-rw—-. 1 root disk 8, 3 Feb 2 06:48 /dev/sda3 例： [root@localhost ~]# ll /dev/sda[a-z] ls: cannot access /dev/sda[a-z]: No such file or directory 四、常见的转义字符如果输出的字符是特殊字符，而特殊字符不能输出的时候，就可以用到转义字符 例： [root@localhost ~]# echo $SHELL /bin/bash 如果想在结果前加一个$ [root@localhost ~]# echo $$SHELL 3639SHELL 结果不是我们想要的，多加一个$成了输出bash的PID，因此需要转义字符 [root@localhost ~]# echo \\$$SHELL $/bin/bash 注：两个$$是输出bash的进程号 [root@localhost ~]# echo $$ 3639 四个常见的转义字符： 反斜杠（\\）：使反斜杠后面的一个变量变为单纯的字符串。 单引号（’’）：转义其中所有的变量为单纯的字符串。 双引号（””）：保留其中的变量属性，与不带“”作用相同 反引号（）：把其中的命令执行后返回结果。 1、反斜杠前面已经介绍了 2、单引号是范围内的都按字符串处理 ​ 例： [root@localhost ~]# echo ‘$SHELL’ $SHELL [root@localhost ~]# echo ‘\\$$SHELL’ \\$$SHELL 可以看出没有进行转换，而是原样输出 3、双引号 例： [root@localhost ~]# echo “$SHELL” /bin/bash [root@localhost ~]# echo “\\$$SHELL” $/bin/bash 4、反引号 [root@localhost ~]# echo uname -a Linux localhost.localdomain 3.10.0-327.el7.x86_64 #1 SMP Thu Oct 29 17:29:29 EDT 2015 x86_64 x86_64 x86_64 GNU/Linux 命令的结果作为输出 五、环境变量变量是计算机系统用于保存可变值的数据类型。在Linux系统中，变量名称一般都是大写的，这是一种约定俗成的规范。我们可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。 1）命令在Linux中执行的过程 （1）判断用户是否以绝对路径或相对路径输入，是则直接执行 ​ 例：/bin/ls （2）检查用户输入的命令是否是别名 （3）bash解释器判断是内部命令还是外部命令 （4）多路径查找用户输入的命令文件 2）系统中重要的10个环境变量 变量名称 作用 HOME 用户的主目录（即家目录） SHELL 用户在使用的Shell解释器名称 HISTSIZE 输出的历史命令记录条数 HISTFILESIZE 保存的历史命令记录条数 MAIL 邮件保存路径 LANG 系统语言、语系名称 RANDOM 生成一个随机数字 PS1 Bash解释器的提示符 PATH 定义解释器搜索用户执行命令的路径 EDITOR 用户默认的文本编辑器 3）自定义变量[root@localhost ~]# WORD=home [root@localhost ~]# echo $WORD home 这样定义的变量不具有全局性，可以提升为全局性 [root@localhost ~]# export WORD","categories":[{"name":"Linux","slug":"Linux","permalink":"http://soliym.top/categories/Linux/"}],"tags":[{"name":"Rhcsa","slug":"Rhcsa","permalink":"http://soliym.top/tags/Rhcsa/"}]},{"title":"云服务器搭建Web网站二","slug":"云服务器搭建Web网站二","date":"2019-12-26T07:08:51.000Z","updated":"2019-12-26T07:15:35.727Z","comments":true,"path":"2019/12/26/云服务器搭建Web网站二/","link":"","permalink":"http://soliym.top/2019/12/26/云服务器搭建Web网站二/","excerpt":"前面讲到我们访问网站是通过IP地址并且后面还需要加/wordpress,这样访问太过于繁琐，而且不是基于https网站，那么下面将通过注册域名来使网站的访问更加简单","text":"前面讲到我们访问网站是通过IP地址并且后面还需要加/wordpress,这样访问太过于繁琐，而且不是基于https网站，那么下面将通过注册域名来使网站的访问更加简单 一、域名注册在阿里云注册域名，t根据自己需求购买域名，如果是学习测试可以使用便宜的域名，比如top，在阿里云购买以后，会有一段的审核时间 二、域名解析DNS域名解析的具体过程就不在说了，下面介绍域名和IP的绑定 1、在阿里云的控制台中找到购买的域名，点击解析 2、在解析里面添加记录，会有5个选项 ​ 记录类型：在阿里云中关于各种类型会有介绍，主要是A、AAAA和CNAME, ​ 主机记录：也就是主机名称，表示某个域下的某台主机，www就是表示一台web主机，常用的 www、@、mail，主机记录的后面的问号给出了它们的用处 解析线路：默认就可以了 记录值：不同的记录类型有不同的写法，比如A对应IPV4，CNAME对应域名，详细可以在阿里云右上如何 设 置解析查看，ip与域名绑定肯定需要ip的，这个就是域名服务器的公网ip TTL：也就是域名服务器的更新时间，为保证各域名是否正在运行，则需要定期更新，默认10分钟就可以 ​ 我们需要添加两 条记录，一条是www还有一条@，表示我们可以通过www.xx.com和xx.com方式访问 三、云服务器设置域名解析正常后，通过域名访问到的是云服务器/var/www/html/index.html文件，如果要正常访问wrodpress就需要对服务器的配置文件进行设置 1、通过IP地址直接访问wordpress复制wordpress中的index.php文件到网站根目录/var/www/html，下并修改文档最后一句 123[root@instance-3naulqbx html]# mv /var/www/html/wordpress/index.php /var/www/html[root@instance-3naulqbx html]# vim index.phprequire( dirname( __FILE__ ) . &apos;/wordpress/wp-blog-header.php&apos; ); 2、通过https访问wordpress将网站设置为https，https比http安全性更好，在http的基础上添加一个安全套层，在http连接建立前通过密钥协商，对传输内容加密 自定义ssl文件，访问网站时会有风险提示，如果要解除提示，需要申请证书，可在云服务器提供商处购买证书 1）安装ssl1[root@instance-3naulqbx html]# yum install mod_ssl -y 2）新建加密文件12[root@instance-3naulqbx html]# cd /etc/pki/tls/certs[root@instance-3naulqbx certs]# make wordpress.crt 3）修改配置文件1root@instance-3naulqbx certs]# vim /etc/httpd/conf.d/vhosts.conf 将下面的内容复制到vhosts.conf中 123456789101112131415&lt;Directory /www&gt; AllowOverride none Require all granted&lt;/Directory&gt;&lt;VirtualHost 106.12.193.196:80&gt; DocumentRoot /www/html ServerName 106.12.193.196 ErrorLog &quot;/var/log/httpd/dummy-host2.example.com-error_log&quot; CustomLog &quot;/var/log/httpd/dummy-host2.example.com-access_log&quot; common SSLEngine on SSLProtocol all -SSLv2 SSLCipherSuite HIGH:MEDIUM:!aNULL:!MD5:!SEED:!IDEA SSLCertificateFile /etc/pki/tls/certs/wordpress.crt SSLCertificateKeyFile /etc/pki/tls/certs/wordpress.key&lt;/VirtualHost&gt; 4）重启服务1[root@instance-3naulqbx certs]# systemctl restart httpd 因为ssl证书是自签名的所以网站访问会有风险提示，可以选择购买ssl证书 （1）购买DV（域名型）证书 （2）使用DNS验证 在域名解析中添加一条记录，根据提示验证完成后，下载证书，证书会包含中平台的证书文件，将Apache文件夹下的三个文件通过xftp上传到服务器 var/www/ssl/ssl/ （3）修改https配置文件 1234[root@instance-3naulqbx ~]# vim /etc/httpd/conf.d/ssl.confSSLCertificateFile /var/www/ssl/ssl/zhixingit.top_ssl.crt SSLCertificateKeyFile /var/www/ssl/ssl/zhixingit.top_ssl.key SSLCertificateChainFile /var/www/ssl/ssl/zhixingit.top_chain.crt 将以上三行的属性修改为上传的证书文件的地址，注意后缀名要对应 （4）重启服务 重启服务后显示仍然会有风险提示，但是现在的提示为“证书对某IP无效，以及对某域名有效”，应为DV为域名型证书，只对域名有效，通过IP访问不能通过 3、通过域名访问wordpress1）在域名解析正常后，仍不能正常访问网站，因为需要备案，只有备案通过后才能访问","categories":[{"name":"Linux","slug":"Linux","permalink":"http://soliym.top/categories/Linux/"}],"tags":[{"name":"Web服务器","slug":"Web服务器","permalink":"http://soliym.top/tags/Web服务器/"}]},{"title":"云服务器搭建web网站一","slug":"云服务器搭建Web网站一","date":"2019-12-24T08:19:08.000Z","updated":"2019-12-24T08:40:31.928Z","comments":true,"path":"2019/12/24/云服务器搭建Web网站一/","link":"","permalink":"http://soliym.top/2019/12/24/云服务器搭建Web网站一/","excerpt":"本文是关于在云服务器上搭建web服务器的过程，云服务器是百度智能云上的学生套餐，安装的是Linux的centos，下面将从云服务器的购买到搭建wordpress网站，详细介绍每一步流程","text":"本文是关于在云服务器上搭建web服务器的过程，云服务器是百度智能云上的学生套餐，安装的是Linux的centos，下面将从云服务器的购买到搭建wordpress网站，详细介绍每一步流程 一、购买云服务器在百度云购买云服务器，学生8元/月，操作系统Linux，入门级服务器，在腾讯云中也有学生优惠套餐，10元/月，服务器在哪都可以，重点是操作系统，本文以centos7.2位例 二、登录云服务器1、在实例设置中重装操作系统，版本为centos7以上，通过密码登录2、通过浏览器的VNC远程登录3、通过Xshell登录1）通过公网IP地址登录 2）查看Linux版本 12[root@instance-3naulqbx ~]# cat /etc/centos-releaseCentOS Linux release 7.2.1511 (Core) 三、云服务器配置1、查看是否安装httpd(Apache)及软件包管理器yum12[root@instance-3naulqbx /]# rpm -ql httpd [root@instance-3naulqbx /]# rpm -ql yum 2、安装httpd，如果安装则跳过1[root@instance-3naulqbx /]# yum install httpd 3、重启httpd服务1[root@instance-3naulqbx ~]# systemctl restart httpd 4、在浏览器中测试1http://你的公网IP地址 如果显示Apache的欢迎界面，则配置成功，那么web服务的基础配置完成 四、网站搭建1、静态网站/var/www/html目录下创建index.html文件，该文件是web网站访问的默认访问页面，如果有该文件，则客户端访问该页面，没有则访问Apache的欢迎界面 1[root@instance-3naulqbx ~]# vim /var/www/html/index.html 在文件中写入helloworld -————————— 关于vim的操作，可以去学习一下，在网站部署中会经常用到，一般操作，按I 编辑文件，按esc回到命令模式，然后Ctrl+：进入到末行模式，输入wq 保存退出 -————————— 静态网站就搭建完成，可以通过前端修改index.html 2、wordpress网站搭建LAMP=Linux+Apache+mariadb+php 以上表示Linux服务器搭建动态网站需要的四种工具 操作系统Linux、Web服务平台Apache、数据库mariadb（MySQL）、PHP脚本语言 因此，在服务器中必须包含四种工具，前面已经安装了前两个，接下来安装后两个 12[root@instance-3naulqbx ~]# yum install php* -y[root@instance-3naulqbx test]# yum install -y mariadb-server.x86_64 安装完以后重启mariadb 1[root@instance-3naulqbx test]# systemctl restart mariadb （1）上传WordPress源码1）在/下创建一个test目录，用来存放web程序 1[root@instance-3naulqbx ~]# mkdir /test 2）使用xshell上传源码到服务器 打开xftp，进入到xftp界面，左边为自己主机，右边为服务器，找到test目录，将web程序拖拽到服务器的方框内，上传完成后，在服务器中查看 （2）配置MySQL数据库1）初始化数据库 1[root@instance-3naulqbx test]# mysql_secure_installation 一直回车就可以 2）创建数据库 1[root@instance-3naulqbx test]# mysql -uroot -proot 创建数据库 1MariaDB [(none)]&gt; create database wordpress; 通过show查看是否创建成功 1MariaDB [(none)]&gt; show databases; 注意每条命令后的’;’，输入quit退出 然后重启数据库 1[root@instance-3naulqbx test]# systemctl restart mariadb.service （3）解压web程序进入网站的默认文档目录下，删除index.html文件，然后将web程序移动到该目录下解压 123[root@instance-3naulqbx test]# cd /var/www/html[root@instance-3naulqbx html]# mv /test/wordpress-4.7.4-zh_CN.zip /var/www/html[root@instance-3naulqbx html]# unzip wordpress-4.7.4-zh_CN.zip （4）测试在网站中输入公网IP/wordpress,如果出现WordPress的安装界面，则安装成功 可能出现的问题： 1）如果不出现安装界面，但是出现“Index of /wordpress”界面，可能是PhP或者mysql没有安装成功，检查重装。 2）出现“您的PHP似乎没有安装运行WordPress所必需的MySQL扩展”提示，可用通过安装php-mysql解决 1[root@instance-3naulqbx wordpress]# yum install php-mysql （5）安装wordpress 1）数据库名为服务器创建的数据库名 2）用户名和密码 1[root@instance-3naulqbx test]# mysql -uroot -proot -u后为用户名 -p后为 密码 3）其他默认 4）配置文件 1[root@instance-3naulqbx wordpress]# vim wp-config.php 根据提示建立wp-config.php文件 （6）安装完成如果成功进入到wrodpress界面，那么安装成功，但是在访问该界面时，还是通过IP访问，我们通常都是通过域名访问的，下一节将介绍通过域名访问并且是https访问 （7）关于wrodpresswrodpress中有许多主题和插件，但是下载需要ftp服务，下面提供一个解决方法，可以不用ftp服务就可以在线更新 1234[root@instance-3naulqbx wordpress]# vim wp-config.php define(&quot;FS_METHOD&quot;, &quot;direct&quot;); define(&quot;FS_CHMOD_DIR&quot;, 0777); define(&quot;FS_CHMOD_FILE&quot;, 0777); 打开wp-cinfig.php文件，将这三行添加在最后并且修改wordpress的权限为777 1[root@instance-3naulqbx html]# chmod 777 -R wordpress/ 由于wrodpress官方服务器的问题，现在会出现 “too many Request”问题","categories":[{"name":"Linux","slug":"Linux","permalink":"http://soliym.top/categories/Linux/"}],"tags":[{"name":"Web服务器","slug":"Web服务器","permalink":"http://soliym.top/tags/Web服务器/"}]},{"title":"internet校验和的增量更新","slug":"internet校验和的增量更新","date":"2019-12-05T14:25:59.000Z","updated":"2019-12-05T14:57:22.113Z","comments":true,"path":"2019/12/05/internet校验和的增量更新/","link":"","permalink":"http://soliym.top/2019/12/05/internet校验和的增量更新/","excerpt":"在IP协议中，首部格式中有一个首部校验和字段，该字段采用的校验方法与常用的奇偶校验和循环冗余校验不同，下面将详细介绍这种方法，以及它所遇到的问题及解决方案","text":"在IP协议中，首部格式中有一个首部校验和字段，该字段采用的校验方法与常用的奇偶校验和循环冗余校验不同，下面将详细介绍这种方法，以及它所遇到的问题及解决方案 一、校验方法IP首部的校验方法： 只校验首部不校验数据部分 发送方：将校验和字段置为0，然后将首部以2字节为一组，以二进制反码的形式相加，将其结果取反码后，写入到IP数据报的首部校验和字段。 接受方：与发送方的操作相似，收到数据报后，将首部以2字节16bit为一组，以二进制反码的形式相加，如果结果为1，则表示该数据报的首部在传输中没有差错，否则出现差错。 该方法在TCP/IP协议中有很多协议都会用到，比如TCP、UDP，不同的是，TCP、UDP添加了12字节的伪首部 二、存在的问题在TCP、UDP存在的问题是这种检错的方法并不可靠，但是它简单、效率高，在TCP、UDP中并没有什么太大的缺陷，而在IP数据报中，因为IP数据报是基于第三层网络层转发的，因此，会频繁的对IP数据报修改，比如IP协议中的TTL值，每经过一个路由器都要减去1，该值都要发生变化，对应校验和也要发生变化，而源数据只发生了很小的一次变化，就要重新计算校验和，这大大降低了路由器的转发速率。 在RFC1141文档中提供了一种解决方法：增量更新 即在原始值只发生了很小的变化，可以对校验和做出很小的改变，而不用重新计算校验和 三、解决方案原始校验和C，以及字节m的旧值和新值： ​ C’= C +（-m）+ m’= C +（m’-m） 虽然该公式更新了校验和C，但是没更新校验和的反码 〜C’=〜（C +（-m）+ m’）=〜C +（m-m’）=〜C + m +〜m’ C语言代码实现： 1234567891011/*implemented according with RFC 1071 and1141*/static unsigned short csum_incremental_update(unsigned short old_csum,​ unsigned short old_field,​ unsigned short new_field)&#123; unsigned long csum = old_csum + old_field + (~new_field &amp; 0xFFFF); csum = (csum &gt;&gt; 16) + (csum &amp; 0xFFFF); csum += (csum &gt;&gt; 16); return csum;&#125;","categories":[{"name":"网络","slug":"网络","permalink":"http://soliym.top/categories/网络/"}],"tags":[{"name":"网络层","slug":"网络层","permalink":"http://soliym.top/tags/网络层/"}]},{"title":"Http与Https的区别和加密原理","slug":"Http与Https的区别和加密原理","date":"2019-12-02T13:24:38.000Z","updated":"2019-12-02T13:30:35.557Z","comments":true,"path":"2019/12/02/Http与Https的区别和加密原理/","link":"","permalink":"http://soliym.top/2019/12/02/Http与Https的区别和加密原理/","excerpt":"HTTP与HTTPS的区别及工作过程","text":"HTTP与HTTPS的区别及工作过程 一、HTTP介绍1、什么是HTTP（一）HTTP（Hypertext Transfer Protocol）：超文本传输协议 一种建立在TCP上的无状态连接的应用层协议，HTTP是WWW的数据交互的基础，超文本文档包括超链接链接到其他资源用户可以很容易获取。HTTP发展用来促进超文本和WWW。所谓协议，就是指双方遵循的规则、约定。http协议，就是浏览器和服务器之间进行通信的一种规规则。 （二）TCP-IP详解对HTTP的概述 H T T P是一个简单的协议。客户进程建立一条同服务器进程的 T C P连接，然后发出请求并读取服务器进程的响应。服务器进程关闭连接表示本次响应结束。服务器进程返回的文件通常含有指向其他服务器上文件的指针 (超文本链接)。用户显然可以很轻松地沿着这些链接从一 个服务器到下一个服务器。 2、HTTP特点1、简单：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的不同类型。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3、请求-响应模式：客户端每次向服务器发起一个请求时都建立一个连接， 服务器处理完客户的请求即断开连接。 4、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 3、HTTP工作过程（一）概述HTTP客户端发起请求，创建端口。 HTTP服务器在端口监听客户端请求。 HTTP服务器向客户端返回状态和内容 （二）详解1、输入地址后回车，首先执行域名解析（1）查询浏览器自身的DNS缓冲 （2）如果缓冲失效则查找系统的DNS缓冲 （3）如果系统DNS缓冲没有查到则查看本地Host文件 （4）如果找不到配置则浏览器发起DNS系统调用 （5）主机向DNS服务器发起查询，获取IP地址 2、连接并进行通信（1）浏览器获得域名对应的IP地址后，发起TCP“三次握手” （2）TCP/IP连接建立起来后，浏览器就可以向服务器发送http请求 （3）服务器接收到这个请求，根据路径参数，经过后端的一些处理之后，把处理后的一个结果的数据返回给浏览器 3、浏览器渲染页面4、HTTP的不足（一）安全性 ​ （1）HTTP使用明文通信，内容可能窃取 ​ （2）不验证通信方的身份，因此有可能遭遇伪装 ​ （3）无法证明报文的完整性，有可能已遭篡改 （二）响应时间长 ​ （1）基于TCP工作，可靠但是速度慢 ​ （2）HTTP协议是无状态协议，传输完成后断开TCP连接，下一次的请求需要重新建立连接 （三）臃肿的消息首部 二、HTTP的改进-HTTPSHttps并不是一个崭新的协议，而是在http的基础上发展而来相当于是Http的升级版。它主要是为了解决http协议安全性不足的问题而诞生的。HTTPS 就是在 HTTP 下加入了 SSL 层，从而保护了交换数据隐私和完整性，提供对网站服务器身份认证的功能，简单来说它就是安全版的 HTTP。 Http+加密+认证+完整性保护=https Https的通信端口由SSL/TSL代替了，它是一种应用层协议。一般的情况下http直接和Tcp进行通信，当使用了SSL之后，就会变成先和SSL通信，SSL再和TCP进行通信。 三、HTTPS采用的加密技术（一）对称密钥加密 SSL采用的加密技术叫做“单密钥加密”，也叫作“对称密钥加密”，这种加密方法是这样的，比如客户端向服务器发送一条信息，首先客户端会采用已知的算法对信息进行加密，接收端对加密的信息进行解密的时候需要用到密钥，中间会传递密钥，（加密和解密的密钥是同一个），密钥在传输中间是被加密的。这种方式看起来安全，但是仍有潜在的危险，一旦被窃听，或者信息被挟持，就有可能破解密钥，而破解其中的信息，这种方式存在安全隐患。 （二）非对称密钥加密“非对称加密”使用的时候有两把锁，一把叫做“私钥”，一把是“公钥”，使用非对称加密的加密方式的时候，服务器首先告诉客户端按照自己给定的公开密钥进行加密处理，客户端按照公开密钥加密以后，服务器接受到信息再通过自己的私有密钥进行解密，这样做的好处就是解密的钥匙根本就不会进行传输，因此也就避免了被挟持的风险。就算公开密钥被窃听者拿到了，它也很难进行解密。 四、HTTPS通信加密机制（一）HTTPS采用混合机制的加密方式https则综合了对称密钥加密和非对称密钥加密的两种方式，充分利用两者的优势，在最初的连接的时候使用非对称密钥的加密方式保证连接的安全性，之后稳定的通讯采用对称加密的方式，稳定的通讯是指确保交换的密钥是安全的。 某网站拥有用于非对称加密的公钥A、私钥A’，浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器，浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器，服务器拿到后用私钥A’解密得到密钥X，这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。 虽然这种加密方式比对称加密和非对称加密安全，但是还是存在漏洞，某网站拥有用于非对称加密的公钥A、私钥A’，浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器，中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’），浏览器随机生成一个用于对称加密的密钥X，用公钥B（浏览器不知道公钥被替换了）加密后传给服务器，中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器，服务器拿到后用私钥A’解密得到密钥X 为了应对这种漏洞，HTTPS加入了一种新的安全机制，证书认证 （二）https的证书机制1、服务器的开发者携带公开密钥，向数字证书认证机构提出公开密钥的申请，数字证书认证机构在认清申请者的身份，审核通过以后，会对开发者申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将密钥放在证书里面，绑定在一起 2、服务器将这份数字证书发送给客户端，因为客户端也认可证书机构，客户端可以通过数字证书中的数字签名来验证公钥的真伪，来确保服务器传过来的公开密钥是真实的。一般情况下，证书的数字签名是很难被伪造的，这取决于认证机构的公信力。一旦确认信息无误之后，客户端就会通过公钥对报文进行加密发送，服务器接收到以后用自己的私钥进行解密。 五、SSL/TLSSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密，所以HPPTS是HTTP+SSL/TCP的简称。 标准化后的SSL更名为TLS(Transport Layer Security 安全传输层协议) （一）SSL协议SSL协议是一个分层的协议，共有两层组成。处于SSL协议的底层的是SSL记录层协议(SSL Record Protocol)，它位于可靠的传输层协议(如TCP)之上，用于封装高层协议的数据。其中SSL握手协议(SSL Handshake Protocol)允许服务方和客户方互相认证，并在应用层协议传送数据之前协商出一个加密算法和会话密钥。 SSL协议实现的安全机制包括： 数据传输的机密性：利用对称密钥算法对传输的数据进行加密。 身份验证机制：基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。 消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性。 （二）加密算法1、散列函数Hash常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性。 2、对称加密常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听。 3、非对称加密即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。 六、SSL/TSL握手过程（一）客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息 （二）服务端返回协商的信息结果，包括选择使用的协议版本，选择的加密套件 ，选择的压缩算法、随机数等，其中随机数用于后续的密钥协商;服务器端配置对应的证书链，用于身份验证与密钥交换 （三）证书校验，客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作 （四）合法性验证通过之后，客户端计算产生随机数字 Pre-master，并用证书公钥加密，发送给服务器 （五）服务器用私钥解密加密的数据，基于之前交换的两个明文随机数，计算得到协商密钥，计算之前所有接收信息的 hash 值，验证数据和密钥正确性; （六）握手结束 七、HTTPS工作流程（一）建立连接1.服务端首先把自己的公钥（Key1）发给证书颁发机构，向证书颁发机构申请证书。 2.证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端。 3.当客户端向服务端请求通信的时候，服务端不再直接返回自己的公钥（Key1），而是把自己申请的证书返回给客户端。 4.客户端收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以客户端只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名，客户端对证书验证成功后，就可以放心地再次利用机构公钥，解密出服务端的公钥Key1。 客户端生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给服务端。 服务端用自己的私钥解开加密，得到对称加密密钥Key2。于是客户端与服务端开始用Key2进行对称加密的通信。 （二）数据传输 对应用层数据进行分片成合适的 block 为分片数据编号，防止重放攻击 使用协商的压缩算法压缩数据 计算 MAC 值和压缩数据组成传输数据 使用 key 加密数据，发送给服务器 服务器收到数据之后使用key解密，校验数据，解压缩数据，重新组装 八、HTTP与HTTPS的不同(1) HTTPS是加密传输协议，HTTP是明文传输协议 (2) HTTPS需要用到SSL证书，而HTTP不用 (3) HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO (4) HTTPS标准端口443，HTTP标准端口80 (5) HTTPS基于传输层，HTTP基于应用层","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://soliym.top/categories/信息安全/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://soliym.top/tags/密码学/"}]},{"title":"单钥密码体制三","slug":"单钥密码体制三","date":"2019-12-01T05:09:52.000Z","updated":"2019-12-01T05:33:51.432Z","comments":true,"path":"2019/12/01/单钥密码体制三/","link":"","permalink":"http://soliym.top/2019/12/01/单钥密码体制三/","excerpt":"下面介绍我国的商用分组密码SM4及单钥密码中的分组密码","text":"下面介绍我国的商用分组密码SM4及单钥密码中的分组密码 一、SM4的特点1、 数据分组长度=128位、密钥长度=128位 数据处理单位：字节（ 8位），字（32位） 2、 基本轮函数加迭代 解密算法与加密算法相同-密钥使用顺序不同 二、SM4 密码算法基本运算1、SM4使用模2加和循环移位运算1）模2加：⊕，32 比特异或运算 2）循环移位：&lt;&lt;&lt; i ，把32位字循环左移i 位 2、代换运算：S盒起混淆作用，输入8bit序列，输出8bit序列 运算规则根据s盒代换 3、非线性变换由4个并行的S盒构成，输入x1,x2,x3,x4,输出y1,y2,y3,y4 运算规则根据s盒代换 4、线性变换起扩散作用，输入32bit，输出32bit，循环移位 L(B)=B^(B&lt;&lt;&lt;2)^(B&lt;&lt;&lt;10)^(B&lt;&lt;&lt;18)^(B&lt;&lt;&lt;24) 5、合成变换由非线性变换和线性变换复合而成 6、轮函数轮函数运算式：F(x0,x1,x2,x3,rk)=x0^T(x1^x2^x3^rk) T函数本质上分两步：一是S盒非线性变换，另一个是线性移位。 三、加密流程加密与解密流程图 算法流程图 四、加密步骤1、明文分组SM4算法分组长度为128bit，也就是16个字节，如果SM4算法分组长度为128bit，也就是16个字节，如果明文字节数不是16的整数倍，仍然采取补0凑足128位的方法。 将明文转换成二进制，然后以128bit分组。 2、明文组分组将128bit的明文组均分为各32bit的子组。 3、合成变换 非线性变换S盒置换规则： SM4中利用了4个完全相同的S盒，每个S盒对应8位的输入和8位的输出 以输入的前半字节为行号，后半字节为列号，行列交叉点处的数据即为输出 线性变换循环移位加： 运算规则： C=L（B）=B⊕(B&lt;&lt;&lt;2)⊕(B&lt;&lt;&lt;10)⊕(B&lt;&lt;&lt;18) ⊕(B&lt;&lt;&lt;24) 流程：X1,x2,x3,rk先异或输出32bit数，然后非线性变换，由四个并行的s盒置换，输出32bit数，在经线性变换，输出32bit数 4、轮函数X0&lt;-x1,x1&lt;-x2,x2&lt;-x3,x3-&lt;x0^T(x1^x2^x3^rk) 5、反序变换R（x32,x33,x34,x35）=（x35,x34,x33,x32） 五、密钥生成 1、系统参数FK 2、固定参数CK 1、初始密钥MK分为4X32=128bit 2、MK与FK异或得到K 3、32轮函数变换得到32个子密钥，轮函数与加密过程基本相同，只是将线性变换修改为 L(B)=B⊕(B&lt;&lt;&lt; 13**)⊕(B&lt;&lt;&lt; 23),加密函数中用到的是密钥，而密钥扩展算法中用到的是32bit固定参数CK 六、安全性①国家专业机构设计。算法简洁，以字和字节为处理单位，对称运算，符合当今分组密码主流。 ②专业机构进行了密码分析，因此是安全的。 ③民间学者对21轮SM4进行了差分密码分析。 ④尚需经过实践检验。 七、流密码流密码流密码：将明文划分成字符，或其编码的基本单元，字符分别与密钥流作用进行加密，解密时以同步产生的同样的密钥流实现。流密码强度完全依赖于密钥所产生的序列的随机性和不可预测性。 如果密码序列是一个非周期序列，那么可以做到一次一密体制，一次一密可以实现无条件安全。 ZUC算法ZUC本质上一个密钥序列产生的算法，其输入为128bit的初始密钥和128比特的初始向量，输出为32比特的密钥字序列，其逻辑上分为三层，分别是：16级线性反馈移位寄存器（LFSR），比特重组（BR），非线性函数F。","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://soliym.top/categories/信息安全/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://soliym.top/tags/密码学/"}]},{"title":"AES列混淆机制详解","slug":"AES列混淆机制详解","date":"2019-11-25T09:04:37.000Z","updated":"2019-11-25T10:23:29.069Z","comments":true,"path":"2019/11/25/AES列混淆机制详解/","link":"","permalink":"http://soliym.top/2019/11/25/AES列混淆机制详解/","excerpt":"在AES中列混淆是比较重要的一步，在列混淆的设计中，设计的算法思想及运算机制是非常值得学习，它包括多项式相乘的处理，以及十六进制乘法中的Xtime机制","text":"在AES中列混淆是比较重要的一步，在列混淆的设计中，设计的算法思想及运算机制是非常值得学习，它包括多项式相乘的处理，以及十六进制乘法中的Xtime机制 一、多项式在AES中列混淆是将矩阵的每一列通过运算得到一列新的值，这个运算即使矩阵相乘，将行位移后的矩阵的列，表示为多项式，该多项式有4个项，最高项的次幂为3，多项式系数为矩阵的列值，按列值的行号等于每一项的次幂，得到一个多项式，记为s(x)； 在固定给出一个多项式，该多项式与s(x)一样，同为最高项的幂为3，该多项式的系数是固定的，这里记为c(x)； 那么通过两多项式相乘可以得到一个多项式f(x)，但是这个多项式并不是一个最高次幂是3的多项式，因此需要对该多项式取余，即模X^4+1; 因为x^4+1在F2上约等于(x+1)^4,模一个4次多项式是为了得到一个三次多项式。 即：X^(i)mod(X^4+1)=X^(imod4) 二、多项式相乘计算两个多项式相乘并不是容易的事，但是可以通过的矩阵的运算，直接求解f(x)的系数 可以得到：x^3的系数为s3c0+s2c1+s1c2+s0c3，通过验证，多项式的系数可以通过两个矩阵相乘得出，两个矩阵由s(x)和c(x)得出： 首先根据固定的多项式可以得到一个4X4的矩阵，第3行排列c3 、c2、c1、c0，然后第2行为c2、c1、c0、c3，每一次根据i+1行的循环左移一位，因此，第0行为c0、c3、c2、c1 s(x)可以得到一个4X1的矩阵，即s0、s1、s2、s3，然后两个矩阵相乘可以得到一个4X1的新列，AES列混淆，就是用这个新列去代换旧列 三、Xtime()机制因为明文矩阵和固定多项式的系数是8bit，即用十六进制表示，因此会遇到十六进制相乘，Xtime()就是简化这个过程 由上述可以总结：对于02或是03这样的乘法，那我们就可以通过Xtime()机制优化算法 Xtime()： 将括号内的数左移一位，判断是否有溢出 1、无溢出，直接输出 2、有溢出，异或1B后输出 判断最高位是否溢出：如果最高位为0，则一位后不输出，如果为1，则移位后溢出 四、列混淆的完整表达式","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://soliym.top/categories/信息安全/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://soliym.top/tags/密码学/"}]},{"title":"单钥密码体制二","slug":"单钥密码体制二","date":"2019-11-24T11:54:21.000Z","updated":"2019-11-25T08:55:29.210Z","comments":true,"path":"2019/11/24/单钥密码体制二/","link":"","permalink":"http://soliym.top/2019/11/24/单钥密码体制二/","excerpt":"数据加密标准-DES是第一个并且也是十分重要的现代对称加密算法，但是由于DES密钥太短，伴随着计算机的计算能力的突飞猛进，DES已经极其不安全，所以需要新的加密算法代替DES，由2000年公布的AES高级加密标准代替DES。","text":"数据加密标准-DES是第一个并且也是十分重要的现代对称加密算法，但是由于DES密钥太短，伴随着计算机的计算能力的突飞猛进，DES已经极其不安全，所以需要新的加密算法代替DES，由2000年公布的AES高级加密标准代替DES。 一、AESRIJIdael是分组长度和密钥长度均可变的分组密码，密钥长度和分组长度可以独立指定为128b、192b、256b，由比利时密码学家Daemen和Rijmen设计。 二、加密流程图 三、加密步骤1、明文分组AES是分组密码，将明文分成固定长度大小的组，每组分别加密，以128为例，将128bit的明文以字节为单位分为16组，在按序每4字节为一列，组成4X4矩阵。 2、字节代换在4X4矩阵中，每个元素都是1字节，8bit，因此，每个元素的前4bit组成行，后4bit组成列，通过s盒查找，代换为新的元素 3、行位移将4X4矩阵每行循环左移i个元素，i为正整数，从0开始。 4、列混淆将矩阵的每个列视为GF（2^8）上的多项式，再与一个固定的多项式c(x)进行模x^4+1乘法，要求c（x）是模x^4+1可逆的多项式 列混淆的实质是两个多项式的相乘，并且希望得到一个多项式，但是两个多项式相乘的结果最高次项不是3，在列混淆中时两个最高次幂为3的多项式相乘，因此，需要模x^4+1.其中 因为多项式的乘法可由线性代数，即矩阵乘法给出，所以采用矩阵运算。 5、轮密钥加将4X4的明文矩阵和4X4的密钥矩阵按位异或，既128bit与128bit异或 四、密钥生成初始给定的密钥是128bit，用于初始加密，但是在后面的10轮迭代中都需要用到密钥，它们加密的密钥是不同的，需要通过初始的128bit密钥，扩展出10个128bit的密钥。因此，AES加密需要11X128bit的密钥。 密钥是按矩阵的列进行分组的，需要添加40个新列来扩展密钥。 当i可以被4整除，需要用到T函数 T函数：1、RCON轮常量，轮常量是一个字32bit，这个字最右边为3个字节24bit的0。 ​ 轮常量是固定的，每一轮均不相同。 ​ 2、ROTBYTE字节代换，利用S盒对输入的数替换，前4bit为行，后4bit为列 ​ 3、BYTESUB字循环，循环左移一个字节，即abcd变为bcda 五、解密过程AES与DES不同，AES的解密过程与加密过程是不同的，不同是指解密的过程是相反的，而Feistel密码的加密解密可以使用相同的电路或程序，因为AES所有中间的加密过程都是可逆的，所以解密过程与加密过程相反，具体操作位加密操作的逆过程。 例：","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://soliym.top/categories/信息安全/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://soliym.top/tags/密码学/"}]},{"title":"单钥密码体制(一)","slug":"单钥密码体制一","date":"2019-11-24T09:34:01.756Z","updated":"2019-11-24T09:57:33.605Z","comments":true,"path":"2019/11/24/单钥密码体制一/","link":"","permalink":"http://soliym.top/2019/11/24/单钥密码体制一/","excerpt":"信息安全的两次变革：第一次是计算机的诞生，许多重要文件存储于计算机中，因此，计算机的主机安全就成为了一个重要的问题。第二次是计算机网络及分布式系统的诞生，人们利用网络对数据传输，在这个复杂且庞大的网络中，如何去传输重要数据，这又给信息安全带来新的问题和挑战。随着这些问题的解决，密码学也在不断的发展中。信息安全的四个目标：保密性、完整性、可用性、合法使用。","text":"信息安全的两次变革：第一次是计算机的诞生，许多重要文件存储于计算机中，因此，计算机的主机安全就成为了一个重要的问题。第二次是计算机网络及分布式系统的诞生，人们利用网络对数据传输，在这个复杂且庞大的网络中，如何去传输重要数据，这又给信息安全带来新的问题和挑战。随着这些问题的解决，密码学也在不断的发展中。信息安全的四个目标：保密性、完整性、可用性、合法使用。 一、单钥密码体制单钥密码体制也称为私钥加密体制，因为通信双方采用的密码相同，因此，也称为对称加密体制，根据其加密算法的特点，可分为：分组密码和流密码。 古典密码：是一种简单的加密体制，它伴随着密码学的发展，它的思想对单钥密码体制影响深远，代换和置换思想，是单钥密码体制的基础。 密码学可分为古代密码、近代密码、现代密码，它有两个重要的时期，一是1949，密码学成为一门学科，二是1976年，公钥密码算法的出现。 密码学的进程：从单表代替到多表代替，再到机械码，以及现在的现代密码学，未来将会出现的量子密码学。 密码学中有一个重要的定律：伯格夫斯基定律：每一个密码都是可以破解的 虽然有些密码至今没有人可以破解，但是根据密码学的加密规则来说，密文都是根据一定的规则由明文加密而来，因此，密文肯定是可以破解的，只是时间和方法问题。 既然所有的密码都是可以破解的，那么机密算法的安全性在哪？ 1、破译的成本超过加密信息性价值 2、破译的时间超过加密信息的生命周期 二、分组密码DES1、DESDES是一种分组加密算法，输入的明文为64位，密钥为56位，生成的密文分组长度为64位 2、DES算法1、对输入分组进行固定的“初始置换”IP运算，可以将这个置换表示为： 注意：这里L0和R0称为“左右半分组”，各为32比特。IP是固定的函数（即输入密钥不是它的参数），它是公开的。这个过程实际上为“扩散（ Diffusion ）”。 2、迭代运算，即将下面的运算迭代16轮 这个过程就是香农信息论中的“混淆” 3、将16轮迭代后得到的结果（L16, R16）输入到IP的逆置换IP-1中： 注意：DES算法的加密和解密运算均采用这3个步骤。仅有的不同是：如果加密算法中使用的轮密钥次序为k1, k2, …, k16，那么解密算法中使用的密钥次序为：k16, k15, …, k1。 加密流程： 3、密钥生成 4、迭代结构 DES的轮结构重点在于F函数，F函数将32bit明文扩展为48bit密文，然后在于密钥异或，再通过S盒的替换，压缩成32bit。 F函数中明文的扩展：将明文分为8*4的矩阵，在矩阵的左右两侧，各加入一列元素，元素生成规则为：元素空间为0到32，左侧一列为第一列元素-1，如果为-1，则为32，右侧一列+1模32 F函数中的密文压缩：通过8个s盒的代换，代换规则，将48bit密文分为8组，每组6bit，分别对应8个S盒，然后将每组的第一位和最后一位组成行，其他位组成列，然后查表替换。 三、DES安全性因为DES的密钥太短，因此不能抵抗穷举密钥搜索攻击，已被破解，但是它的思想影响了后来单钥密码体制的设计。 四、DES的设计思想DES的设计主要包含了扩散和混淆，这也是单钥加密算法中，分组密码的基本设计思想，扩散是将密钥对明文的影响尽可能多的去影响明文中的元素，使明文和密文的差别尽可能的大。混淆是将明文和密文的联系尽可能小，通过统计等手段，不能确定明文和密文之间的关系。 扩散和混淆的思想来源于古典密码中的置换和代换。","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://soliym.top/categories/信息安全/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://soliym.top/tags/密码学/"}]},{"title":"vlan接口模式","slug":"vlan接口模式","date":"2019-11-07T13:24:05.138Z","updated":"2019-12-24T08:47:58.730Z","comments":true,"path":"2019/11/07/vlan接口模式/","link":"","permalink":"http://soliym.top/2019/11/07/vlan接口模式/","excerpt":"vlan三种接口模式区别：","text":"vlan三种接口模式区别： Access端口1、收到数据包收到一个数据包，判断是否有vlan信息，如果没有则打上端口的pvid，并进行交换转发 2、发送数据包将数据包的vlan信息剥离，直接发送出去 Trunk端口1、收到数据包1）收到一个数据包，判断是否有vlan信息，如果没有则打上端口的pvid，并进行交换转发 2）如果有vlan信息，则判断该trunk端口是否容许该vlan数据包进入，容许转发，否则丢弃。 2、发送数据包比较端口的pvid和发送的vlan信息，如果相同则剥离vlan信息，然后发送，不相等，则直接发送。 hybrid端口1、收到数据包1）没有vlan信息，则打上端口的pvid，然后交换转发 2）有vlan信息，则判断该端口是否容许该vlan的数据包进入 2、发送数据包判断该vlan的属性 1）untagged 剥离vlan tag，进行转发 2）tagged 直接发送 3）没有接口容许vlan，丢弃 注：交换机内部在处理数据包时，所有数据包一定是打上vlan tag的 总结1、tag报文是在原来以太网mac帧格式的基础上，在源mac和目的mac地址的后面加上4字节的vlan信息，组成802.1q帧，对于vlan信息PC网卡不能识别 2、access端口只能属于一个vlan 3、trunk端口可用于多个vlan通信 4、hybrid端口允许端个vlan通过，可以接受和发送多vlan报文 5、hybrid和trunk端口在处理数据报时，方法是一样的，不同在于，发送数据包，hybrid端口可以容许多个vlan数据包发送时不打标签，trunk端口只容许缺省vlan的数据包发送时不打标签 6、access端口只属于一个vlan，所以它的缺省vlan就是在所在vlan，hybrid和trunk端口属于多个vlan，他们的缺省vlan为vlan 1 7、如果设置了端口的缺省vlan id，当端口收到不带vlan tag的数据包之后，则将数据包转发到缺省vlan所在的交换机端口，当端口发送带有vlan tag的数据包时，如果数据包的vlan id与端口缺省vlan 相同，则交换机将去掉数据包携带的vlan tag，然后转发到该接口。 8、华为交换机的缺省vlan为pvid","categories":[{"name":"CCNP/HCNP","slug":"CCNP-HCNP","permalink":"http://soliym.top/categories/CCNP-HCNP/"}],"tags":[{"name":"HCNP","slug":"HCNP","permalink":"http://soliym.top/tags/HCNP/"}]},{"title":"OSPF(三)","slug":"OSPF(三)","date":"2019-09-23T09:56:03.224Z","updated":"2019-09-23T09:57:49.065Z","comments":true,"path":"2019/09/23/OSPF(三)/","link":"","permalink":"http://soliym.top/2019/09/23/OSPF(三)/","excerpt":"10、过滤OSPF路由利用OSPF的汇总，在汇总条目的同时要求ospf协议传递这些汇总路由来实现路由过滤—cisco、华为均可","text":"10、过滤OSPF路由利用OSPF的汇总，在汇总条目的同时要求ospf协议传递这些汇总路由来实现路由过滤—cisco、华为均可 ospf 1 router-id 4.4.4.4 area 0.0.0.1 abr-summary 192.168.1.144 255.255.255.248 not-advertise 该条路由将不能再传递—3类 [r6]ospf 1 [r6-ospf-1]asbr-summary 192.168.1.132 255.255.255.252 not-advertise 拒绝7类的传递 注：此处所谓的汇总网络号，实际可以是具体的明细路由； 11、OSPF不规则区域（一）规则区域：星型结构—骨干区域位于中心，非骨干区域连接骨干区域 ​ —必须存在合法的ABR 该规则的意义在于减少LSA的更新量—星型结构稳定性较高，性价比好； OSPF存在的条件： 1、直连的邻居间，区域ID必须相同，route-id不同，否则无法建立邻居关系—ABR-连接不同的区域。 2、一台ABR没有连接到骨干区域，则为不合法ABR，不能进行路由信息的共享。 3、合法的ABR上的区域间。可直接进行路由信息共享，无须经过骨干区域。 （二）不规则区域 1、没有连接到骨干的非骨干区域 2、不连续的骨干区域 （三）解决方法： ​ 1）tunnel 隧道–GRE，一种简单的VPN 在两台的ABR上建立tunnel，然后将其宣告到OSPF协议中 配置： interface Tunnel0/0/0 ip address 10.1.1.1 255.255.255.0 tunnel-protocol gre source 34.1.1.1 destination 45.1.1.2 缺点： 1、周期和触发的信息将对中间的穿越区域造成资源的占用； 2、选路不佳 ​ 2）OSPF-vlink 虚电路—网络中合法的ABR（工作的区域0的ABR），和非法ABR间建立一条虚链路（在OSPF协议中构建，没有新生网段） 由合法ABR授权非法ABR进行区域间路由共享 配置： [r3]ospf 1 [r3-ospf-1]area 1 [r3-ospf-1-area-0.0.0.1]vlink-peer 5.5.5.5 此处5.5.5.5为对端ABR的router-id 优点： 没有新生链路，故选路正常 缺点： cisco设备中OSPF虚链路为避免对中间穿越区域周期保活和更新产生资源占用，取消了周期的hello包和周期更新；—- 不可靠，不稳定 华为设备中依然保留周期的hello包和更新—-占用中间区域资源 ​ 3）OSPF多进程双向重发布 OSPF多进程，进程号仅具有本地意义，邻居间建立邻居关系时可以使用不同的进程号； 若在一台设备上同时启动多个进程，那么不同进程存在自己的邻居关系，生成不同的数据库（不共享）； 最终将所有数据库计算所得路由加载于同一张路由表中； 在解决不规则区域时，可以让非法ABR将不同的OSPF区域工作在不同的OSPF进程中，之后使用双向重发布技术来实现路由共享； 配置： [r2]ospf 1 [r2-ospf-1]import-route ospf 2 [r2]ospf 2 [r2-ospf-2]import-route ospf 1 优点：1、选路正常 2、无周期信息 3、但依然可靠（触发更新、邻居关系周期保障） 12、OSPF扩展知识（一）附录E — link-id相同的问题 若一台ABR将两条3类LSA导入其他区域；同时这两条LSA的link-id会相同； 假设：短掩码网段先进入，link-id正常显示；长掩码进入时link-id加反掩码 20.1.0.0/16–link-id 20.1.0.0 20.1.0.0/24–link-id 20.1.0.255 若长掩码先进入，再短掩码进入时，长掩码的信息被刷新为反掩码； link-id相同时，短掩码正常显示，长掩码加反掩码 （二）OSPF选路规则 1、AD（管理距离）无关的第一种情况： r2(config)#router ospf 1 r2(config-router)#distance 109 1.1.1.1 0.0.0.0 本地从RID为1.1.1.1的设备处学习到路由条目，管理距离修改109； 一台路由器从两个OSPF邻居处学习到了两条相同的路由时，仅比较度量值，不关注管理距离；因为仅针对一台邻居进行管理距离修改的结果是要么两台都被改，要么修改失败；-关注IOS版本—有时修改RID大路由器管理距离生效，有时需要修改RID小的设备； 2、AD（管理距离）无关的第二种情况 O IA 3类 O IA 与 O IA路由相遇，到达相同目标的两条3类路由，这两条路由均通过非骨干传递，仅关注cost值，不关注管理距离； 若一条通过骨干区域传递，另一条同过非骨干区域传递–非骨干传递的路由无效 OSPF的水平分割：区域标号为A的3类LSA，不能回到区域A； 3、OE 与OE E为5类 N 为7类 默认所有重发布进入路由条目均为类型2，类型2在路由表中cost值不会显示沿途的累加，仅显示起始度量； ①两条均为OE2或者均为N2，起始度量相同； 关注沿途的累加度量 （OE2路由在表中度量默认不显示内部度量，仅显示起始度量） ②两条均为OE2或者均为N2，起始度量不同；优先起始度量小的路径； 注：以上设计是便于管理员快速干涉选路； 4、OE1路由仅比较总度量（起始度量+沿途累加），仅修改起始度量不一定能干涉选路，必须在修改或使得总度量产生区别才能干涉选路； 拓扑优于路由 1/2LSA计算所得路由优于3/4/5/7类计算所得 内部优于外部 3类优于4/5/7类 类型1优于类型2 E1优于E2，N1优于N2，E1优于N2，N1优于E2； E1与N1相遇，或E2与N2相遇，先比总度量（起始+沿途）小优；度量一致5类优于7类 5、FA-转发地址 正常OSPF区域收到的5类LSA不存在FA值； 产生FA的条件： 1、5类LSA —- 假设R9为ASBR，S0/0口工作的OSPF中，E0/0口工作在非ospf协议或不同ospf进程中；且S0/1也宣告在和S0/0相同的OSPF进程中，同时该接口的工作方式为广播型； 将在5类LSA中出现FA地址，地址为R9连接R10网段中R10的接口ip；R9与R10间运行的是EIGRP协议 意义在于让R9前端的OSPF设备(比如R8)，清楚的知道域外的下一跳拓扑结构，更好的避免环路； 2、7类LSA—必然出现FA地址 假设R9为ASBR，S0/0口工作的OSPF中，S0/1口工作在非ospf协议或不同进程中； S0/1未运行OSPF–FA地址为R9上最后宣告的环回地址（个别IOS也可能是最大环回接口ip地址），若R9没有环回接口；FA地址为R9上最后宣告的物理接口地址（个别IOS也可能是最大的物理接口ip地址） R9的S0/1也工作OSPF协议中，S0/1接口工作方式为广播，那么FA地址为R10接口ip； S0/1的工作方式为点到点，那么FA地址为R9的s0/1口ip 切记：在FA地址出现后，4类LSA无效；人为过滤掉4类LSA，依然可达域外； ​ 当4类LSA存在，却人为过滤了到达FA地址的路由，那么将无法访问域外； ​ 一旦出现FA地址，所有的选路计算均基于FA地址进行； 1、针对存在FA的5/7类路由，4类LSA无意义，仅递归到FA地址；若FA地址被策略过滤导致不可达； 2、路由表中的度量是到FA地址的度量，不是到ASBR的度量； 6、NP位+E位 P位被加密，故抓包时看不见P位； 正常NSSA区域内的1类LSA中，N=1 E=0 标识该区域转发7类LSA，不转发5类 非NSSA区域E=1 N=0 标识可以转发5类，不能转发7类 P位为1，标识该区域将执行7类转5类； P为0，不能7转5； 区域0连接到两个非骨干区域，这两个非骨干假设为区域1和区域2；区域1/2同时连接外部协议，且同时进行了重发布配置；区域1为NSSA区域，区域2为非NSSA区域；那么此时的区域1，P位=0不能进行7转5；故骨干区域只能收到从区域2来的外部路由； 若区域1和区域2均为NSSA区域，那么ABR的RID大区域进行7转5，另一个区域不转， 故骨干区域只能收到从一个区域传递的外部路由； 7、SFP算法 –OSPF防环机制 在同一个区域每台路由具有一致的LSDB 每台路由器以自己为根计算到达每个目标的最短路径（最小cost值） 必须区域划分– 优势-1）域间汇总减少路由条目数量 汇总路由是在所有明细路由均消失后才删除，网络更稳定 区域划分后不同类别的LSA传播范围不同，控制更新量 过程–基于本地LSDB(1/2类LSA)生成–生成有向图–基于有向图来进行最短路径树生成 最短路径树，关注本地LINK-ID的LSA开始–》基于该LSA内提及到点到点或传输网络信息再查看link-id递归到下一条信息；基于所有点到点和传输网络信息生成最短路径树主干； 然后用树中每台设备的末梢网络信息补充路由表，完成收敛 13、OSPF的扩展配置1、认证—接口认证 [r3]interface GigabitEthernet 0/0/1 在直连邻居的接口上配置即可 [r3-GigabitEthernet0/0/1]ospf authentication-mode md5 1 cisco123 密文认证，key编号1，密码为cisco123，密码直接以MD5值传递； 2、被动接口 – 只接受不发送路由协议的信息，其他信息正常通过；华为成为沉默接口 [r3]ospf 1 [r3-ospf-1]silent-interface GigabitEthernet 0/0/0 3、修改计时器—OSPF的hello time 为10或30s；dead time为hello 的4倍； 3类缺省 –》 配置特殊区域后自动生成 – 末梢、完全末梢、完全NSSA 5类缺省—》本地路由表中通过其他协议或OSPF的其他进程生成了缺省路由条目—前提 之后使用重发布机制将改条目重发布到ospf的协议中来； [r4]ospf 1 [r4-ospf-1]default-route-advertise 默认导入路由起始度量为1,类型2； [r4-ospf-1]default-route-advertise type 1 cost 10 修改类型和起始度量 改小计时器可以加快收敛速度，但将增加对网络资源占用；故修改时不宜修改过小，维持原有的倍数关系； [r3]interface GigabitEthernet 0/0/1 [r3-GigabitEthernet0/0/1]ospf timer hello 5 修改本端的hello time，本端的dead time自动4倍关系匹配；直连邻居间hello 和dead time必须完全一致，否则无法建立邻居关系； 缺省路由 – 3类的缺省 5类的缺省 7类缺省 若本地路由表中没有缺省条目，也可以让设备强制向内网发送一条5类缺省 [r4-ospf-1]default-route-advertise always 默认为类型2，cost值为1； [r4-ospf-1]default-route-advertise always type 1 cost 10 修改类型和起源cost； 7类缺省：普通的NSSA区域将自动产生7类的LSA；也可在NSSA区域内手动生成出7类缺省 [r4]ospf 1 [r4-ospf-1]area 1 [r4-ospf-1-area-0.0.0.1]nssa default-route-advertise 默认为类型2 ，起始cost为1； 优选顺序：内部优于外部，类型1优于类型2；","categories":[{"name":"CCNP/HCNP","slug":"CCNP-HCNP","permalink":"http://soliym.top/categories/CCNP-HCNP/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://soliym.top/tags/OSPF/"}]},{"title":"OSPF(二)","slug":"OSPF(二)","date":"2019-09-19T09:46:51.653Z","updated":"2019-09-19T09:51:19.591Z","comments":true,"path":"2019/09/19/OSPF(二)/","link":"","permalink":"http://soliym.top/2019/09/19/OSPF(二)/","excerpt":"7、OSPF 从邻居建立成为邻接关系的条件1、网络类型基于接口网络类型来区别： 接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的","text":"7、OSPF 从邻居建立成为邻接关系的条件1、网络类型基于接口网络类型来区别： 接口网络：判断网络类型，是基于设备接口的二层封装技术来进行的 点到点：在一个网段内只能存在两个节点，即便强制连接第三节点，最终也无法正常的通讯 ​ 串行链路上，二层封装为ppp或hdlc –没有物理寻址 MA：多路访问 –在一个网段内的节点数量不限制； BMA： 广播型多路访问技术；在一个MA网络中同时存在广播机制； ​ 二层封装技术为以太网； NBMA：非广播型多路技术；在一个MA网络中没有广播机制； ​ 二层封装技术为帧中继—串行链路 MGRE–点到点 在点到点网络中，OSPF协议正常均从邻居关系晋升为邻接关系； 在MA网络中，若所有邻居皆建立为邻接关系，将导致大量的重复更新；距离矢量路由协议在MA环境中使用了接口水平分割机制；由于OSPF协议是基于数据库同步对比的方式来进行收敛，故不支持接口的水平分割； ospf最终将在MA网段进行DR/BDR的选举；非DR/BDR间将维持邻居关系，不建立邻接关系来避免重复更新； 2、选举规则比较接口优先级 0-255 大优 默认点到点链路接口不行进行DR/BDR选举，故cisco 优先级为0-不参选 MA网络中所有参选接口默认优选级为1，在优先级一致的情况必须参选设备的route-id数值大优； 干涉选举：修改参选接口的优先级 [r1-GigabitEthernet0/0/0]ospf dr-priority 2 因为选举非抢占，故修改优先级后，必须重启ospf协议进程 reset ospf 1 process Warning: The OSPF process will be reset. Continue? [Y/N]:y 建议：网络存在DR/BDR后，其他设备修改为0，不参选；不需要重启设备的进程； 8、OSPFlsa类型1、OSPF的数据库表—LSDB 链路状态数据库 数据库表中装载OSPF的不同类型的LSA； [r1]display ospf lsdb router 1.1.1.1 具体某条LSA 类别名 link-id 每条LSA均存在以下信息 Type : Router 类别名 Ls id : 1.1.1.1 link-id 在目录中番号 Adv rtr : 1.1.1.1 通告者的RID Ls age : 532 老化时间 正常1800周期刷新，触发更新导致刷新；最大老化3609 Len : 60 长度 Options : E 选项 seq# : 80000003 序列号 chksum : 0xb2ee 校验和码 OSPF的LSA是1800会更新一次序列号会加一 LSA的新旧比较 1、会先比较序列号，序列号越大越优， 2、如果序列号相同，会比较校验值（checksum)越大越优 3、如果校验值也相同，会比较LSA Age时间，是否等于MAX-age时间（3600） 4、如果age时间不等于max-age时间，会比较他们的差值，如果差值大15分钟（900秒），小的优 5、如果age时间不等于max-age时间，会比较他们的差值，如果差值小于15分钟，说明是同一条LSA，忽略其中一条 2、什么情况下LSA会更新： 1、1800到期会更新 2、触发更新（接口地址变化（增加，或删除），修改接口开销值，删除接口，或者删除通告） [r4-ospf-1]import-route rip 1 将RIP进程1重发布到OSPF的进程1 [r5]display ospf lsdb ase originate-router 查看5类LSA ASBR—自治系统边界路由器—协议边界路由器 3、LSA类型 LSA类别 传播范围 通告者 携带信息 LSA-1 router 本地设备所在区域 该区域每台设备的RID 每台设备本地所在区域的直连 拓扑 LSA-2 Network 本地设备所在区域 DR 单个MA网段的拓扑 LSA-3 summary 整个OSPF域 ABR 域间路由 LSA-4 asbr 除ASBR所在的区域 ABR ASBR位置 ​ 外的整个ospf域； asbr 所在区域基于1类交代位置 LSA-5 external 整个OSPF域 ASBR 域外路由 LSA-7 NSSA 本地的NSSA区域 ASBR 域外路由 ​ LSA类别 link-id 通告者 LSA-1 router 通告者的RID 本区域内每台设备必须发送 LSA-2 Network DR的接口ip地址 每个MA网段中的DR LSA-3 summary 域间路由目标网络号 ABR，在经过下一台ABR时，修改为新的ABR的RID LSA-4 asbr ASBR的RID 和ASBR同一区域的ABR，在经过下一台ABR时，修改为新的ABR的RID LSA-5 external 域外路由目标网络号 ASBR LSA-7 NSSA 域外路由目标网络号 ASBR； 离开本地NSSA区域时转换为5类 OSPF协议正常学习到的路由条目优先级为10；重发布进入的路由为150； 9、LSA优化优化OSPF协议，减少LSA的更新量；正常1类LSA是一台设备一条，2类lsa是一个网段的DR一条；3类和5类是一条路由一条LSA；4类是一台ASBR产生一条； 1、汇总—减少骨干区域的更新量 1）域间路由汇总—将非骨干区域汇总到骨干区域 在ABR上进行配置 [r1]ospf 1 [r1-ospf-1]area 2 只能汇总本地通过该区域1、2类LSA产生的路由 [r1-ospf-1-area-0.0.0.2]abr-summary 5.5.4.0 255.255.252.0 注：汇总配置完成后，需要手工添加空接口防环路由 2）域外路由汇总；因为域外路由由ASBR重发布导入；故在导入的ASBR上进行配置 [r4]ospf 1 [r4-ospf-1]asbr-summary 99.1.0.0 255.255.252.0 2、特殊区域-减少非骨干区域的更新量—不能是骨干区域，不能存在的虚链路； ①不能存在ASBR 1、末梢区域 stub 拒绝4/5类的LSA；生成一条3类的缺省路由指向骨干区域 [r5]ospf 1 [r5-ospf-1]area 2 [r5-ospf-1-area-0.0.0.2]stub 切记:该区域所有设备均需要定义为末梢区域； 2、完全末梢区域 在末梢区域的基础上，进一步拒绝3类lsa，仅保留一条3类的缺省； 先将该区域配置为末梢，区域然后仅在abr上定义完全即可； [r1-ospf-1-area-0.0.0.2]stub no-summary ②存在ASBR 1、NSSA 非完全末梢区域—该区域拒绝其他区域的ASBR产生的4/5LSA；本地区域内ASBR产生的5类LSA，以7类在本区域传播，从本区域进入骨干区域时由ABR（新的ASBR）转换为5类，同时自动产生一条7的缺省指向骨干区域； [r4]ospf [r4-ospf-1]are 1 [r4-ospf-1-area-0.0.0.1]nssa 本区域内所有设备均需配置 2、完全NSSA –在NSSA的基础上，进一步拒绝3的LSA；生成一条3类缺省指向骨干区域； 先将该区域配置为NSSA区域，然后仅在ABR上定义完全即可 [r3-ospf-1-area-0.0.0.1]nssa no-summary 切记:考虑到ISP连接网络后，产生的缺省路由与OSPF特殊区域产生的缺省可能导致环路； ​ ISP连接到的哪个区域，那么该区域不能设定为任何的特殊区域；","categories":[{"name":"CCNP/HCNP","slug":"CCNP-HCNP","permalink":"http://soliym.top/categories/CCNP-HCNP/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://soliym.top/tags/OSPF/"}]},{"title":"OSPF(一)","slug":"OSPF(一)","date":"2019-09-19T09:40:53.475Z","updated":"2019-09-19T09:50:58.070Z","comments":true,"path":"2019/09/19/OSPF(一)/","link":"","permalink":"http://soliym.top/2019/09/19/OSPF(一)/","excerpt":"一、动态路由协议1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。","text":"一、动态路由协议1、动态路由协议：直连路由间构建邻居关系，通过相互沟通学习路由信息，来获取未知的路由信息，然后根据不同的路由选择算法，计算到达未知网段的最佳路径，并将其加载到路由表中。 2、动态路由协议分类： ​ 1、基于AS将路由协议分为IGP和EGP ​ AS-自治系统 ​ 0-65535 标准为2个字节 扩展为4个字节 ​ 1-64511 公有 ​ 64512-65535 私有 ​ IGP—内部网关路由协议（as之内使用） ​ RIP/OSPF/EIGRP(Cisco)/isis ​ EGP—外部网关路由协议（as之间使用） ​ BGP/EGP ​ 2、内部网关路由协议—IGP分类 ​ ①更新时是否携带子网掩码：有类别—不携带 ​ 无类别—携带 ​ ②工作特点：距离适量—RIP/EIGRP ​ 基于路由条目收敛 ​ 链路状态—OSPF/ISIS ​ 基于LSA收敛 二、开放式最短路径优先协议1、OSPF协议特点适用范围：IGP 类型：链路状态型动态路由协议 算法：SPF算法 封装：基于IP封装，协议号为89—跨层封装 版本：OSPFV2—IPV4、OSPFV3—IPV6 更新方式：组播或单播—224.0.0.5/224.0.0.6 ​ 触发更新/周期更新—周期更新时间是30min 区域划分：OSPF需要合理规划IP地址和区域划分 ​ —目的：减少lsa数量、减少lsa传播范围、减少对资源的消耗 ​ —原因：OSPF需要消耗大量的路由器资源 metric计算：OSPF使用cost计算metric ​ cost=参考带宽/链路实际带宽 ​ 每条路由信息的metric值=该条路径上每段链路的cost值的总和 router-id：在网络内唯一标识一台路由器 2、区域划分​ 1、区域内传拓扑： ​ —用于每台路由器计算到达所有未知路径的最短路径 ​ —拓扑信息：路由器之间的连接关系 ​ 2、 区域间传路由： ​ —区域间传递计算完成的路由信息 ​ —路由信息：包含的接口的路由信息 ​ 3、区域标识：使用十进制或类似于ip地址的32位二进制 ​ 4、区域划分：基于链路（接口） ​ 5、区域类型：骨干区域 ​ —区域0，必须存在且唯一 ​ 非骨干区域 ​ —非0区域 ​ 6、 路由器的角色： ​ —骨干路由器：一个路由器的所有接口都在area 0中 ​ —非骨干路由器：一个路由器的所有接口都不在area 0 中 ​ —ABR：区域边界路由器：能够产生3类LSA的路由器既有接口属于area 0 又有接口属 于非area 0 ​ —ASBR：自治系统边界路由器，能够产生5类或7类LSA的路由器，连接ospf网络和非ospf网络，并且将非ospf引入到ospf网络中 ​ 7、区域划分规则 ​ ①OSPF网络中必须存在并唯一的骨干区域（若OSPF仅仅存在一个区域可以为非0区域） ​ ②非骨干区域必须与骨干区域直接相连（非骨干不能非骨干直接相连） ​ 8、不规则区域：1.不连续的0区域 2.非骨干没有挂靠在骨干区域之上 3、OSPF数据报 OSPF数据包跨层封装于三层报头 五类数据报： 1、hello（224.0.0.5）：发现、建立、保活邻居关系、邻接关系 2、DBD-数据库描述包：本地链路状态数据库的目录 3、LSR-链路状态查询：根据DBD中的描述，对未知的lsa请求 4、LSU-链路状态更新：对请求的LSR的回复，携带lsa信息 5、LSACK-链路状态确认：确认包，保证lsa传递的可靠性 DBD：数据库描述数据包 使用隐式确认，分为两种：1.主从选举DBD-包含mtu，若不一致则停留在预启动 2.发送LSA头部摘要信息（LSA目录） 由于IP数据报不可靠，所以除hello外，其他数据包需要确认 DBD—序列号，显示或隐式确认 LSR—LSU LSU—LSACK 4、OSPF状态机down：一旦收发hello，则进入下一状态 init—初始化：当接收到的hello中携带自己的router-id，则进入下一状态 2way—双发通信：邻居关系建立的标志 ​ 点到点网络直接进入下一状态，ma网路进行DR/BDR选举 ​ 条件匹配：若条件匹配成功，进入下一状态 ​ 若条件匹配失败，停留在当前状态，依靠hello保活邻居关系 Exstart预启动:通过类hello包DBD进行主从关系选举，router-id大的为主，优先进入下一状态 ​ （通过主从选举确定先发送DBD的一方，确保传输的可靠性和对链路带宽的占用小） 如果mtu不相同则停留在该阶段 exchange准交换：使用真正的DBD包进行数据库目录的共享 loading 加载：使用LSR/LSU/LSack来获取未知的LSA信息 lsr–请求列表-针对每一条发送lsu lsu–重传列表-对方收到lsu后发送ack确认，如果没收到，则重发 full转发:邻接关系建立的标志 5、OSPF工作方式启动宣告配置完成后，路由器开始组播（224.0.0.5）收发OSPF的hello包；若接收到的hello包中存在本地的route-id，建立邻居关系，生成邻居表； 之后基于表格中所有的邻居进行条件的匹配，匹配失败将维持邻居关系，仅hello包周期保活即可； 匹配成功者间可以建立邻接关系；邻居间使用DBD进行数据库目录的比对；之后使用LSR查询目录中未知的LSA信息，对端使用LSU来携带传递LSA，最终需要LSack进行接收确认； 当本地收集到区域内所有设备的LSA后，生成LSDB—链路状态数据库表； 本地基于LSDB启用SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表内； 收敛完成，仅hello包周期保活所有的邻居和邻接关系；每30MIN周期进行DBD包的收发来进行纠错； 结构突变： 新增网段—直连新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛 断开网段—断开新增网段设备使用DBD来告知所有的邻居，邻居进行LSR/LSU/LSACK收敛 无法沟通—-dead time 和最大老化来解决 正常邻居间存在hello包，若超过dead time依然没有hello包，断开邻居关系，删除从该邻居处学习到的所有信息 若邻居关系依然正常，但每30min的周期没有正常进行，每条lsa后方存在一个老化时间，默认最大为3609s；到达最大老化时删除该LSA信息即可； 名词： Router-ID：路由器标示符，用于标识该路由器在OSPF网络中的唯一性 选举规则：1.手工指定最优先 2.最大的环回接口地址 3.最大的物理接口 hello时间、dead时间：默认10、40或 30、120s DR优先级 ： DR：指定路由器 BDR：备份指定路由器 LSA：链路状态通告；在不同条件下存在不同类别的LSA，用于携带拓扑或路由 LSDB：链路状态数据库；所有LSA的集合 OSPF收敛行为—OSPF的LSA洪泛 ​ OSPF的LSDB同步 OSPF邻居关系建立条件： 1.router-ID必须不同 2.area-ID必须一致 3.认证类型和认证型数据都一致 4.hello时间、dead时间都一致 5.特殊区域标识必须一致 6.若在MA网络中，network mask必须一致 7.必须同时使用单播或组播 6、OSPF基础配置（一）ciscor1(config)#router ospf 1 启动时需要配置进程号，仅具有本地意义 r1(config-router)#router-id 1.1.1.1 配置RID，要求为全网唯一 ​ 手工—环回接口最大数字—物理接口最大数字 宣告：1、激活 2、路由或拓扑 3、区域划分 r1(config-router)#network 1.1.1.1 0.0.0.0 area 0 r1(config-router)#network 12.1.1.0 0.0.0.255 area 0 ​ 反掩码 启动配置完成后，所有设备间使用hello包，发现并建立邻居关系，生成邻居表： Hello time 为10s，dead time 为 hello time 的4倍； r2#show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 1.1.1.1 0 FULL/ - 00:00:34 12.1.1.1 Serial1/0 3.3.3.3 0 FULL/ - 00:00:39 23.1.1.2 Serial1/1 邻居关系建立后，邻居间进行条件匹配，匹配成功者间进入邻接关系；基于DBD/LSR/LSU/LSack获取未知LSA信息，生成LSDB–数据库表； r2#show ip ospf database LSDB同步完成后，本地使用SPF最短路径选路规则，将到达未知网段的路由加载路由表： 使用字母O标识通过OSPF学习的路由； O 本地区域内的路由，是本地通过拓扑计算所得 O IA 域间路由，其他区域的路由，通过ABR共享进入的 管理距离为110；度量为cost值=开销值=参考带宽/接口带宽 默认参考带宽为100M；整段路径cost值之和最小为最佳路径； 注：当接口带宽大于参考带宽时，cost值为1；将可能导致选路不佳，建议修改参考带宽 r1(config)#router ospf 1 r1(config-router)#auto-cost reference-bandwidth ? The reference bandwidth in terms of Mbits per second r1(config-router)#auto-cost reference-bandwidth 1000 切记：整个网络所有设备均需要修改一致； 【5】OSPF建立成为邻接关系的条件—-关注网络类型 点到点–在一个网段内只能存在两个节点 MA网络—在一个网段内节点数量不限制 在点到点网络ospf只能直接建立邻接关系； 在MA网络中为避免重复的更新，将进行DR/BDR选举，所有的非DR/BDR间仅建立邻居关系；DR/BDR与其他非DR/BDR建立邻接关系，基于224.0.0.6沟通； 选举规则： 比较接口优先级 0-255 大优 默认为1； 接口优先级若相同，比较RID； r1(config)#interface fastEthernet 0/0 r1(config-if)#ip ospf priority 3 修改接口优先级 注：ospf选择非抢占的，因此在人为修改了优先级后，必须重启所有设备的OSPF进程 r1#clear ip ospf process Reset ALL OSPF processes? [no]: yes 可以将设备的参选接口优先级修改为0,—-不参选；但至少留一台设备参选，否则将无DR,网络无法通行； （二）华为[r1]ospf 1 router-id 1.1.1.1 启动时需要定义进程号，仅具有本地意义； 建议同时配置ROUTER-ID； ​ 手工—环回最大数值IP地址—物理接口最大数值IP地址 宣告： [r2]ospf 1 router-id 2.2.2.2 [r2-ospf-1]area 0 [r2-ospf-1-area-0.0.0.0]network 12.1.1.2 0.0.0.0 [r2-ospf-1]area 1 [r2-ospf-1-area-0.0.0.1]network 23.1.1.1 0.0.0.0 OSPF的区域划分规则： 星型结构—所有的非骨干区域必须连接到的骨干区域，否则不能进行区域间路由共享 ABR—区域边界路由器 同时工作的多个区域间；合法ABR必须同时工作在骨干区域，否则不能进行区域间的路由共享； 启动配置完成后，路由器间使用hello包收发建立邻居关系，生成邻居表： [r2]display ospf peer Area 0.0.0.0 interface 12.1.1.2(GigabitEthernet0/0/0)’s neighbors Router ID: 1.1.1.1 Address: 12.1.1.1 State: Full Mode:Nbr is Slave Priority: 1 DR: 12.1.1.1 BDR: 12.1.1.2 MTU: 0 Dead timer due in 35 sec Retrans timer interval: 5 Neighbor is up for 00:18:48 Authentication Sequence: [ 0 ] 邻居关系建立后，邻居间进行条件的匹配；匹配成功建立邻接关系，同步LSDB完成后，本地生成LSDB—数据库表； [r2]display ospf lsdb 查看数据库的目录；内部存在各种类别的信息，需要具体查看 LSDB同步完成后，本地基于SFP算法，计算到达所有未知网段的最短路径，然后将其加载到路由表中； [r3]display ip routing-table 查看路由表 Destination/Mask Proto Pre Cost Flags NextHop Interface ​ 1.1.1.1/32 OSPF 10 2 D 23.1.1.1 GigabitEthernet0/0/0 ​ 2.2.2.2/32 OSPF 10 1 D 23.1.1.1 GigabitEthernet0/0/0 [r3]display ip routing-table protocol ospf 查看本地所有通过OSPF协议学习到的路由 [r1]display ospf routing 查看本地工作OSPF的直连，及本地通过OSPF学习到的路由 Destination Cost Type NextHop AdvRouter Area 1.1.1.1/32 0 Stub 1.1.1.1 1.1.1.1 0.0.0.0 12.1.1.0/24 1 Transit 12.1.1.1 1.1.1.1 0.0.0.0 2.2.2.2/32 1 Stub 12.1.1.2 2.2.2.2 0.0.0.0 3.3.3.3/32 2 Inter-area 12.1.1.2 2.2.2.2 0.0.0.0 23.1.1.0/24 2 Inter-area 12.1.1.2 2.2.2.2 0.0.0.0 类型标记为Inter-area 代表其他区域产生的路由条目 OSPF的度量值为cost=开销值=参考带宽/接口带宽 默认的参考带宽为100M；OSPF默认优选整段路径cost之和最小； 若接口带宽大于参考带宽，cost值为1；将可能导致选路的不佳，建议修改默认的参考带宽； [r1]ospf 1 [r1-ospf-1]bandwidth-reference 1000 切记：一旦修改，全网所有设备均需修改为一致； ​ ​ ​","categories":[{"name":"CCNP/HCNP","slug":"CCNP-HCNP","permalink":"http://soliym.top/categories/CCNP-HCNP/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://soliym.top/tags/OSPF/"}]},{"title":"EIGRP增强内部网关路由协议简述","slug":"EIGRP增强内部网关路由协议简述","date":"2019-09-02T09:14:50.548Z","updated":"2019-09-02T09:14:50.548Z","comments":true,"path":"2019/09/02/EIGRP增强内部网关路由协议简述/","link":"","permalink":"http://soliym.top/2019/09/02/EIGRP增强内部网关路由协议简述/","excerpt":"EIGRP：增强内部网关路由协议 — cisco私有的协议 无类别距离矢量协议，协议号88；组播更新：224.0.0.10 增量更新—仅触发、无周期更新—–可靠性、更新量小 支持非等开销负载均衡","text":"EIGRP：增强内部网关路由协议 — cisco私有的协议 无类别距离矢量协议，协议号88；组播更新：224.0.0.10 增量更新—仅触发、无周期更新—–可靠性、更新量小 支持非等开销负载均衡 AD 本地下一跳到达目标的度量 FD 本地到达目标的度量 S 最佳路径的下一跳路由器 FS 备份路径的下一跳路由器 FC 可行性条件，成为备份路径的条件 【1】EIGRP的数据包 Hello 包 用于邻居发现、建立、保活 hello time 5s Update包 路由条目–目标网络号+度量值 查询包 查询路径，最佳路径和备份路径—-非等开销负载均衡 应答包 查询确认 ACK 【2】EIGRP的4大组件 组建 Hello机制—-认识所有邻居 PDM —-支持多种网络层协议 （协议有关单元） 协议无关单元 IPX appletalk RTP–可靠传输协议—-借鉴TCP的4种可靠机制–确认、重传、排序、流控（不能超过链路带宽的百分之50） DUAL—扩散更新（弥散更新）算法 【3】EIGRP的工作过程 启动配置后，运行EIGRP协议的路由器，通过组播224.0.0.10向所有的邻居发送hello包；收到邻居的hello包后及表示认识了邻居，生成邻居表； 邻居关系建立后，邻居间使用更新包进行路由信息的共享； 收集到所有的路由条目后，本地生成–拓扑表；—装载所有的最佳和备份路径； 本地默认将拓扑表中的最佳路径全部加载到路由表内；—收敛完成 结构突变： 新增网段—直连新增网段的设备，使用更新包告知所有邻居即可 断开网段—-直连断开网段的设备，发出查询包，通过DUAL，收集应答包来重新收敛 无法沟通—-hello time 5s hold time 15s 更新包、查询包、应答包–均被RTP服务 接收到这三种包时，需要ACK来确认，若未进行确认将单播重传，最大16次，若依然失败断开邻居关系；RTP在转发这三种包时，还会对其进行排序和流控； 【4】EIGRP的配置 r1(config)#router eigrp ? 启动时需要配置AS号 Autonomous system number r1(config)#router eigrp 90 此处理解为全网一致的进程号； r1(config-router)# r1(config-router)#no auto-summary 关闭自动汇总 宣告：激活 路由 r1(config-router)#network 1.0.0.0 r1(config-router)#network 124.1.1.1 0.0.0.0 EIGRP宣告时，可以向rip一样直接配置主类，也可以像OSPF一样使用反掩码进行匹配 启动配置完成后，邻居间使用hello包建立邻居关系，生成邻居表： r2#show ip eigrp neighbors IP-EIGRP neighbors for process 90 H Address Interface Hold Uptime SRTT RTO Q Seq ​ (sec) (ms) Cnt Num 2 124.1.1.4 Fa0/0 10 00:01:59 28 200 0 11 1 23.1.1.2 Se1/1 13 00:02:14 39 234 0 11 0 124.1.1.1 Fa0/0 13 00:02:19 389 2334 0 7 邻居关系建立后，邻居间使用更新包收敛路由信息，生成拓扑表： 本地到达邻居的最佳和备份路径； r3(config)#interface s1/1 r3(config-if)#bandwidth 800 修改接口参考带宽 一个接口的实际传输带宽—-硬件、QOS；参考带宽并不影响实际传输带宽，只影响路由协议的选路； r3#show ip eigrp topology IP-EIGRP Topology Table for AS(90)/ID(3.3.3.3) Codes: P - Passive, A - Active, U - Update, Q - Query, R - Reply, ​ r - reply Status, s - sia Status P 1.1.1.0/24, 1 successors, FD is 2300416 ​ via 23.1.1.1 (2300416/156160), Serial1/0 最佳 ​ via 34.1.1.2 (3842560/156160), Serial1/1 备份 ​ FD AD FD可行距离 —- 本地通过该路径到达目标的度量 AD可行后继距离（通告距离）—-本地的下一跳到达目标的度量值 FC可行条件—-成为备份路径的条件 备份的AD小于不等于最佳路径的FD值 备份路径的意义在于可以和最佳路径一起完成非等开销负载均衡； 非等开销负载均衡：当到达一个目标地址时，若存在两条开销相近的路径时，可以让设备将流量按比例延这些路径同时传输，提高链路的利用率； 差异值：备份的FD/最佳路径的FD=向上取整 设备默认的差异值规定为1，标示仅支持等开销负载均衡 r3#show ip protocols EIGRP maximum metric variance 1 可以通过修改差异值，来实现非等开销负载均衡 r3(config)#router eigrp 90 r3(config-router)#variance 2 r3#show ip route 1.1.1.0 默认设备将最佳路径加载于路由表中： D - EIGRP, EX - EIGRP external 使用字母D标示正常EIGRP学习的路由； 管理距离为90； 度量：复合度量—–各种参数 度量计算公式：存在权重值 Formula with default K values (K1 = 1, K2 = 0, K3 = 1, K4 = 0, K5 = 0): 当K5为0时： Metric = [K1 BW + ((K2 BW) / (256 – load)) + K3 * delay] 当K5大于0时: Metric = [K1 BW + ((K2 BW) / (256 – load)) + K3 delay] [K5 / (reliability + K4)] 带宽 可靠性 延迟 负载 MTU 默认k值下度量计算为带宽+延时： 带宽=（10^7/整路径最小带宽）*256 延时=（整段路径入口的延时之和/10）*256 256为放大因子—-1、放大参数便于比较 2、兼容IGRP 【5】EIGRP的扩展配置 认证 r2(config)#key chain a r2(config-keychain)#key 1 r2(config-keychain-key)#key-string cisco123 r2(config)#interface s1/1 r2(config-if)#ip authentication key-chain eigrp 90 a r2(config-if)#ip authentication mode eigrp 90 md5 注：EIGRP仅支持MD5认证，故在没有修改模式前，认证是无意义的 手工汇总–在更新源路由器上，所有更新发出接口上进行配置 r3(config)#interface s1/0 r3(config-if)#ip summary-address eigrp 90 3.3.2.0 255.255.254.0 汇总配置完成后，在汇总设备上将自动产生指向汇总地址的空接口防环路由 被动接口–只接收不发送路由协议信息 ​ 用于连接用户的接口，不能用于连接邻居的接口 r3(config)#router eigrp 90 r3(config-router)#passive-interface loopback 0 加快收敛 hello 5s hold time15s r3(config)#interface s1/1 r3(config-if)#ip hello-interval eigrp 90 5 r3(config-if)#ip hold-time eigrp 90 15 缺省路由—在边界路由器上向所有直连内网的接口上进行汇总配置，汇总地址0.0.0.0/0； ​ 但边界路由器需要静态缺省指向ISP r1(config)#interface fastEthernet 0/0 r1(config-if)#ip summary-address eigrp 90 0.0.0.0 0.0.0.0","categories":[{"name":"CCNA","slug":"CCNA","permalink":"http://soliym.top/categories/CCNA/"}],"tags":[{"name":"EIGRP","slug":"EIGRP","permalink":"http://soliym.top/tags/EIGRP/"}]},{"title":"OSPF开放最短路径优先协议简述","slug":"OSPF开放最短路径优先协议简述","date":"2019-09-02T09:12:08.004Z","updated":"2019-09-02T09:12:08.008Z","comments":true,"path":"2019/09/02/OSPF开放最短路径优先协议简述/","link":"","permalink":"http://soliym.top/2019/09/02/OSPF开放最短路径优先协议简述/","excerpt":"一、开放式最短路径优先协议 OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。","text":"一、开放式最短路径优先协议 OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。 OSPFv2用于ipv4网络，OSPFv3用在ipv6网络。可用于大型网络。 二、基本概念链路状态 OSPF路由器收集其所在网络区域上各路由器的连接状态信息，即链路状态信息（Link-State），生成链路状态数据库(Link-State Database)。路由器掌握了该区域上所有路由器的链路状态信息，也就等于了解了整个网络的拓扑状况。OSPF路由器利用“最短路径优先算法(Shortest Path First, SPF)”，独立地计算出到达任意目的地的路由。 区域 OSPF协议引入“分层路由”的概念，将网络分割成一个“主干”连接的一组相互独立的部分，这些相互独立的部分被称为“区域”(Area)，“主干”的部分称为“主干区域”。每个区域就如同一个独立的网络，该区域的OSPF路由器只保存该区域的链路状态。每个路由器的链路状态数据库都可以保持合理的大小，路由计算的时间、报文数量都不会过大。 共有五种区域的主要区别在于它们和外部路由器间的关系： 标准区域: 一个标准区域可以接收链路更新信息和路由总结。 主干区域(传递区域):主干区域是连接各个区域的中心实体。主干区域始终是“区域0”，所有其他的区域都要连接到这个区域上交换路由信息。主干区域拥有标准区域的所有性质。 存根区域（stub Area）：存根区域是不接受自治系统以外的路由信息的区域。如果需要自治系统以外的路由，它使用默认路由0.0.0.0。 完全存根区域：它不接受外部自治系统的路由以及自治系统内其他区域的路由总结。需要发送到区域外的报文则使用默认路由：0.0.0.0。完全存根区域是Cisco自己定义的。 不完全存根区域**(NSAA)**: 它类似于存根区域，但是允许接收以LSA Type 7发送的外部路由信息，并且要把LSA Type 7转换成LSA Type 5。 OSPF中的四种路由器 在OSPF多区域网络中，路由器可以按不同的需要同时成为以下四种路由器中的几种： \\1. 内部路由器：所有端口在同一区域的路由器，维护一个链路状态数据库。 \\2. 主干路由器：具有连接主干区域端口的路由器。 \\3. 区域边界路由器(ABR)：具有连接多区域端口的路由器，一般作为一个区域的出口。ABR为每一个所连接的区域建立链路状态数据库，负责将所连接区域的路由摘要信息发送到主干区域，而主干区域上的ABR则负责将这些信息发送到各个区域。 \\4. 自治域系统边界路由器(ASBR)：至少拥有一个连接外部自治域网络（如非OSPF的网络）端口的路由器，负责将非OSPF网络信息传入OSPF网络。 OSPF路由器之间交换链路状态公告(LSA)信息。OSPF的LSA中包含连接的接口、使用的Metric及其他变量信息。OSPF路由器收集链接状态信息并使用SPF算法来计算到各节点的最短路径。 协议类型 Hello报文，通过周期性地发送来发现和维护邻接关系； ​ 存在router ID—-RID 全网唯一的编号，使用ip地址 DBD(链路状态数据库描述)报文，描述本地路由器保存的LSDB(链路状态数据库)； LSR(LS Request)报文，向邻居请求本地没有的LSA； LSU(LS Update)报文，向邻居发送其请求或更新的LSA； LSAck(LS ACK)报文，收到邻居发送的LSA后发送的确认报文。 OSPF网络类型 根据路由器所连接的物理网络不同，OSPF将网络划分为四种类型：广播多路访问型（Broadcast multiAccess）、非广播多路访问型（None Broadcast MultiAccess，NBMA）、点到点型（Point-to-Point）、点到多点型（Point-to-MultiPoint）。 指派路由器（DR）和备份指派路由器（BDR） 在多路访问网络上可能存在多个路由器，为了避免路由器之间建立完全相邻关系而引起的大量开销，OSPF要求在区域中选举一个DR。每个路由器都与之建立完全相邻关系。DR负责收集所有的链路状态信息，并发布给其他路由器。选举DR的同时也选举出一个BDR，在DR失效的时候，BDR担负起DR的职责。 点对点型网络不需要DR，因为只存在两个节点，彼此间完全相邻。 协议组成OSPF协议由Hello协议、交换协议、扩散协议组成。 当路由器开启一个端口的OSPF路由时，将会从这个端口发出一个Hello报文，以后它也将以一定的间隔周期性地发送Hello报文。OSPF路由器用Hello报文来初始化新的相邻关系以及确认相邻的路由器邻居之间的通信状态。 对广播型网络和非广播型多路访问网络，路由器使用Hello协议选举出一个DR。在广播型网络里，Hello报文使用多播地址224.0.0.5周期性广播，并通过这个过程自动发现路由器邻居。在MA网络中，DR负责向其他路由器逐一发送Hello报文。 三、工作原理一般用于同一个路由域内。在这里，路由域是指一个自治系统（Autonomous System），即AS，它是指一组通过统一的路由政策或路由协议互相交换路由信息的网络。在这个AS中，所有的OSPF路由器都维护一个相同的描述这个AS结构的数据库，该数据库中存放的是路由域中相应链路的状态信息，OSPF路由器正是通过这个数据库计算出其OSPF路由表的。 四、工作工程1、数据包5种基本数据包 HELLO—邻居的发现、建立、保活 DBD—–数据库描述包—数据库目录信息 LSR—–链路状态请求 LSU—–链路状态更新—携带各种LSA LSACK—链路状态确认 2、OSPF的状态机–描述接口状态Down：本地一旦发出hello包，进入下一状态 Init–初始化：本地接收到的hello包中若存在本地的RID，进入下一状态 2way–双向通信：邻居关系建立的标志 条件匹配：点到点网络直接进入下一个状态；MA网络将进行DR/BDR选举（40s），非DR/BDR间不能进入下一个状态； Exstart–预启动：使用类hello的BDB包进行主从关系选举，RID数值大为主，主从优先进入下一个状态。 Exchange–准交换：使用真正的BDB进行数据库目录的共享，需要ACK； LOding–加载：使用LSR/LSU/LSack来获取未知的LSA信息； Full–转发：邻接关系建立的标志； 3、工作过程1、启动配置完成后，本地收发hello包，建立邻居关系，生成邻居表； 2、再进行条件的匹配，匹配失败将停留于邻居关系，仅hello包保活即可； 3、匹配成功者之间建立邻接关系，需要DBD共享数据库目录，LSR/LSU/LSack来获取未知的LSA信息，当收集完网络中所有的LSA后，生成数据表–LSDB 4、LSDB建立完成后，本地基于OSPF选路规则，计算本地到达所有未知网段的最短路径，然后将其加载到路由表中，完成收敛。 5、收敛完成后–hello包周期保活–30分钟周期的BDB比对，若不一致将会使用LSR/LSU/LSack重新获取 4、配置配置 R1(config)#router ospf 100 创建/进入OSPF进程100 R1(config-router)#router-id 1.1.1.1 指定Router-id，不指定则为环回地址，没有环回则为物理接 口地址 R1(config-router)#network 12.1.1.1 0.0.0.0 area 0 可在接口内配置，IP ospd 100 area 0 ​ 1、路由 2、激活 3、区域 OSPF三种表 邻居表 R2#show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 1.1.1.1 1 FULL/DR 00:00:39 12.1.1.1 FastEthernet1/0 拓扑表 R2#show ip ospf database ​ OSPF Router with ID (2.2.2.2) (Process ID 100) ​ Router Link States (Area 0) Link ID ADV Router Age Seq# Checksum Link count 1.1.1.1 1.1.1.1 90 0x80000005 0x00BF34 2 2.2.2.2 2.2.2.2 458 0x80000003 0x00BA04 3 ​ Net Link States (Area 0) Link ID ADV Router Age Seq# Checksum 12.1.1.1 1.1.1.1 470 0x80000001 0x004AD0 路由表 R2#show ip ospf route ​ OSPF Router with ID (2.2.2.2) (Process ID 100) ​ Area BACKBONE(0) ​ Intra-area Route List * 12.1.1.0/24, Intra, cost 1, area 0, Connected ​ via 12.1.1.2, FastEthernet1/0 * 23.1.1.0/24, Intra, cost 1, area 0, Connected ​ via 23.1.1.2, FastEthernet1/1 *&gt; 1.1.1.1/32, Intra, cost 2, area 0 ​ via 12.1.1.1, FastEthernet1/0 * 2.2.2.2/32, Intra, cost 1, area 0, Connected ​ via 2.2.2.2, Loopback0 R2#show ip route ospf ​ 1.0.0.0/32 is subnetted, 1 subnets O 1.1.1.1 [110/2] via 12.1.1.1, 00:01:50, FastEthernet1/0 区域划分的规则： 星型结构 其他区域要和骨干域相连 需要存在ABR 区域边界路由器 ​ 通告者 内容 1类LSA router 路由器本身 链路状态 2类LSA network DR 描述MA网络 3类LSA sumary ABR 路由条目 成为邻接关系的条件 1、如果在串行链路上 直接形成邻接关系 2、如果是以太网环境 只和DR/BDR形成邻接关系 选举规则 先比较优先级 越大越优先 比较Router-ID 越大越优先 非抢占性 修改优先级 R1(config)#int f0/0 R1(config-if)#ip ospf priority 2 干涉选择方法： 修改DR优先级最大，BDR次大；该选举非抢占，故必须手动重启所有设备进程 R2#clear ip ospf process Reset ALL OSPF processes? [no]: y 修改DR优先级最大，BDR次大；将其他路由器修改为0 扩展配置： 认证 明文认证： R2(config)#int s1/0 R2(config-if)#ip ospf authentication R2(config-if)#ip ospf authentication-key 1 cisco 密文认证： R2(config)#int f0/0 R2(config-if)#ip ospf authentication message-digest R2(config-if)#ip ospf message-digest-key 1 md5 cisco 区域明文认证： R3(config)#router ospf 100 R3(config-router)#area 0 authentication 区域密文认证： R1(config)#router ospf 100 R1(config-router)#area 1 authentication message-digest 被动接口 R1(config)#router ospf 100 R1(config-router)#passive-interface loopback 0 加快收敛速度 R1(config)#int s1/1 R1(config-if)#ip ospf hello-interval 5 修改hello时间为5s dead time自动四倍关系 R1(config-if)#ip ospf dead-interval 20 链路两端必须一致 缺省路由 R1(config)#router ospf 100 R1(config-router)#default-information originate 需要有缺省路由指向ISP R1(config)#ip route 0.0.0.0 0.0.0.0 loopback 10 强制下放缺省 R1(config)#router ospf 100 R1(config-router)#default-information originate always","categories":[{"name":"CCNA","slug":"CCNA","permalink":"http://soliym.top/categories/CCNA/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://soliym.top/tags/OSPF/"}]},{"title":"RIP路由信息简述","slug":"RIP路由信息简述","date":"2019-09-02T09:05:26.249Z","updated":"2019-09-02T09:12:33.464Z","comments":true,"path":"2019/09/02/RIP路由信息简述/","link":"","permalink":"http://soliym.top/2019/09/02/RIP路由信息简述/","excerpt":"RIP：路由信息协议","text":"RIP：路由信息协议 1. 定义：路由信息协议（英语：Routing Information Protocol，缩写：RIP）是一种内部网关协议（IGP），为最早出现的距离向量路由协议。属于网络层，可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等。 RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议， RIP协议要求网络中每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。RIP协议将“距离”定义为：从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为每经过一个路由器则距离加1。“距离”也称为“跳数”。RIP允许一条路径最多只能包含15个路由器，因此，距离等于16时即为不可达。可见 RIP协议只适用于小型互联网，并不适用于复杂网络的情况。 2. 特点：（1）仅和相邻的路由器交换信息。如果两个路由器之间的通信不经过另外一个路由器，那么这两个路由器是相邻的。RIP协议规定，不相邻的路由器之间不交换信息。 （2）路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。 （3）按固定时间交换路由信息，如，每隔30秒，然后路由器根据收到的路由信息更新路由表。（也可进行相应配置使其触发更新） 3.版本：（1）版本​ RIPv1:使用有类路由，在它的路由更新(Routing Updates)中并不带有子网的资讯，因此它无法支援可变长度子网掩码。这个限制造成在RIPv1的网络中，在同级网络下无法使用不同的子网掩码。换句话说，在同一个网络下所有的子网络数目都是相同的。另外，它也不支援对路由过程时的认证，使得RIPv1有一些轻微的弱点，有机会遭受到可能的攻击。 ​ RIPv2：因为RIPv1的缺陷，RIPv2在1994年被提出，与RIP1最大的不同是RIP2为一个无类别路由协议，其更新消息中携带子网掩码，它支持VLSM、CIDR、认证和多播。另外针对安全性的问题，RIPv2也提供一套方法，未透过加密来达到认证的效果。而之后[RFC 2082]也定义了利用MD5来达到认证的方法。 ​ RIPng：主要是针对IPv6做一些延伸的规范。与RIPv2相比下其最主要的差异是：RIPv2支援RIP更新认证, RIPng 则不支持，因为IPv6路由器理应会使用IPsec来进行身份验证；RIPv2 容许给路由器附上任何标签， RIPng 则不容许； RIPv2 在每个路由表项中都保存下一跳的信息，RIPng是对一组路由表项指定下一跳信息；RIPv2 使用UDP端口520和多播地址224.0.0.9通信，RIPng 则使用UDP端口521和多播地址FF02::9通信。 （2）总结RIPv1和RIPv2的区别1.RIPv1是有类路由协议（不携带掩码），RIPv2是无类路由协议（携带掩码） 2.RIPv1不能支持VLSM，RIPv2可以支持VLSM 3.RIPv1没有认证的功能，RIPv2可以支持认证，并且有明文和MD5两种认证 4.RIPv1没有手工汇总的功能，RIPv2可以在关闭自动汇总的前提下，进行手工汇总 5.RIPv1是广播更新，RIPv2是组播更新， 6.RIPv1对路由没有标记的功能，RIPv2可以对路由打标记（tag），用于过滤和做策略 7.RIPv1发送的updata最多可以携带25条路由条目，RIPv2在有认证的情况下最多只能携带24条路由 8.RIPv1发送的updata包里面没有next-hop属性，RIPv2有next-hop属性，可以用与路由更新的重定 4. 工作原理：​ （1）初始化——RIP[1]初始化时，会从每个参与工作的接口上发送请求数据包。该请求数据包会向所有的RIP路由器请求一份完整的路由表。该请求通过LAN上的广播形式发送LAN或者在点到点链路发送到下一跳地址来完成。这是一个特殊的请求，向相邻设备请求完整的路由更新。 ​ （2）接收请求——RIP有两种类型的消息，响应和接收消息。请求数据包中的每个路由条目都会被处理，从而为路由建立度量以及路径。RIP采用跳数度量，值为1的意为着一个直连的网络，16，为网络不可达。路由器会把整个路由表作为接收消息的应答返回。 ​ （3）接收到响应——路由器接收并处理响应，它会通过对路由表项进行添加，删除或者修改作出更新。 ​ （4）常规路由更新和定时——路由器以30秒一次地将整个路由表以应答消息地形式发送到邻居路由器。路由器收到新路由或者现有路由地更新信息时，会设置一个180秒地超时时间。如果180秒没有任何更新信息，路由的跳数设为16。路由器以度量值16宣告该路由，直到刷新计时器从路由表中删除该路由。刷新计时器的时间设为240秒，或者比过期计时器时间多60秒。Cisco还用了第三个计时器，称为抑制计时器。接收到一个度量更高的路由之后的180秒时间就是抑制计时器的时间，在此期间，路由器不会用它接收到的新信息对路由表进行更新，这样能够为网路的收敛提供一段额外的时间。 ​ （5）触发路由更新——当某个路由度量发生改变时，路由器只发送与改变有关的路由，并不发送完整的路由表。 5. RIP防环机制5.1 记数最大值（maximum hop count）：定义最大跳数（最大为15跳），当跳数为16跳时,目标为不可达。 5.2 水平分割（split horizon）：从一个接口学习到的路由不会再广播回该接口。 5.3 毒性逆转水平分割（poison reverse）：从一个接口学习的路由会发送回该接口，但是已经被毒化，跳数设置为16跳，不可达。 5.4 触发更新（trigger update）：一旦检测到路由崩溃，立即广播路由刷新报文，而不等到下一刷新周期。 5.5 抑制计时器（holddown timer）：防止路由表频繁翻动，增加了网络的稳定性。 6. RIP路由更新机制RIP协议有两种更新机制：一是定期更新，二是触发更新。“定期更新”是根据设置的更新计时器定期发送RIP路由通告。该通告报文中携带了除“水平分割”机制抑制的RIP路由之外本地路由器中的所有RIP路由信息。而“触发更新”则是RIP路由器仅在有路由表项发生变化时发送的RIP路由通告，仅携带本地路由表中有变化的路由信息。RIP路由器一旦察觉到网络变化，就尽快甚至是立即发送更新报文，而不等待更新周期结束。只要触发更新的速度足够快，就可以大大地防止“计数到无穷大”的发生，但是这一现象还是有可能发生的。 无论是定期更新，还是触发更新，RIP路由的更新规则如下： l 如果更新的某路由表项在路由表中没有，则直接在路由表中添加该路由表项； l 如果路由表中已有相同目的网络的路由表项，且来源端口相同，那么无条件根据最新的路由信息更新其路由表； l 如果路由表中已有相同目的网络的路由表项，但来源端口不同，则要比较它们的度量值，将度量值较小的一个作为自己的路由表项； l 如果路由表中已有相同目的网络的路由表项，且度量值相等，保留原来的路由表项。 7、Rip基础配置1）RIPV1 r1(config)#router rip 启动协议 r1(config-router)#version 1 选择版本1，若不进行版本选举，默认为升级版本1； r1(config-router)#network 1.0.0.0 主类地址—-RIP在宣告时，只能定义主类的范围 clear ip route * 刷新路由表 2）RIPV2 r1(config)#router rip r1(config-router)#version 2选择版本2 r1(config-router)#no auto-summary 关闭自动汇总； r1(config-router)#network 12.0.0.0 8、RIP扩展配置1、RIPV2的认证​ 运行了RIP协议的邻居间，进行身份的核实 先定制key，再在同邻居直连的接口上调用 指令： r1(config)#key chain xxx r1(config-keychain)#key 1 r1(config-keychain-key)#key-string cisco123 邻居间必须一致 r1(config)#interface s1/1 r1(config-if)#ip rip authentication key-chain xxx r1(config-if)#ip rip authentication mode md5 模式也必须一致 2、RIPV2的手工汇总在更新源路由器上向所有更新发出的接口上配置 r2(config)#interface s1/0 r2(config-if)#ip summary-address rip 2.2.2.0 255.255.254.0 如果在接口中汇总多个路由，则选择掩码短的 3、被动接口仅接收不发送路由协议信息；只能用于连接用户的接口，不得用于连接邻居的接口 r1(config)#router rip r1(config-router)#passive-interface loopback 0 4、加快收敛RIP计时器 30s 更新 180s失效 180s抑制 240s刷新 ​ 适当的修改计时器，可以加快设备的收敛速度 ​ 建议修改时维持原有的倍数关系，且不易修改的过小；全网所有设备均修改 r1(config)#router rip r1(config-router)#timers basic 15 90 90 120 5、缺省路由在边界路由器上配置RIP缺省后，内部的路由器将自动生成缺省路由指向边界路由器；边界路由器到达ISP的缺省路由，宣告手工静态配置 r3(config)#router rip r3(config-router)#default-information originate","categories":[{"name":"CCNA","slug":"CCNA","permalink":"http://soliym.top/categories/CCNA/"}],"tags":[]},{"title":"DHCP工作原理","slug":"DHCP工作原理","date":"2019-09-02T04:12:03.755Z","updated":"2019-09-02T04:23:42.076Z","comments":true,"path":"2019/09/02/DHCP工作原理/","link":"","permalink":"http://soliym.top/2019/09/02/DHCP工作原理/","excerpt":"DHCP 全称Dynamic Host configuration protocol， 动态主机配置协议。 它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数，","text":"DHCP 全称Dynamic Host configuration protocol， 动态主机配置协议。 它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数， 一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上(UDP头，IP头、链路层头)也有一些差别​ 1）DHCP DiscoverDHCP客户端请求地址时，并不知道DHCP服务器的位置，因此DHCP客户端会在本地网络内以广播方式发送请求报文，这个报文成为Discover报文，目的是发现网络中的DHCP服务器，所有收到Discover报文的DHCP服务器都会发送回应报文，DHCP客户端据此可以知道网络中存在的DHCP服务器的位置。 2）DHCP OfferDHCP服务器收到Discover报文后，就会在所配置的地址池中查找一个合适的IP地址，加上相应的租约期限和其他配置信息(如网关、DNS服务器等)，构造一个Offer报文，发送给用户(可以广播、也可以单播)，告知用户本服务器可以为其提供IP地址。(注意，只是告诉client可以提供，是预分配，还需要client通过ARP检测该IP是否重复) 3）DHCP Request客户端会在两种情况下发送DHCP Request a）DHCP客户端可能会收到来自DHCP服务器的很多Offer，所以必须在这些回应中选择一个。Client通常选择第一个回应Offer报文的服务器作为自己的目标服务器，并回应一个广播Request报文，通告选择的服务器。注意，”Client通常选择第一个回应Offer报文的服务器作为自己的目标服务器”这里存在一个安全问题，如果我们的伪DHCP服务器能比原始DHCP服务器先发送Offer数据包，就能达到欺骗的目的，从而劫持目标用户的流量 b）获取DHCP客户端成功获取IP地址后，在地址使用租期过去1/2时，会向DHCP服务器发送单播Request报文续延租期，如果没有收到DHCP ACK报文，在租期过去3/4时，会再次发送广播Request报文续延租期。 4）DHCP ACKDHCP服务器收到Request报文后，根据Request报文中携带的用户MAC来查找有没有相应的租约记录(即之前的预分配过程中登记的那个MAC)，如果有则发送ACK报文作为回应，通知用户可以使用分配的IP地址。 5） DHCP NAK如果DHCP服务器收到Request报文后，没有发现有相应的租约记录或者由于某些原因无法正常分配IP地址，则发送NAK报文作为回应，通知用户无法分配合适的IP地址。 6）DHCP Release当用户不再需要使用分配IP地址时，就会”主动”向DHCP服务器发送Release报文，告知服务器用户不再需要分配IP地址，DHCP服务器会释放被绑定的租约(在数据库中清除某个MAC对某个IP的租约记录，这样，这个IP就可以分配给下一个请求租约的MAC) \\7. DHCP DeclineDHCP客户端收到DHCP服务器回应的ACK报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送Decline报文，通知服务器所分配的IP地址不可用，我们在手工设置静态IP、或者DHCP分配中有时会遇到”检测到IP冲突”的提示就是因为客户端利用ARP机制来在当前内网中确认当前指定的IP是否已经被占用 8）DHCP InformDHCP客户端如果需要从DHCP服务器端获取更为详细的配置信息，则发送Inform报文向服务器进行请求，服务器收到该报文后，将根据租约进行查找，找到相应的配置信息后，发送ACK报文回应DHCP客户端。 二、DHCP协议的本质DHCP使用UDP进行报文的传输。在主机DHCP获得地址之前，主机并没有有效的IP地址，它是通过受限广播IP地址（全1），当该地址作为目的地址时，子网内的所有主机都能收到该IP数据报。IP层的广播实际上是基于链路层的广播来实现的，所以这里有个前提，即链路层具有广播功能，在以太网中，目的地址为全1的MAC地址可作为链路上的广播地址。只要数据包能够正确到达主机IP层UDP的端口上，则应用程序就能收到该端口上的广播IP包，这正是DHCP设备能正确获得IP地址的本质。 DHCP客户端使用固定端口号68，而服务器使用固定端口号67。 DHCP由三种机制分配IP地址： 1.自动分配方式：DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器租用到IP地址，就可以永久使用该地址。 2.动态分配方式：DHCP服务器给主机指定一个有时间限制的IP地址， 时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。 3.手工分配方式：客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。 三种地址分配方式中， 只有动态分配方式可以重复使用客户端不再需要的地址 三、DHCP工作流程 1、客户端以广播的方式发送DHCP_DISCOVER报文，广播的范围的服务器都能接收到该报文。 2、所有的DHCP服务器都会对该报文进行响应，向DHCP客户端发送DHCP_OFFER报文，报文中的 Your（Client）IP Address字段携带了分配给客户端的IP地址，同时服务器的IP地址放在报文中的option字段中以便客户端可以区分，服务器分配后IP地址给客户端后，会把该地址分配记录下来。 3、DHCP客户端可能收到多个服务器的DHCP_OFFER报文，但是它只能对其中的一个做响应，通常DHCP客户端处理最先收到的DHCP_OFFER报文并响应。 4、DHCP客户端从DHCP_OFFER报文中提取可使用的IP地址和服务器IP地址后，会发出个广播的DHCP_REQUST报文，并在选项字段中加入选中的DHCP服务器的IP地址和自己要的IP地址。 5、DHCP服务器收到DHCP_REQUST报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP服务器不做任何处理，然后清除相应IP地址分配记录；如果相同，DHCP服务器就会向客户端发送一个DHCP_ACK报文，并在报文选项字段中增加IP地址的使用租期信息。 6、DHCP客户端接收到DHCP_ACK报文后，会检查服务器分配的IP地址是否能够使用（发送一个ARP请求到网络中，如果无主机回应该请求，则表示该地址可用）。如果可以使用，则客户端成功获得IP地址会根据IP地址使用租期自动启动续延过程；如果DHCP客户端发现分配的IP地址已经被使用，则需要向DHCP服务器发出一个DHCP_DECLINE报文，通知DHCP服务器禁用这个IP地址，此后，DHCP客户端重新开始上述地址申请流程。 7、客户端在使用租期超过50%或87.5%时，会以广播播形式向DHCP服务器发送DHCP_REQUST报文来续租IP地址。如果DHCP客户端成功收到服务器返回的DHCP_ACK报文，则按相应时间延长IP地址租期；如果没有收到服务器返回的的DHCP_ACK报文，则DHCP 客户端继续使用这个IP地址，直到IP地址使用租期到期。当租期到期后，DHCP客户端会向DHCP服务器发送一个DHCP_RELEASE报文来释放这个IP地址，并开始新的IP地址申请过程。 8、最后需要指出的是，DHCP服务器发送的DHCP_OFFER报文中的IP地址不一定是最后分配给客户端的IP地址，通常情况下，DHCP服务器会保留该地址直到客户端发出DHCP_REQUEST请求。在整个协商过程中，如果DHCP客户端发送的DHCP_REQUEST报文中的地址信息不正确，如客户端已经迁移到新的子网或者租约已经过期，DHCP服务器会发送DHCP_NAK报文给DHCP客户端，让客户端重新发起地址申请过程。 四、配置DHCP配置： R1(config)#ip dhcp pool ccna(dhcp服务器名称） R1(dhcp-config)#network 172.16.1.0 255.255.255.0 R1(dhcp-config)#default-router 172.16.1.1 R1(dhcp-config)#dns-server 8.8.8.8 排除地址： 排除单个地址 R1(config)#ip dhcp excluded-address 172.16.1.254 排除一段地址 R1(config)#ip dhcp excluded-address 172.16.1.100 172.16.1.200 ​ 起始地址 结束地址","categories":[{"name":"CCNA","slug":"CCNA","permalink":"http://soliym.top/categories/CCNA/"}],"tags":[{"name":"DHCP","slug":"DHCP","permalink":"http://soliym.top/tags/DHCP/"}]},{"title":"RHCSA-Linux基础命令（一）","slug":"RHCSA-Linux基础命令（一）","date":"2019-06-17T11:21:08.791Z","updated":"2019-12-24T08:45:13.855Z","comments":true,"path":"2019/06/17/RHCSA-Linux基础命令（一）/","link":"","permalink":"http://soliym.top/2019/06/17/RHCSA-Linux基础命令（一）/","excerpt":">Linux的基本原则1、由目的单一的小程序组成 2、一切皆文件，设备的访问入口也是文件 3、避免捕获用户接口，尽量不和用户交互 4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。","text":">Linux的基本原则1、由目的单一的小程序组成 2、一切皆文件，设备的访问入口也是文件 3、避免捕获用户接口，尽量不和用户交互 4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。 命令格式>命令 >命令 参数 >命令 -选项 >命令 -选项 参数 修改命令的执行特性短选项 -l 多个选项可以组合 长格式 –long ​ 参数 指定命令的作用对象 基础命令重启：reboot 关机：shutdown -h now，poweroff ip a / ifconfig 查看ip地址 dhclient 地址请求，打开网络模式 kill -9 ID 结束相应的进程（命令 -选项 参数） pwd 指出当前工作环境 print workdoing directory su 切换到root用户并不切换环境（工作目录） switch user su - root 切换到root用户并切换环境(切换了工作目录) cd 切换目录 change directroy ​ 绝对路径 从根开始到目标的路径叫绝对路径 ​ 相对路径 相对当前目录开始到目标路径 ​ / 根 ​ ~ 家目录 /root /home/redhat ​ ~ USERNAME(root用户有权限) 直接切换到指定用户的家目录 ​ - 在上一个目录和当前目录来回切换 ​ . 当前目录 ​ .. 上一级目录 passwd 修改密码：passwd 用户名 直接输入passwd修改当前用户的密码 删除密码：passwd -d 用户名 root用户：不需要输入原密码，可以不符合密码复杂性规则，可以给任何人修改密码 普通用户：需要输入原密码，必须符合密码复杂性规则，passwd修改密码无法指定用户 [student@localhost ~]$ su -c passwd普通用户给root用户修改密码","categories":[{"name":"Linux","slug":"Linux","permalink":"http://soliym.top/categories/Linux/"}],"tags":[{"name":"Rhcsa","slug":"Rhcsa","permalink":"http://soliym.top/tags/Rhcsa/"}]},{"title":"RHCSA-Linux简介","slug":"RHCSA-Linux简介","date":"2019-06-17T11:17:36.958Z","updated":"2019-12-24T08:44:54.274Z","comments":true,"path":"2019/06/17/RHCSA-Linux简介/","link":"","permalink":"http://soliym.top/2019/06/17/RHCSA-Linux简介/","excerpt":"操作系统是什么？操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。 操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。","text":"操作系统是什么？操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。 操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。 >&gt;硬件：框架 冯诺依曼体系结构：1946年美籍凶牙利科学家冯诺依曼提出存储程序原理，把程序本身当做数据来对待，程序和该程序处理数据用同样的方式存储，并确定了存储程序计算机的五大组成部分和基本工作方法。 特点： （1）计算机处理数据和指令一律用二进制数表示 （2）顺序执行程序 计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序 从主存储器中取出指令一条一条的执行，这一概念称为顺序执行程序。 （3）计算机硬件由运算器、控制器、存储器、输入设备、输出设备五大部分组成。 memory：编址存储设备 假设我们的存储器为一个长条，其中每八位（bit）作为一个单元，我们把它称为字节byte，字节又称为cell。 机器语言：二进制指令 （但是对于编程 人员来说二进制语言太难懂（太简陋，太底层），但是程序员想用简单点的语言去描述计算机又不懂所以两者之间不能耦合可以加一个中间层–编译器） 汇编语言： 仅是将二进制转为人类语言想接近的语言或者是与人类语言符号相同的类型（+ and/plus） 所以任何一款芯片制造商他们都把机器的代码也就是机器语言提供一个较为简单的稍微向上一点的但任然很简陋的编程接口叫做汇编语言（微码编程语言） 软件：​ —-汇编语言： （低级语言） ​ 应用：驱动程序 汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。 ​ eg：操作：寄存器BX的内容送到AX中 ​ 1000100111011000 机器指令 ​ mov ax,bx 汇编指令 （注意：最终识别的还是01二进制数所以还需要将汇编语言转换为二进语言所以需要用到汇编器） ​ —-(高级语言)：比较接近人类的思维逻辑 —-(编译器) ​ 系统级： c c++ ​ 适用场合大型的对性能要求比较高的服务类程序 如：oracle mysql linux windows / ​ 应用级：java python ruby 系统调用的层级关系(系统组成结构) 操作系统内核的功能：系统调用接口 程序管理 内存管理，虚拟内存—内存交换 文件系统管理 设备驱动","categories":[{"name":"Linux","slug":"Linux","permalink":"http://soliym.top/categories/Linux/"}],"tags":[{"name":"Rhcsa","slug":"Rhcsa","permalink":"http://soliym.top/tags/Rhcsa/"}]},{"title":"c关于堆栈的划定","slug":"c关于堆栈的划定","date":"2019-05-14T13:41:59.467Z","updated":"2019-05-14T13:51:36.365Z","comments":true,"path":"2019/05/14/c关于堆栈的划定/","link":"","permalink":"http://soliym.top/2019/05/14/c关于堆栈的划定/","excerpt":"c语言 全局变量与局部变量的划分在做背包问题的时候遇到这样的问题，定义一个二维数组变量，该变量的大小为1000*1000，但是在运行时报错，显示“Stack overflow ”，说明在此处超过了栈的空间。","text":"c语言 全局变量与局部变量的划分在做背包问题的时候遇到这样的问题，定义一个二维数组变量，该变量的大小为1000*1000，但是在运行时报错，显示“Stack overflow ”，说明在此处超过了栈的空间。 c/c++内存分配栈区(stack sagment)由编译器自动分配释放，存放函数的参数的值，局部变量的值等。在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M(也有的是1M，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆区(heap sagment) 一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收 。它与数据结构中的堆是两回事。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 全局区(静态区)(data sagment)全局变量和静态变量的存储区域是在一起的，程序结束后由系统释放。数据区的大小由系统限定，一般很大。 因为栈区的大小是编译器分配好的，如果变量的空间过大就会有栈的溢出问题，因此变量的类型是局部变量还是全局变量要根据变量大小选择，一版来说只有用到数组要考虑溢出问题，比如long、double都是固定长度大小的。如果数组的大小大于1000*1000就要考虑溢出问题，而全局变量的大小是有系统规定的，一般都很大。全局变量大小可达G以上。","categories":[{"name":"c语言","slug":"c语言","permalink":"http://soliym.top/categories/c语言/"}],"tags":[{"name":"堆栈","slug":"堆栈","permalink":"http://soliym.top/tags/堆栈/"}]},{"title":"2n皇后","slug":"2n皇后","date":"2019-04-11T12:37:08.115Z","updated":"2019-04-11T12:39:37.505Z","comments":true,"path":"2019/04/11/2n皇后/","link":"","permalink":"http://soliym.top/2019/04/11/2n皇后/","excerpt":"问题描述问题描述给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。","text":"问题描述问题描述给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 输入格式 输入的第一行为一个整数n，表示棋盘的大小。 接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 输出格式 输出一个整数，表示总共有多少种放法。 样例输入41 1 1 11 1 1 11 1 1 11 1 1 1 样例输出 2 样例输入 41 0 1 11 1 1 11 1 1 11 1 1 1 样例输出 0 问题分析2n皇后问题是在n皇后的问题上扩展而来，涉及搜索、模拟、n皇后问题，要解决2n皇后问题先要解决n皇后问题，n皇后在前面已经写了，现在来解决2n皇后的问题。 2n皇后实际是在在棋盘上先放一种皇后，然后再放另一种皇后，已经放过皇后的位置就不能再放皇后，所以首先记录白皇后的位置，然后再放黑皇后，需要一个二维数组来模拟棋盘，初始时，这个棋盘上是0或1，0表示不可以放皇后，1表示可以放皇后的，在开始放白皇后的时候，如果白皇后可以在棋盘上放置，那么记录该位置，将该位置标记为2，代表放置的是白皇后，当所有的白皇后放置完以后，计数器现在为n代表白皇后放置完，然后放置黑皇后，放置黑皇后时，如果放置位置是2那么，则代表位置是白皇后，那么该位置不能再放置黑皇后。按照放置白皇后的方法放置黑皇后。放置方法仍然采用回溯法。 算法设计放置位置检查是否合适一种皇后算法1234567891011bool check(int x,int y)//皇后的放置位置是否合适&#123;//x为行，y为列 int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) //判断是否在同一列或同斜行 return false; &#125; return true;&#125; 两种皇后算法12345678910bool check(int x, int y,int s)//x为行，y为列&#123; int i; for (i = 0; i &lt; x; i++) &#123; if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i]))) return false; &#125; return true;&#125; 在放置一种的基础上添加标志，当s==2时表示放置白皇后，所用到的是a数组，当s==3时，表示放置黑皇后，所用到的是c数组。a数组用来记录白皇后在各行的位置。c数组表示黑皇后在各行的位置。 回溯算法一种皇后回溯1234567891011121314151617void king(int k)&#123; int i; if(k==n)//如果n皇后符合位置，合法方案加一 &#123; count++;//合法方案计数 return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/ &#123; a[k]=i; king(k+1); &#125; &#125;&#125; 两种皇后回溯123456789101112131415161718192021void king(int k,int s)&#123; int i; if (k == n) &#123; if (s==2)king(0, 3);//s==3时放置黑皇后 else count++;//如果白皇后和黑皇后都等于n则计数器加一 return; &#125; for (i = 0; i &lt; n; i++) &#123; if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s))//与放置一种相比，增加两种条件，所放位置上不能等0或不能等2 &#123; s==2?a[k] = i:c[k] = i; b[k][i] = s;//记录白皇后、黑皇后的位置 king(k + 1,s);//第一行放置完，开始第二行 b[k][i] = 1;//还原棋盘 &#125; &#125;&#125; 源代码编译器vs2017 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n ;int count = 0;int a[10];int c[10];int b[10][10];bool check(int x, int y,int s)&#123; int i; for (i = 0; i &lt; x; i++) &#123; if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i]))) return false; &#125; return true;&#125;void king(int k,int s)&#123; int i; if (k == n) &#123; if (s==2)king(0, 3); else count++; return; &#125; for (i = 0; i &lt; n; i++) &#123; if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s)) &#123; s==2?a[k] = i:c[k] = i; b[k][i] = s; king(k + 1,s); b[k][i] = 1; &#125; &#125;&#125;int main(void)&#123; int i, j; scanf_s(\"%d\",&amp;n); for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) scanf_s(\"%d\", &amp;b[i][j]); king(0,2); printf(\"%d\", count); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://soliym.top/categories/算法/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://soliym.top/tags/递归/"}]},{"title":"n皇后","slug":"n皇后","date":"2019-04-06T10:10:57.536Z","updated":"2019-04-06T14:34:57.514Z","comments":true,"path":"2019/04/06/n皇后/","link":"","permalink":"http://soliym.top/2019/04/06/n皇后/","excerpt":"问题描述​ n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。","text":"问题描述​ n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。 问题分析​ 如果采用枚举法判断每一种情况，需要枚举n^2的组合数，如果n=8;南无需要枚举54502232次，如果n再增大，需要枚举的次数就太过庞大。所以采用回溯法，尽量减少不必要的循环，当问题达到边界时，返回上一层，不必再浪费资源。如果只考虑每一行放置一个皇后、每一列也只放置一个皇后。从第一行开始放置皇后，当第一行的皇后确定后，结束循环，开始从下一行开始放置皇后，且放置皇后的位置不能与前面的皇后在同一列或同一条对角线。需要一个判断函数，判定在该位置能否放置皇后。如果一行的所有位置都不能放置皇后，那么回溯至上一行。 回溯法按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的。 算法设计皇后位置比较算法1234567891011bool check(int x,int y)//皇后的放置位置是否合适&#123;//x为行，y为列 int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) //判断是否在同一列或同斜行 return false; &#125; return true;&#125; 每一行放一个皇后，就解决了不在同行的问题。 在第i行的时候，遍历n列，试探位置。和之前所有行放的位置进行比较。 比较列：当前列col 不等于 之前 所有列。 即col != arr[i]。 比较斜线， 因为不再同一斜率为1或者-1的斜线。(row - i) / (col - arr[i]) != 1 或 -1 可以取巧用绝对值函数: abs(row-i) != abs(col-arr[i])。回溯算法 1234567891011121314151617void king(int k)&#123; int i; if(k==n)//如果n皇后符合位置，合法方案加一 &#123; count++;//合法方案计数 return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/ &#123; a[k]=i; king(k+1); &#125; &#125;&#125; 回溯每行放置一个皇后，记录每个皇后所在的列数，如果递归后的结果不符合，则回退至该位置，从该位置继续遍历。回溯的条件有两种，一种是在一行中没有找到适合放置皇后的位置，另一种是符合放置方案，然后回溯，寻找下一个方案。 源代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n=8;int count=0;int a[10];bool check(int x,int y)&#123; int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) return false; &#125; return true;&#125;void king(int k)&#123; int i; if(k==n) &#123; count++; return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i)) &#123; a[k]=i; king(k+1); &#125; &#125;&#125;int main(void)&#123; king(0); printf(\"%d\",count); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://soliym.top/categories/算法/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://soliym.top/tags/递归/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2019-03-30T06:59:22.507Z","updated":"2019-03-30T07:03:58.902Z","comments":true,"path":"2019/03/30/贪心算法/","link":"","permalink":"http://soliym.top/2019/03/30/贪心算法/","excerpt":"贪心算法概述：贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。 注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。","text":"贪心算法概述：贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。 注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。 完美的代价问题描述 回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 交换的定义是：交换两个相邻的字符 例如mamad 第一次交换 ad : mamda 第二次交换 md : madma 第三次交换 ma : madam (回文！完美！) 输入格式 第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000) 第二行是一个字符串，长度为N.只包含小写字母 输出格式 如果可能，输出最少的交换次数。 否则输出Impossible 样例输入 5mamad 样例输出 3 问题分析​ 在输入的字符串中不匹配的字母可能是一个或零，所以可以先找出这个字母，创建一个包含26个空间是数组，分别表示字符串中字母的个数，然后遍历这个数组，如果字母的个数为奇数，则表示该字母为不匹配字母。首先从首字母开始，找到与它匹配的字符，再将它与最后一个字母交换，这样一对匹配的字母就交换完了，如果遇到不匹配的字母，则将它与中间的字母交换，然后在开始遍历。但是问题要求的是相邻的交换，所以这种方法不符合要求。 ​ 我们需要相邻交换，所以要找到交换的起点和终点。求解方法和上面类似，先从首字母开始，在从与字符串的另一方向开始，遍历找到与首字母匹配的字母，记录它的位置，从该位置起，将后一个字母向前一个位置移动，直到与最后，记录交换次数，再将首字母元素赋值给最后一个元素，这样一趟交换完成。 全局循环次数：1 to n/2; 每次循环需判断是否为不匹配元素 匹配元素循环次数：n-i-1 to j(当字母为匹配字母时) 匹配元素移动次数：j to n-i-1 不匹配元素循环次数：i to j(当字母为匹配字母时) 不匹配元素移动次数：j to i 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;int count=0;//交换次数 void hunwen(char x,int y,char *z)&#123; int i,j,k; for(i=0;i&lt;y/2;i++) &#123; if(z[i]!=x) &#123;//匹配字母情况 j=y-i-1; while(j!=i&amp;&amp;(z[j]!=z[i]))j--; for(k=j;k&lt;y-i-1;k++) &#123; z[k]=z[k+1]; count++; &#125; z[k]=z[i]; &#125; else &#123;//不匹配字母情况 j=i; while(j!=y-i-1&amp;&amp;(z[j]!=z[y-i-1])) j++; for(k=j;k&gt;i;k--) &#123; z[k]=z[k-1]; count++; &#125; z[k]=z[y-i-1]; &#125; &#125;&#125;int main(void)&#123; int n; int i,j=0; char w;//记录不匹配字符 int b[26]=&#123;0&#125;; char a[801]; scanf(\"%d\",&amp;n); getchar();//清除缓存 for(i=0;i&lt;n;i++) scanf(\"%c\",&amp;a[i]); for(i=0;i&lt;n;i++) b[a[i]-97]++; //对字母个数计数 for(i=0;i&lt;26;i++) &#123; if(b[i]%2!=0) &#123; w=i+97; j++; &#125;//遍历找到不匹配字母 &#125; if(j&gt;=2)printf(\"impossible\"); else &#123; hunwen(w,n,a);//交换函数 printf(\"%d\",count);&#125; return 0; &#125; 每一次循环都使字符串两边的字母匹配，达到局部最优的方案，贪心算法没有固定的算法模式，只有固定的算法思想：局部最优，从而全局最优。","categories":[{"name":"算法","slug":"算法","permalink":"http://soliym.top/categories/算法/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://soliym.top/tags/贪心/"}]},{"title":"建站分享","slug":"关于博客的搭建","date":"2018-11-26T14:40:01.936Z","updated":"2019-03-29T15:27:24.299Z","comments":true,"path":"2018/11/26/关于博客的搭建/","link":"","permalink":"http://soliym.top/2018/11/26/关于博客的搭建/","excerpt":"Github Pages + Hexo 我的博客是Github Pages + Hexo在github上搭建的。 下面是我对搭建博客过程中的一些分享","text":"Github Pages + Hexo 我的博客是Github Pages + Hexo在github上搭建的。 下面是我对搭建博客过程中的一些分享 一、 Git、node.js 先下载安装好Git、node.js，具体的过程参照了网上很多的帖子，很多都不是很详细，对于我这种小白来说就是一种折磨（完全看不懂，虽然学了一点前端的HTML、css、js，但这里完全用不上，到是在后面修改主题的时候到是能看明白了。。。。）这些博客里有一个挺详细的，按照他的过程，很容易就弄出来了（其实也不容易。。。。。出现好多问题，当时就很崩溃，明明按照他的步骤完成的，为啥就不通过呢，只能靠着百度一一解决了。。。 这个帖子有点小错误，可能是环境和版本不同的原因吧（我搭建的时候有些地方会出错，需要自己去改） 1http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%B8%80)/ 二、Github 在github上申请免费的空间来搭建网页，以前西部数码上购买过一个虚拟主机，很贵，一年要几百大洋，主要是国内的主要备案很麻烦，后来就放弃了。在github上可以搭建一个简单的静态网页，虽然是静态的，但是也可以加入很多功能，比如评论、分享系统。用来写写博客或作为个人的自我接受很好用。没有繁琐的管理，搭建好以后只管写博客就好。 注册GitHub的时候最好是在chrome浏览器中，因为可以翻译网页，像我这种还没过四级的渣渣，看见这些英文网站就头疼。。。。 具体的注册步骤就不说了，反正我也是看着别人的帖子弄的。。。这个很容易网上就能找到（我忘了我是在按照那个弄的了） 三、hexo配置完hexo本地就算配置完成了，接下来就是将hexo托管到github。 那个_config.yml有两个，一个是在hexo文件夹下的，另一个是在主题文件夹下的，一定要分清楚这两个，后面修改主题配置的时候会对这两个文件进行修改。 到这基础的就弄完了，可以说有个简单的博客就搭建完了，不过这时候页面有点丑（太low而且没啥功能），接下来就是对博客的美化-主题 123hexo g hexo s hexo d 四、主题我使用的是Material X作为博客的主题，想弄的话可以在我们博客的最下面点Material X连接，里面有关于这个主题的修改方法，在最下方有主题的源代码，下载后将文件放在主题文件夹中，上传就Ok了，具体的方法可以百度（有时间是话我会写篇文章来详细说一下我是怎样修改的和遇到的问题） 1https://xaoxuu.com/blog/ 1https://www.wushile.top/ 关于搭建博客 博客搭建花了大概四天多的时间才完成对博客的简单搭建，第一次弄博客，遇到了很多很多的问题，几乎都快要放弃了，但想想已经花费的很多的时间去做这个博客，就该把它弄完，从无到有，很庆幸坚持到了最后，从一无所知的小白到完成搭建这个博客，学到了很多知识，在网上查找解决问题的时候也见识到了很多。很久都没有这么专注的去做一件事情，每天就想着一件事，就想把这个博客建好，现在终于把基础搭建完了，不足的地方以后再去修改，千里之行始于足下。这是第一次写博客，很多格式都不动，写的很low，没办法，这会已经快一点，也没时间去学了，明天还有课。这两周可能不会对博客再进行大的修改了，还有两周考数据结构，没时间去美化了，等考完试再去博客进行修改吧","categories":[{"name":"随笔","slug":"随笔","permalink":"http://soliym.top/categories/随笔/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://soliym.top/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-25T08:55:32.795Z","updated":"2019-03-28T15:00:56.177Z","comments":true,"path":"2018/11/25/hello-world/","link":"","permalink":"http://soliym.top/2018/11/25/hello-world/","excerpt":"hello world","text":"hello world first personalblog1你好，世界！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://soliym.top/categories/随笔/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://soliym.top/tags/hexo/"}]}]}