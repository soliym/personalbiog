{"meta":{"title":"soliym","subtitle":null,"description":null,"author":"soliym","url":"http://soliym.top"},"pages":[{"title":"about","date":"2019-03-29T14:17:54.000Z","updated":"2019-03-29T15:33:26.432Z","comments":true,"path":"about/index.html","permalink":"http://soliym.top/about/index.html","excerpt":"","text":"这个人很懒，不想介绍自己~"},{"title":"categories","date":"2019-03-10T06:21:38.000Z","updated":"2019-03-10T06:24:40.167Z","comments":true,"path":"categories/index.html","permalink":"http://soliym.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-04T03:45:41.000Z","updated":"2019-03-10T06:23:45.878Z","comments":true,"path":"tags/index.html","permalink":"http://soliym.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"EIGRP增强内部网关路由协议简述","slug":"EIGRP增强内部网关路由协议简述","date":"2019-09-02T09:14:50.548Z","updated":"2019-09-02T09:14:50.548Z","comments":true,"path":"2019/09/02/EIGRP增强内部网关路由协议简述/","link":"","permalink":"http://soliym.top/2019/09/02/EIGRP增强内部网关路由协议简述/","excerpt":"EIGRP：增强内部网关路由协议 — cisco私有的协议 无类别距离矢量协议，协议号88；组播更新：224.0.0.10 增量更新—仅触发、无周期更新—–可靠性、更新量小 支持非等开销负载均衡","text":"EIGRP：增强内部网关路由协议 — cisco私有的协议 无类别距离矢量协议，协议号88；组播更新：224.0.0.10 增量更新—仅触发、无周期更新—–可靠性、更新量小 支持非等开销负载均衡 AD 本地下一跳到达目标的度量 FD 本地到达目标的度量 S 最佳路径的下一跳路由器 FS 备份路径的下一跳路由器 FC 可行性条件，成为备份路径的条件 【1】EIGRP的数据包 Hello 包 用于邻居发现、建立、保活 hello time 5s Update包 路由条目–目标网络号+度量值 查询包 查询路径，最佳路径和备份路径—-非等开销负载均衡 应答包 查询确认 ACK 【2】EIGRP的4大组件 组建 Hello机制—-认识所有邻居 PDM —-支持多种网络层协议 （协议有关单元） 协议无关单元 IPX appletalk RTP–可靠传输协议—-借鉴TCP的4种可靠机制–确认、重传、排序、流控（不能超过链路带宽的百分之50） DUAL—扩散更新（弥散更新）算法 【3】EIGRP的工作过程 启动配置后，运行EIGRP协议的路由器，通过组播224.0.0.10向所有的邻居发送hello包；收到邻居的hello包后及表示认识了邻居，生成邻居表； 邻居关系建立后，邻居间使用更新包进行路由信息的共享； 收集到所有的路由条目后，本地生成–拓扑表；—装载所有的最佳和备份路径； 本地默认将拓扑表中的最佳路径全部加载到路由表内；—收敛完成 结构突变： 新增网段—直连新增网段的设备，使用更新包告知所有邻居即可 断开网段—-直连断开网段的设备，发出查询包，通过DUAL，收集应答包来重新收敛 无法沟通—-hello time 5s hold time 15s 更新包、查询包、应答包–均被RTP服务 接收到这三种包时，需要ACK来确认，若未进行确认将单播重传，最大16次，若依然失败断开邻居关系；RTP在转发这三种包时，还会对其进行排序和流控； 【4】EIGRP的配置 r1(config)#router eigrp ? 启动时需要配置AS号 Autonomous system number r1(config)#router eigrp 90 此处理解为全网一致的进程号； r1(config-router)# r1(config-router)#no auto-summary 关闭自动汇总 宣告：激活 路由 r1(config-router)#network 1.0.0.0 r1(config-router)#network 124.1.1.1 0.0.0.0 EIGRP宣告时，可以向rip一样直接配置主类，也可以像OSPF一样使用反掩码进行匹配 启动配置完成后，邻居间使用hello包建立邻居关系，生成邻居表： r2#show ip eigrp neighbors IP-EIGRP neighbors for process 90 H Address Interface Hold Uptime SRTT RTO Q Seq ​ (sec) (ms) Cnt Num 2 124.1.1.4 Fa0/0 10 00:01:59 28 200 0 11 1 23.1.1.2 Se1/1 13 00:02:14 39 234 0 11 0 124.1.1.1 Fa0/0 13 00:02:19 389 2334 0 7 邻居关系建立后，邻居间使用更新包收敛路由信息，生成拓扑表： 本地到达邻居的最佳和备份路径； r3(config)#interface s1/1 r3(config-if)#bandwidth 800 修改接口参考带宽 一个接口的实际传输带宽—-硬件、QOS；参考带宽并不影响实际传输带宽，只影响路由协议的选路； r3#show ip eigrp topology IP-EIGRP Topology Table for AS(90)/ID(3.3.3.3) Codes: P - Passive, A - Active, U - Update, Q - Query, R - Reply, ​ r - reply Status, s - sia Status P 1.1.1.0/24, 1 successors, FD is 2300416 ​ via 23.1.1.1 (2300416/156160), Serial1/0 最佳 ​ via 34.1.1.2 (3842560/156160), Serial1/1 备份 ​ FD AD FD可行距离 —- 本地通过该路径到达目标的度量 AD可行后继距离（通告距离）—-本地的下一跳到达目标的度量值 FC可行条件—-成为备份路径的条件 备份的AD小于不等于最佳路径的FD值 备份路径的意义在于可以和最佳路径一起完成非等开销负载均衡； 非等开销负载均衡：当到达一个目标地址时，若存在两条开销相近的路径时，可以让设备将流量按比例延这些路径同时传输，提高链路的利用率； 差异值：备份的FD/最佳路径的FD=向上取整 设备默认的差异值规定为1，标示仅支持等开销负载均衡 r3#show ip protocols EIGRP maximum metric variance 1 可以通过修改差异值，来实现非等开销负载均衡 r3(config)#router eigrp 90 r3(config-router)#variance 2 r3#show ip route 1.1.1.0 默认设备将最佳路径加载于路由表中： D - EIGRP, EX - EIGRP external 使用字母D标示正常EIGRP学习的路由； 管理距离为90； 度量：复合度量—–各种参数 度量计算公式：存在权重值 Formula with default K values (K1 = 1, K2 = 0, K3 = 1, K4 = 0, K5 = 0): 当K5为0时： Metric = [K1 BW + ((K2 BW) / (256 – load)) + K3 * delay] 当K5大于0时: Metric = [K1 BW + ((K2 BW) / (256 – load)) + K3 delay] [K5 / (reliability + K4)] 带宽 可靠性 延迟 负载 MTU 默认k值下度量计算为带宽+延时： 带宽=（10^7/整路径最小带宽）*256 延时=（整段路径入口的延时之和/10）*256 256为放大因子—-1、放大参数便于比较 2、兼容IGRP 【5】EIGRP的扩展配置 认证 r2(config)#key chain a r2(config-keychain)#key 1 r2(config-keychain-key)#key-string cisco123 r2(config)#interface s1/1 r2(config-if)#ip authentication key-chain eigrp 90 a r2(config-if)#ip authentication mode eigrp 90 md5 注：EIGRP仅支持MD5认证，故在没有修改模式前，认证是无意义的 手工汇总–在更新源路由器上，所有更新发出接口上进行配置 r3(config)#interface s1/0 r3(config-if)#ip summary-address eigrp 90 3.3.2.0 255.255.254.0 汇总配置完成后，在汇总设备上将自动产生指向汇总地址的空接口防环路由 被动接口–只接收不发送路由协议信息 ​ 用于连接用户的接口，不能用于连接邻居的接口 r3(config)#router eigrp 90 r3(config-router)#passive-interface loopback 0 加快收敛 hello 5s hold time15s r3(config)#interface s1/1 r3(config-if)#ip hello-interval eigrp 90 5 r3(config-if)#ip hold-time eigrp 90 15 缺省路由—在边界路由器上向所有直连内网的接口上进行汇总配置，汇总地址0.0.0.0/0； ​ 但边界路由器需要静态缺省指向ISP r1(config)#interface fastEthernet 0/0 r1(config-if)#ip summary-address eigrp 90 0.0.0.0 0.0.0.0","categories":[{"name":"CCNA","slug":"CCNA","permalink":"http://soliym.top/categories/CCNA/"}],"tags":[{"name":"EIGRP","slug":"EIGRP","permalink":"http://soliym.top/tags/EIGRP/"}]},{"title":"OSPF开放最短路径优先协议简述","slug":"OSPF开放最短路径优先协议简述","date":"2019-09-02T09:12:08.004Z","updated":"2019-09-02T09:12:08.008Z","comments":true,"path":"2019/09/02/OSPF开放最短路径优先协议简述/","link":"","permalink":"http://soliym.top/2019/09/02/OSPF开放最短路径优先协议简述/","excerpt":"一、开放式最短路径优先协议 OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。","text":"一、开放式最短路径优先协议 OSPF(Open Shortest Path First)是一个内部网关协议(Interior Gateway Protocol,简称IGP)。与RIP相对，OSPF是链路状态路由协议，而RIP是距离向量路由协议。链路是路由器接口的另一种说法，因此OSPF也称为接口状态路由协议。OSPF通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，每个OSPF路由器使用这些最短路径构造路由表。 OSPFv2用于ipv4网络，OSPFv3用在ipv6网络。可用于大型网络。 二、基本概念链路状态 OSPF路由器收集其所在网络区域上各路由器的连接状态信息，即链路状态信息（Link-State），生成链路状态数据库(Link-State Database)。路由器掌握了该区域上所有路由器的链路状态信息，也就等于了解了整个网络的拓扑状况。OSPF路由器利用“最短路径优先算法(Shortest Path First, SPF)”，独立地计算出到达任意目的地的路由。 区域 OSPF协议引入“分层路由”的概念，将网络分割成一个“主干”连接的一组相互独立的部分，这些相互独立的部分被称为“区域”(Area)，“主干”的部分称为“主干区域”。每个区域就如同一个独立的网络，该区域的OSPF路由器只保存该区域的链路状态。每个路由器的链路状态数据库都可以保持合理的大小，路由计算的时间、报文数量都不会过大。 共有五种区域的主要区别在于它们和外部路由器间的关系： 标准区域: 一个标准区域可以接收链路更新信息和路由总结。 主干区域(传递区域):主干区域是连接各个区域的中心实体。主干区域始终是“区域0”，所有其他的区域都要连接到这个区域上交换路由信息。主干区域拥有标准区域的所有性质。 存根区域（stub Area）：存根区域是不接受自治系统以外的路由信息的区域。如果需要自治系统以外的路由，它使用默认路由0.0.0.0。 完全存根区域：它不接受外部自治系统的路由以及自治系统内其他区域的路由总结。需要发送到区域外的报文则使用默认路由：0.0.0.0。完全存根区域是Cisco自己定义的。 不完全存根区域**(NSAA)**: 它类似于存根区域，但是允许接收以LSA Type 7发送的外部路由信息，并且要把LSA Type 7转换成LSA Type 5。 OSPF中的四种路由器 在OSPF多区域网络中，路由器可以按不同的需要同时成为以下四种路由器中的几种： \\1. 内部路由器：所有端口在同一区域的路由器，维护一个链路状态数据库。 \\2. 主干路由器：具有连接主干区域端口的路由器。 \\3. 区域边界路由器(ABR)：具有连接多区域端口的路由器，一般作为一个区域的出口。ABR为每一个所连接的区域建立链路状态数据库，负责将所连接区域的路由摘要信息发送到主干区域，而主干区域上的ABR则负责将这些信息发送到各个区域。 \\4. 自治域系统边界路由器(ASBR)：至少拥有一个连接外部自治域网络（如非OSPF的网络）端口的路由器，负责将非OSPF网络信息传入OSPF网络。 OSPF路由器之间交换链路状态公告(LSA)信息。OSPF的LSA中包含连接的接口、使用的Metric及其他变量信息。OSPF路由器收集链接状态信息并使用SPF算法来计算到各节点的最短路径。 协议类型 Hello报文，通过周期性地发送来发现和维护邻接关系； ​ 存在router ID—-RID 全网唯一的编号，使用ip地址 DBD(链路状态数据库描述)报文，描述本地路由器保存的LSDB(链路状态数据库)； LSR(LS Request)报文，向邻居请求本地没有的LSA； LSU(LS Update)报文，向邻居发送其请求或更新的LSA； LSAck(LS ACK)报文，收到邻居发送的LSA后发送的确认报文。 OSPF网络类型 根据路由器所连接的物理网络不同，OSPF将网络划分为四种类型：广播多路访问型（Broadcast multiAccess）、非广播多路访问型（None Broadcast MultiAccess，NBMA）、点到点型（Point-to-Point）、点到多点型（Point-to-MultiPoint）。 指派路由器（DR）和备份指派路由器（BDR） 在多路访问网络上可能存在多个路由器，为了避免路由器之间建立完全相邻关系而引起的大量开销，OSPF要求在区域中选举一个DR。每个路由器都与之建立完全相邻关系。DR负责收集所有的链路状态信息，并发布给其他路由器。选举DR的同时也选举出一个BDR，在DR失效的时候，BDR担负起DR的职责。 点对点型网络不需要DR，因为只存在两个节点，彼此间完全相邻。 协议组成OSPF协议由Hello协议、交换协议、扩散协议组成。 当路由器开启一个端口的OSPF路由时，将会从这个端口发出一个Hello报文，以后它也将以一定的间隔周期性地发送Hello报文。OSPF路由器用Hello报文来初始化新的相邻关系以及确认相邻的路由器邻居之间的通信状态。 对广播型网络和非广播型多路访问网络，路由器使用Hello协议选举出一个DR。在广播型网络里，Hello报文使用多播地址224.0.0.5周期性广播，并通过这个过程自动发现路由器邻居。在MA网络中，DR负责向其他路由器逐一发送Hello报文。 三、工作原理一般用于同一个路由域内。在这里，路由域是指一个自治系统（Autonomous System），即AS，它是指一组通过统一的路由政策或路由协议互相交换路由信息的网络。在这个AS中，所有的OSPF路由器都维护一个相同的描述这个AS结构的数据库，该数据库中存放的是路由域中相应链路的状态信息，OSPF路由器正是通过这个数据库计算出其OSPF路由表的。 四、工作工程1、数据包5种基本数据包 HELLO—邻居的发现、建立、保活 DBD—–数据库描述包—数据库目录信息 LSR—–链路状态请求 LSU—–链路状态更新—携带各种LSA LSACK—链路状态确认 2、OSPF的状态机–描述接口状态Down：本地一旦发出hello包，进入下一状态 Init–初始化：本地接收到的hello包中若存在本地的RID，进入下一状态 2way–双向通信：邻居关系建立的标志 条件匹配：点到点网络直接进入下一个状态；MA网络将进行DR/BDR选举（40s），非DR/BDR间不能进入下一个状态； Exstart–预启动：使用类hello的BDB包进行主从关系选举，RID数值大为主，主从优先进入下一个状态。 Exchange–准交换：使用真正的BDB进行数据库目录的共享，需要ACK； LOding–加载：使用LSR/LSU/LSack来获取未知的LSA信息； Full–转发：邻接关系建立的标志； 3、工作过程1、启动配置完成后，本地收发hello包，建立邻居关系，生成邻居表； 2、再进行条件的匹配，匹配失败将停留于邻居关系，仅hello包保活即可； 3、匹配成功者之间建立邻接关系，需要DBD共享数据库目录，LSR/LSU/LSack来获取未知的LSA信息，当收集完网络中所有的LSA后，生成数据表–LSDB 4、LSDB建立完成后，本地基于OSPF选路规则，计算本地到达所有未知网段的最短路径，然后将其加载到路由表中，完成收敛。 5、收敛完成后–hello包周期保活–30分钟周期的BDB比对，若不一致将会使用LSR/LSU/LSack重新获取 4、配置配置 R1(config)#router ospf 100 创建/进入OSPF进程100 R1(config-router)#router-id 1.1.1.1 指定Router-id，不指定则为环回地址，没有环回则为物理接 口地址 R1(config-router)#network 12.1.1.1 0.0.0.0 area 0 可在接口内配置，IP ospd 100 area 0 ​ 1、路由 2、激活 3、区域 OSPF三种表 邻居表 R2#show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 1.1.1.1 1 FULL/DR 00:00:39 12.1.1.1 FastEthernet1/0 拓扑表 R2#show ip ospf database ​ OSPF Router with ID (2.2.2.2) (Process ID 100) ​ Router Link States (Area 0) Link ID ADV Router Age Seq# Checksum Link count 1.1.1.1 1.1.1.1 90 0x80000005 0x00BF34 2 2.2.2.2 2.2.2.2 458 0x80000003 0x00BA04 3 ​ Net Link States (Area 0) Link ID ADV Router Age Seq# Checksum 12.1.1.1 1.1.1.1 470 0x80000001 0x004AD0 路由表 R2#show ip ospf route ​ OSPF Router with ID (2.2.2.2) (Process ID 100) ​ Area BACKBONE(0) ​ Intra-area Route List * 12.1.1.0/24, Intra, cost 1, area 0, Connected ​ via 12.1.1.2, FastEthernet1/0 * 23.1.1.0/24, Intra, cost 1, area 0, Connected ​ via 23.1.1.2, FastEthernet1/1 *&gt; 1.1.1.1/32, Intra, cost 2, area 0 ​ via 12.1.1.1, FastEthernet1/0 * 2.2.2.2/32, Intra, cost 1, area 0, Connected ​ via 2.2.2.2, Loopback0 R2#show ip route ospf ​ 1.0.0.0/32 is subnetted, 1 subnets O 1.1.1.1 [110/2] via 12.1.1.1, 00:01:50, FastEthernet1/0 区域划分的规则： 星型结构 其他区域要和骨干域相连 需要存在ABR 区域边界路由器 ​ 通告者 内容 1类LSA router 路由器本身 链路状态 2类LSA network DR 描述MA网络 3类LSA sumary ABR 路由条目 成为邻接关系的条件 1、如果在串行链路上 直接形成邻接关系 2、如果是以太网环境 只和DR/BDR形成邻接关系 选举规则 先比较优先级 越大越优先 比较Router-ID 越大越优先 非抢占性 修改优先级 R1(config)#int f0/0 R1(config-if)#ip ospf priority 2 干涉选择方法： 修改DR优先级最大，BDR次大；该选举非抢占，故必须手动重启所有设备进程 R2#clear ip ospf process Reset ALL OSPF processes? [no]: y 修改DR优先级最大，BDR次大；将其他路由器修改为0 扩展配置： 认证 明文认证： R2(config)#int s1/0 R2(config-if)#ip ospf authentication R2(config-if)#ip ospf authentication-key 1 cisco 密文认证： R2(config)#int f0/0 R2(config-if)#ip ospf authentication message-digest R2(config-if)#ip ospf message-digest-key 1 md5 cisco 区域明文认证： R3(config)#router ospf 100 R3(config-router)#area 0 authentication 区域密文认证： R1(config)#router ospf 100 R1(config-router)#area 1 authentication message-digest 被动接口 R1(config)#router ospf 100 R1(config-router)#passive-interface loopback 0 加快收敛速度 R1(config)#int s1/1 R1(config-if)#ip ospf hello-interval 5 修改hello时间为5s dead time自动四倍关系 R1(config-if)#ip ospf dead-interval 20 链路两端必须一致 缺省路由 R1(config)#router ospf 100 R1(config-router)#default-information originate 需要有缺省路由指向ISP R1(config)#ip route 0.0.0.0 0.0.0.0 loopback 10 强制下放缺省 R1(config)#router ospf 100 R1(config-router)#default-information originate always","categories":[{"name":"CCNA","slug":"CCNA","permalink":"http://soliym.top/categories/CCNA/"}],"tags":[{"name":"OSPF","slug":"OSPF","permalink":"http://soliym.top/tags/OSPF/"}]},{"title":"RIP路由信息简述","slug":"RIP路由信息简述","date":"2019-09-02T09:05:26.249Z","updated":"2019-09-02T09:12:33.464Z","comments":true,"path":"2019/09/02/RIP路由信息简述/","link":"","permalink":"http://soliym.top/2019/09/02/RIP路由信息简述/","excerpt":"RIP：路由信息协议","text":"RIP：路由信息协议 1. 定义：路由信息协议（英语：Routing Information Protocol，缩写：RIP）是一种内部网关协议（IGP），为最早出现的距离向量路由协议。属于网络层，可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等。 RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议， RIP协议要求网络中每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。RIP协议将“距离”定义为：从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为每经过一个路由器则距离加1。“距离”也称为“跳数”。RIP允许一条路径最多只能包含15个路由器，因此，距离等于16时即为不可达。可见 RIP协议只适用于小型互联网，并不适用于复杂网络的情况。 2. 特点：（1）仅和相邻的路由器交换信息。如果两个路由器之间的通信不经过另外一个路由器，那么这两个路由器是相邻的。RIP协议规定，不相邻的路由器之间不交换信息。 （2）路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。 （3）按固定时间交换路由信息，如，每隔30秒，然后路由器根据收到的路由信息更新路由表。（也可进行相应配置使其触发更新） 3.版本：（1）版本​ RIPv1:使用有类路由，在它的路由更新(Routing Updates)中并不带有子网的资讯，因此它无法支援可变长度子网掩码。这个限制造成在RIPv1的网络中，在同级网络下无法使用不同的子网掩码。换句话说，在同一个网络下所有的子网络数目都是相同的。另外，它也不支援对路由过程时的认证，使得RIPv1有一些轻微的弱点，有机会遭受到可能的攻击。 ​ RIPv2：因为RIPv1的缺陷，RIPv2在1994年被提出，与RIP1最大的不同是RIP2为一个无类别路由协议，其更新消息中携带子网掩码，它支持VLSM、CIDR、认证和多播。另外针对安全性的问题，RIPv2也提供一套方法，未透过加密来达到认证的效果。而之后[RFC 2082]也定义了利用MD5来达到认证的方法。 ​ RIPng：主要是针对IPv6做一些延伸的规范。与RIPv2相比下其最主要的差异是：RIPv2支援RIP更新认证, RIPng 则不支持，因为IPv6路由器理应会使用IPsec来进行身份验证；RIPv2 容许给路由器附上任何标签， RIPng 则不容许； RIPv2 在每个路由表项中都保存下一跳的信息，RIPng是对一组路由表项指定下一跳信息；RIPv2 使用UDP端口520和多播地址224.0.0.9通信，RIPng 则使用UDP端口521和多播地址FF02::9通信。 （2）总结RIPv1和RIPv2的区别1.RIPv1是有类路由协议（不携带掩码），RIPv2是无类路由协议（携带掩码） 2.RIPv1不能支持VLSM，RIPv2可以支持VLSM 3.RIPv1没有认证的功能，RIPv2可以支持认证，并且有明文和MD5两种认证 4.RIPv1没有手工汇总的功能，RIPv2可以在关闭自动汇总的前提下，进行手工汇总 5.RIPv1是广播更新，RIPv2是组播更新， 6.RIPv1对路由没有标记的功能，RIPv2可以对路由打标记（tag），用于过滤和做策略 7.RIPv1发送的updata最多可以携带25条路由条目，RIPv2在有认证的情况下最多只能携带24条路由 8.RIPv1发送的updata包里面没有next-hop属性，RIPv2有next-hop属性，可以用与路由更新的重定 4. 工作原理：​ （1）初始化——RIP[1]初始化时，会从每个参与工作的接口上发送请求数据包。该请求数据包会向所有的RIP路由器请求一份完整的路由表。该请求通过LAN上的广播形式发送LAN或者在点到点链路发送到下一跳地址来完成。这是一个特殊的请求，向相邻设备请求完整的路由更新。 ​ （2）接收请求——RIP有两种类型的消息，响应和接收消息。请求数据包中的每个路由条目都会被处理，从而为路由建立度量以及路径。RIP采用跳数度量，值为1的意为着一个直连的网络，16，为网络不可达。路由器会把整个路由表作为接收消息的应答返回。 ​ （3）接收到响应——路由器接收并处理响应，它会通过对路由表项进行添加，删除或者修改作出更新。 ​ （4）常规路由更新和定时——路由器以30秒一次地将整个路由表以应答消息地形式发送到邻居路由器。路由器收到新路由或者现有路由地更新信息时，会设置一个180秒地超时时间。如果180秒没有任何更新信息，路由的跳数设为16。路由器以度量值16宣告该路由，直到刷新计时器从路由表中删除该路由。刷新计时器的时间设为240秒，或者比过期计时器时间多60秒。Cisco还用了第三个计时器，称为抑制计时器。接收到一个度量更高的路由之后的180秒时间就是抑制计时器的时间，在此期间，路由器不会用它接收到的新信息对路由表进行更新，这样能够为网路的收敛提供一段额外的时间。 ​ （5）触发路由更新——当某个路由度量发生改变时，路由器只发送与改变有关的路由，并不发送完整的路由表。 5. RIP防环机制5.1 记数最大值（maximum hop count）：定义最大跳数（最大为15跳），当跳数为16跳时,目标为不可达。 5.2 水平分割（split horizon）：从一个接口学习到的路由不会再广播回该接口。 5.3 毒性逆转水平分割（poison reverse）：从一个接口学习的路由会发送回该接口，但是已经被毒化，跳数设置为16跳，不可达。 5.4 触发更新（trigger update）：一旦检测到路由崩溃，立即广播路由刷新报文，而不等到下一刷新周期。 5.5 抑制计时器（holddown timer）：防止路由表频繁翻动，增加了网络的稳定性。 6. RIP路由更新机制RIP协议有两种更新机制：一是定期更新，二是触发更新。“定期更新”是根据设置的更新计时器定期发送RIP路由通告。该通告报文中携带了除“水平分割”机制抑制的RIP路由之外本地路由器中的所有RIP路由信息。而“触发更新”则是RIP路由器仅在有路由表项发生变化时发送的RIP路由通告，仅携带本地路由表中有变化的路由信息。RIP路由器一旦察觉到网络变化，就尽快甚至是立即发送更新报文，而不等待更新周期结束。只要触发更新的速度足够快，就可以大大地防止“计数到无穷大”的发生，但是这一现象还是有可能发生的。 无论是定期更新，还是触发更新，RIP路由的更新规则如下： l 如果更新的某路由表项在路由表中没有，则直接在路由表中添加该路由表项； l 如果路由表中已有相同目的网络的路由表项，且来源端口相同，那么无条件根据最新的路由信息更新其路由表； l 如果路由表中已有相同目的网络的路由表项，但来源端口不同，则要比较它们的度量值，将度量值较小的一个作为自己的路由表项； l 如果路由表中已有相同目的网络的路由表项，且度量值相等，保留原来的路由表项。 7、Rip基础配置1）RIPV1 r1(config)#router rip 启动协议 r1(config-router)#version 1 选择版本1，若不进行版本选举，默认为升级版本1； r1(config-router)#network 1.0.0.0 主类地址—-RIP在宣告时，只能定义主类的范围 clear ip route * 刷新路由表 2）RIPV2 r1(config)#router rip r1(config-router)#version 2选择版本2 r1(config-router)#no auto-summary 关闭自动汇总； r1(config-router)#network 12.0.0.0 8、RIP扩展配置1、RIPV2的认证​ 运行了RIP协议的邻居间，进行身份的核实 先定制key，再在同邻居直连的接口上调用 指令： r1(config)#key chain xxx r1(config-keychain)#key 1 r1(config-keychain-key)#key-string cisco123 邻居间必须一致 r1(config)#interface s1/1 r1(config-if)#ip rip authentication key-chain xxx r1(config-if)#ip rip authentication mode md5 模式也必须一致 2、RIPV2的手工汇总在更新源路由器上向所有更新发出的接口上配置 r2(config)#interface s1/0 r2(config-if)#ip summary-address rip 2.2.2.0 255.255.254.0 如果在接口中汇总多个路由，则选择掩码短的 3、被动接口仅接收不发送路由协议信息；只能用于连接用户的接口，不得用于连接邻居的接口 r1(config)#router rip r1(config-router)#passive-interface loopback 0 4、加快收敛RIP计时器 30s 更新 180s失效 180s抑制 240s刷新 ​ 适当的修改计时器，可以加快设备的收敛速度 ​ 建议修改时维持原有的倍数关系，且不易修改的过小；全网所有设备均修改 r1(config)#router rip r1(config-router)#timers basic 15 90 90 120 5、缺省路由在边界路由器上配置RIP缺省后，内部的路由器将自动生成缺省路由指向边界路由器；边界路由器到达ISP的缺省路由，宣告手工静态配置 r3(config)#router rip r3(config-router)#default-information originate","categories":[{"name":"CCNA","slug":"CCNA","permalink":"http://soliym.top/categories/CCNA/"}],"tags":[]},{"title":"DHCP工作原理","slug":"DHCP工作原理","date":"2019-09-02T04:12:03.755Z","updated":"2019-09-02T04:23:42.076Z","comments":true,"path":"2019/09/02/DHCP工作原理/","link":"","permalink":"http://soliym.top/2019/09/02/DHCP工作原理/","excerpt":"DHCP 全称Dynamic Host configuration protocol， 动态主机配置协议。 它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数，","text":"DHCP 全称Dynamic Host configuration protocol， 动态主机配置协议。 它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数， 一、DHCP共有八种报文，不同报文之间的区别除了DHCP数据包本身之外，在封包上(UDP头，IP头、链路层头)也有一些差别​ 1）DHCP DiscoverDHCP客户端请求地址时，并不知道DHCP服务器的位置，因此DHCP客户端会在本地网络内以广播方式发送请求报文，这个报文成为Discover报文，目的是发现网络中的DHCP服务器，所有收到Discover报文的DHCP服务器都会发送回应报文，DHCP客户端据此可以知道网络中存在的DHCP服务器的位置。 2）DHCP OfferDHCP服务器收到Discover报文后，就会在所配置的地址池中查找一个合适的IP地址，加上相应的租约期限和其他配置信息(如网关、DNS服务器等)，构造一个Offer报文，发送给用户(可以广播、也可以单播)，告知用户本服务器可以为其提供IP地址。(注意，只是告诉client可以提供，是预分配，还需要client通过ARP检测该IP是否重复) 3）DHCP Request客户端会在两种情况下发送DHCP Request a）DHCP客户端可能会收到来自DHCP服务器的很多Offer，所以必须在这些回应中选择一个。Client通常选择第一个回应Offer报文的服务器作为自己的目标服务器，并回应一个广播Request报文，通告选择的服务器。注意，”Client通常选择第一个回应Offer报文的服务器作为自己的目标服务器”这里存在一个安全问题，如果我们的伪DHCP服务器能比原始DHCP服务器先发送Offer数据包，就能达到欺骗的目的，从而劫持目标用户的流量 b）获取DHCP客户端成功获取IP地址后，在地址使用租期过去1/2时，会向DHCP服务器发送单播Request报文续延租期，如果没有收到DHCP ACK报文，在租期过去3/4时，会再次发送广播Request报文续延租期。 4）DHCP ACKDHCP服务器收到Request报文后，根据Request报文中携带的用户MAC来查找有没有相应的租约记录(即之前的预分配过程中登记的那个MAC)，如果有则发送ACK报文作为回应，通知用户可以使用分配的IP地址。 5） DHCP NAK如果DHCP服务器收到Request报文后，没有发现有相应的租约记录或者由于某些原因无法正常分配IP地址，则发送NAK报文作为回应，通知用户无法分配合适的IP地址。 6）DHCP Release当用户不再需要使用分配IP地址时，就会”主动”向DHCP服务器发送Release报文，告知服务器用户不再需要分配IP地址，DHCP服务器会释放被绑定的租约(在数据库中清除某个MAC对某个IP的租约记录，这样，这个IP就可以分配给下一个请求租约的MAC) \\7. DHCP DeclineDHCP客户端收到DHCP服务器回应的ACK报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送Decline报文，通知服务器所分配的IP地址不可用，我们在手工设置静态IP、或者DHCP分配中有时会遇到”检测到IP冲突”的提示就是因为客户端利用ARP机制来在当前内网中确认当前指定的IP是否已经被占用 8）DHCP InformDHCP客户端如果需要从DHCP服务器端获取更为详细的配置信息，则发送Inform报文向服务器进行请求，服务器收到该报文后，将根据租约进行查找，找到相应的配置信息后，发送ACK报文回应DHCP客户端。 二、DHCP协议的本质DHCP使用UDP进行报文的传输。在主机DHCP获得地址之前，主机并没有有效的IP地址，它是通过受限广播IP地址（全1），当该地址作为目的地址时，子网内的所有主机都能收到该IP数据报。IP层的广播实际上是基于链路层的广播来实现的，所以这里有个前提，即链路层具有广播功能，在以太网中，目的地址为全1的MAC地址可作为链路上的广播地址。只要数据包能够正确到达主机IP层UDP的端口上，则应用程序就能收到该端口上的广播IP包，这正是DHCP设备能正确获得IP地址的本质。 DHCP客户端使用固定端口号68，而服务器使用固定端口号67。 DHCP由三种机制分配IP地址： 1.自动分配方式：DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器租用到IP地址，就可以永久使用该地址。 2.动态分配方式：DHCP服务器给主机指定一个有时间限制的IP地址， 时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。 3.手工分配方式：客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。 三种地址分配方式中， 只有动态分配方式可以重复使用客户端不再需要的地址 三、DHCP工作流程 1、客户端以广播的方式发送DHCP_DISCOVER报文，广播的范围的服务器都能接收到该报文。 2、所有的DHCP服务器都会对该报文进行响应，向DHCP客户端发送DHCP_OFFER报文，报文中的 Your（Client）IP Address字段携带了分配给客户端的IP地址，同时服务器的IP地址放在报文中的option字段中以便客户端可以区分，服务器分配后IP地址给客户端后，会把该地址分配记录下来。 3、DHCP客户端可能收到多个服务器的DHCP_OFFER报文，但是它只能对其中的一个做响应，通常DHCP客户端处理最先收到的DHCP_OFFER报文并响应。 4、DHCP客户端从DHCP_OFFER报文中提取可使用的IP地址和服务器IP地址后，会发出个广播的DHCP_REQUST报文，并在选项字段中加入选中的DHCP服务器的IP地址和自己要的IP地址。 5、DHCP服务器收到DHCP_REQUST报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP服务器不做任何处理，然后清除相应IP地址分配记录；如果相同，DHCP服务器就会向客户端发送一个DHCP_ACK报文，并在报文选项字段中增加IP地址的使用租期信息。 6、DHCP客户端接收到DHCP_ACK报文后，会检查服务器分配的IP地址是否能够使用（发送一个ARP请求到网络中，如果无主机回应该请求，则表示该地址可用）。如果可以使用，则客户端成功获得IP地址会根据IP地址使用租期自动启动续延过程；如果DHCP客户端发现分配的IP地址已经被使用，则需要向DHCP服务器发出一个DHCP_DECLINE报文，通知DHCP服务器禁用这个IP地址，此后，DHCP客户端重新开始上述地址申请流程。 7、客户端在使用租期超过50%或87.5%时，会以广播播形式向DHCP服务器发送DHCP_REQUST报文来续租IP地址。如果DHCP客户端成功收到服务器返回的DHCP_ACK报文，则按相应时间延长IP地址租期；如果没有收到服务器返回的的DHCP_ACK报文，则DHCP 客户端继续使用这个IP地址，直到IP地址使用租期到期。当租期到期后，DHCP客户端会向DHCP服务器发送一个DHCP_RELEASE报文来释放这个IP地址，并开始新的IP地址申请过程。 8、最后需要指出的是，DHCP服务器发送的DHCP_OFFER报文中的IP地址不一定是最后分配给客户端的IP地址，通常情况下，DHCP服务器会保留该地址直到客户端发出DHCP_REQUEST请求。在整个协商过程中，如果DHCP客户端发送的DHCP_REQUEST报文中的地址信息不正确，如客户端已经迁移到新的子网或者租约已经过期，DHCP服务器会发送DHCP_NAK报文给DHCP客户端，让客户端重新发起地址申请过程。 四、配置DHCP配置： R1(config)#ip dhcp pool ccna(dhcp服务器名称） R1(dhcp-config)#network 172.16.1.0 255.255.255.0 R1(dhcp-config)#default-router 172.16.1.1 R1(dhcp-config)#dns-server 8.8.8.8 排除地址： 排除单个地址 R1(config)#ip dhcp excluded-address 172.16.1.254 排除一段地址 R1(config)#ip dhcp excluded-address 172.16.1.100 172.16.1.200 ​ 起始地址 结束地址","categories":[{"name":"CCNA","slug":"CCNA","permalink":"http://soliym.top/categories/CCNA/"}],"tags":[{"name":"DHCP","slug":"DHCP","permalink":"http://soliym.top/tags/DHCP/"}]},{"title":"RHCSA-Linux基础命令（一）","slug":"RHCSA-Linux基础命令（一）","date":"2019-06-17T11:21:08.791Z","updated":"2019-09-02T04:17:01.720Z","comments":true,"path":"2019/06/17/RHCSA-Linux基础命令（一）/","link":"","permalink":"http://soliym.top/2019/06/17/RHCSA-Linux基础命令（一）/","excerpt":">Linux的基本原则1、由目的单一的小程序组成 2、一切皆文件，设备的访问入口也是文件 3、避免捕获用户接口，尽量不和用户交互 4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。","text":">Linux的基本原则1、由目的单一的小程序组成 2、一切皆文件，设备的访问入口也是文件 3、避免捕获用户接口，尽量不和用户交互 4、配置文件保存在纯文本格式，只要有一个文本编辑器，足以搞定所有的配置。 命令格式>命令 >命令 参数 >命令 -选项 >命令 -选项 参数 修改命令的执行特性短选项 -l 多个选项可以组合 长格式 –long ​ 参数 指定命令的作用对象 基础命令重启：reboot 关机：shutdown -h now，poweroff ip a / ifconfig 查看ip地址 dhclient 地址请求，打开网络模式 kill -9 ID 结束相应的进程（命令 -选项 参数） pwd 指出当前工作环境 print workdoing directory su 切换到root用户并不切换环境（工作目录） switch user su - root 切换到root用户并切换环境(切换了工作目录) cd 切换目录 change directroy ​ 绝对路径 从根开始到目标的路径叫绝对路径 ​ 相对路径 相对当前目录开始到目标路径 ​ / 根 ​ ~ 家目录 /root /home/redhat ​ ~ USERNAME(root用户有权限) 直接切换到指定用户的家目录 ​ - 在上一个目录和当前目录来回切换 ​ . 当前目录 ​ .. 上一级目录 passwd 修改密码：passwd 用户名 直接输入passwd修改当前用户的密码 删除密码：passwd -d 用户名 root用户：不需要输入原密码，可以不符合密码复杂性规则，可以给任何人修改密码 普通用户：需要输入原密码，必须符合密码复杂性规则，passwd修改密码无法指定用户 [student@localhost ~]$ su -c passwd普通用户给root用户修改密码","categories":[{"name":"RHCSA","slug":"RHCSA","permalink":"http://soliym.top/categories/RHCSA/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://soliym.top/tags/Linux命令/"}]},{"title":"RHCSA-Linux简介","slug":"RHCSA-Linux简介","date":"2019-06-17T11:17:36.958Z","updated":"2019-09-02T04:16:45.576Z","comments":true,"path":"2019/06/17/RHCSA-Linux简介/","link":"","permalink":"http://soliym.top/2019/06/17/RHCSA-Linux简介/","excerpt":"操作系统是什么？操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。 操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。","text":"操作系统是什么？操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是配置在计算机硬件上的第一层软件，任何其它软件都必须在操作系统的支持下才能运行。 操作系统的主要功能是为管理硬件资源和为应用程序开发人员提供良好的环境来使应用程序具有更好的兼容性，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口（应用编程接口API，由操作系统实现提供的所有系统调用所构成的集合，是应用程序和系统之间的接口）呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理的结果返回给应用程序。 >&gt;硬件：框架 冯诺依曼体系结构：1946年美籍凶牙利科学家冯诺依曼提出存储程序原理，把程序本身当做数据来对待，程序和该程序处理数据用同样的方式存储，并确定了存储程序计算机的五大组成部分和基本工作方法。 特点： （1）计算机处理数据和指令一律用二进制数表示 （2）顺序执行程序 计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动地并按顺序 从主存储器中取出指令一条一条的执行，这一概念称为顺序执行程序。 （3）计算机硬件由运算器、控制器、存储器、输入设备、输出设备五大部分组成。 memory：编址存储设备 假设我们的存储器为一个长条，其中每八位（bit）作为一个单元，我们把它称为字节byte，字节又称为cell。 机器语言：二进制指令 （但是对于编程 人员来说二进制语言太难懂（太简陋，太底层），但是程序员想用简单点的语言去描述计算机又不懂所以两者之间不能耦合可以加一个中间层–编译器） 汇编语言： 仅是将二进制转为人类语言想接近的语言或者是与人类语言符号相同的类型（+ and/plus） 所以任何一款芯片制造商他们都把机器的代码也就是机器语言提供一个较为简单的稍微向上一点的但任然很简陋的编程接口叫做汇编语言（微码编程语言） 软件：​ —-汇编语言： （低级语言） ​ 应用：驱动程序 汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的,不同平台之间不可直接移植。 ​ eg：操作：寄存器BX的内容送到AX中 ​ 1000100111011000 机器指令 ​ mov ax,bx 汇编指令 （注意：最终识别的还是01二进制数所以还需要将汇编语言转换为二进语言所以需要用到汇编器） ​ —-(高级语言)：比较接近人类的思维逻辑 —-(编译器) ​ 系统级： c c++ ​ 适用场合大型的对性能要求比较高的服务类程序 如：oracle mysql linux windows / ​ 应用级：java python ruby 系统调用的层级关系(系统组成结构) 操作系统内核的功能：系统调用接口 程序管理 内存管理，虚拟内存—内存交换 文件系统管理 设备驱动","categories":[{"name":"RHCSA","slug":"RHCSA","permalink":"http://soliym.top/categories/RHCSA/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://soliym.top/tags/Linux/"}]},{"title":"常见排序算法（1）","slug":"常见排序算法（1）","date":"2019-05-16T15:40:24.468Z","updated":"2019-09-02T04:16:25.207Z","comments":true,"path":"2019/05/16/常见排序算法（1）/","link":"","permalink":"http://soliym.top/2019/05/16/常见排序算法（1）/","excerpt":"排序算法是算法中最重要、最基础的算法，也是编程中用到最多的算法。不论是竞赛还是面试时，排序算法都是最常见的考点，下面根据排序思想不同，给出常见的几种排序算法。","text":"排序算法是算法中最重要、最基础的算法，也是编程中用到最多的算法。不论是竞赛还是面试时，排序算法都是最常见的考点，下面根据排序思想不同，给出常见的几种排序算法。 插入类排序基本思想：在一个已排好序的基础上，每一步将下个待排序的记录有序插入到已排好的记录子集中，直到所有的待排序记录全部插入到序列中。 直接插入排序算法思想：将第i个数据插到前面i-1个以排好的数据中。 例如：48 62 35 77 55 14 35* 98 a ｛48｝ 62 35 77 55 14 35* 98 b ｛48 62｝ 35 77 55 14 35* 98 c ｛35 48 62｝77 55 14 35* 98 。。。。。。。。。。。。。。。 算法过程：保留第i个数据，将第i个数据依次和前面i-1个数据比较，如果大于其中某一个数据，则停止，将第I个数据插入到此数据后一位，在每次比较中，较大的数据向后移动一位（排序为从小到大）。 12345678910111213void InsSort(int r[],int length)&#123; for(int i=2;i&lt;=length;i++) &#123; r[0]=r[j];//采用首地址保存第i个元素,并且防止数组越界 int j=i-1; while(r[0]&lt;r[j])&#123; r[j+1]=r[j]; j--; &#125; r[j+1]=r[0]; &#125;&#125; 直接插入排序的时间复杂度为T(n)=O(n^2),空间复杂度，空间复杂度为S（n）=O(1); 直接插入排序是稳定的排序方法。当有两个相同元素时，他们的相对位置不发生改变。 折半插入排序算法思想：在直接插入的思想中加入折半查找的思想，提高查找效率。 基本的排序方法不变，只是在查找的过程中做出改变，前面的查找为顺序查找，从第i-1个元素按顺序查找到第1个元素。 1234567891011121314151617void BinSort（int r[],int length）&#123; for(int i=2;i&lt;=length;i++) &#123; int r[0]=r[i]; int low=1,high=i-1; while(low&lt;=high) &#123; int mid=(low+high)/2; if(r[0]&lt;r[mid]) high=mid-1; else low=mid+1; &#125; for(int j=i-1;j&gt;=low;j--) r[j+1]=r[j]; r[low]=r[0]; &#125;&#125; 折半插入排序是由直接插入排序改良而来，在原有的基础上加入折半查找，折半查找是一种非常重要的计算机思维，在很多地方都有应用。 虽然折半插入是由直接插入改进而来，但是时间复杂度并没用改变多少，仍然为0（n^2）; 希尔排序在插入排序中，希尔排序是最佳的排序算法，也是比较难理解的算法。 例： 初始 46 55 13 42 94 17 05 70 d=4 46 17 05 42 94 55 13 70 d=2 05 17 13 42 46 55 94 70 d=1 05 13 17 42 46 55 70 94 123456789101112131415161718void shellInSort(int r[],int length,int delta)&#123; for(int i=1+delta;i&lt;=length,i++)//delta为增量d &#123; if(r[i]&lt;r[i-delta])//子序列最后一个元素和第一个元素比较 ｛ r[0]=r[i]; for(int j=i-delta;j&gt;0&amp;&amp;r[0]&lt;r[j];j-=delta) r[j+delta]=r[j]; r[j+delta]=r[0]; ｝ &#125;&#125;void shellSort(int r[],int length,int delta[],int n)&#123; for(int i=0;i&lt;=n-1;i++) shellInSort(r,length,delta[i]);&#125; 关于增量d的选取： shell ： d=n/2;d=d/2……..d=1; knuth: d=d/3+1; 时间复杂度：O（n^1.5）; 注意：希尔排序是一种不稳定的排序； 总结 排序算法 时间复杂度 空间复杂度 稳定性 直接插入 O(n^2) O(1) 稳定 折半插入 O(n^2) O(1) 稳定 希尔排序 O(n^1.5) O(1) 不稳定","categories":[{"name":"算法","slug":"算法","permalink":"http://soliym.top/categories/算法/"}],"tags":[{"name":"插入排序","slug":"插入排序","permalink":"http://soliym.top/tags/插入排序/"}]},{"title":"c关于堆栈的划定","slug":"c关于堆栈的划定","date":"2019-05-14T13:41:59.467Z","updated":"2019-05-14T13:51:36.365Z","comments":true,"path":"2019/05/14/c关于堆栈的划定/","link":"","permalink":"http://soliym.top/2019/05/14/c关于堆栈的划定/","excerpt":"c语言 全局变量与局部变量的划分在做背包问题的时候遇到这样的问题，定义一个二维数组变量，该变量的大小为1000*1000，但是在运行时报错，显示“Stack overflow ”，说明在此处超过了栈的空间。","text":"c语言 全局变量与局部变量的划分在做背包问题的时候遇到这样的问题，定义一个二维数组变量，该变量的大小为1000*1000，但是在运行时报错，显示“Stack overflow ”，说明在此处超过了栈的空间。 c/c++内存分配栈区(stack sagment)由编译器自动分配释放，存放函数的参数的值，局部变量的值等。在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M(也有的是1M，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆区(heap sagment) 一般由程序员分配释放，若程序员不释放，程序结束时可能由系统回收 。它与数据结构中的堆是两回事。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 全局区(静态区)(data sagment)全局变量和静态变量的存储区域是在一起的，程序结束后由系统释放。数据区的大小由系统限定，一般很大。 因为栈区的大小是编译器分配好的，如果变量的空间过大就会有栈的溢出问题，因此变量的类型是局部变量还是全局变量要根据变量大小选择，一版来说只有用到数组要考虑溢出问题，比如long、double都是固定长度大小的。如果数组的大小大于1000*1000就要考虑溢出问题，而全局变量的大小是有系统规定的，一般都很大。全局变量大小可达G以上。","categories":[{"name":"c语言","slug":"c语言","permalink":"http://soliym.top/categories/c语言/"}],"tags":[{"name":"堆栈","slug":"堆栈","permalink":"http://soliym.top/tags/堆栈/"}]},{"title":"open vswitch","slug":"open-vswitch","date":"2019-04-19T04:56:10.561Z","updated":"2019-04-19T04:59:30.687Z","comments":true,"path":"2019/04/19/open-vswitch/","link":"","permalink":"http://soliym.top/2019/04/19/open-vswitch/","excerpt":"open vswitch实验在Terminal下对ovs交换机进行测试； 对ovs交换机和端口的创建；对端口号的修改，配置完ovs以后查看交换机的状态，以及两个端口号的测试。","text":"open vswitch实验在Terminal下对ovs交换机进行测试； 对ovs交换机和端口的创建；对端口号的修改，配置完ovs以后查看交换机的状态，以及两个端口号的测试。 ovs各模块 ovs-vswitched 主要模块 ovsdb-server 轻量级数据库服务器 ovs-dpctl 配置switch内核 ovs-vsctl c查询和更新交换机配置 ovs-appctl f发送命令消息 ovs常用操作 操作 命令 添加网桥 ovs-vsctl add-br 交换机名 删除网桥 ovs-vsctl del-br 交换机名 添加端口 ovs-vsctl add-port 交换机名 端口号 删除端口 ovs-vsctl del-port 交换机名 端口号 连接控制器 ovs-vsctl set-controller 交换机名 tcp:ip 地址：端口号 断开控制器 ovs-vsctl del-controller 交换机名 列出所有网桥（交换机） ovs-vsctl list-br 列出网桥中的所有端口 ovs-vsctl list-port 交换机名 列出所有连接到网卡的网桥 ovs-vsctl port-to-br 端口号 查看ovs网络状态 ovs-vsctl show 查看ovs端口信息 ovs-vsctl show 交换机名 修改端口号 ovs-vsctl set Interface 端口名 ofport_request=新端口号 以上为ovs经常用到的操作，也是最基础的操作。下面开始ovs的测试实验。 open vswitchovs交换机创建创建一个名为ovs-switch的交换机 1sudo ovs-vsctl add-br ovs-switch 端口的配置配置一个端口号，名为p0,并设置网络接口为;intrenal 1sudo ovs-vsctl set Interface p0 type=internal 设置端口号，如果不自己设置，端口号由系统随机设置 1sudo ovs-vsctl set Interface 端口名 ofport_request=新端口号 虚拟网络空间配置避免与本地网络地址发生冲突，需要创建一个虚拟网络空间，将接口放入当中 1234sudo ip netns add ns0sudo ip link set p0 netns ns0sudo ip netns exec ip addr add 192.168.1.100/24dev p0sudoip netns ecev ns0 ifconfig p0 promisc up 创建一个名为ns0的虚拟网络空间，并将端口p0放入其中，给端口p0配置ip 192.168..1.100 查看ovs交换机查看ovs交换机的各个接口属性 1sudo ovs-vsctl show 测试端口两个端口之间相互测试，需要创建两个端口 1sudo ip netns exec ns0 ping 192.168.1.101 192.168.1.101为第二个端口的ip","categories":[{"name":"SDN","slug":"SDN","permalink":"http://soliym.top/categories/SDN/"}],"tags":[{"name":"vswitch","slug":"vswitch","permalink":"http://soliym.top/tags/vswitch/"}]},{"title":"2n皇后","slug":"2n皇后","date":"2019-04-11T12:37:08.115Z","updated":"2019-04-11T12:39:37.505Z","comments":true,"path":"2019/04/11/2n皇后/","link":"","permalink":"http://soliym.top/2019/04/11/2n皇后/","excerpt":"问题描述问题描述给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。","text":"问题描述问题描述给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 输入格式 输入的第一行为一个整数n，表示棋盘的大小。 接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 输出格式 输出一个整数，表示总共有多少种放法。 样例输入41 1 1 11 1 1 11 1 1 11 1 1 1 样例输出 2 样例输入 41 0 1 11 1 1 11 1 1 11 1 1 1 样例输出 0 问题分析2n皇后问题是在n皇后的问题上扩展而来，涉及搜索、模拟、n皇后问题，要解决2n皇后问题先要解决n皇后问题，n皇后在前面已经写了，现在来解决2n皇后的问题。 2n皇后实际是在在棋盘上先放一种皇后，然后再放另一种皇后，已经放过皇后的位置就不能再放皇后，所以首先记录白皇后的位置，然后再放黑皇后，需要一个二维数组来模拟棋盘，初始时，这个棋盘上是0或1，0表示不可以放皇后，1表示可以放皇后的，在开始放白皇后的时候，如果白皇后可以在棋盘上放置，那么记录该位置，将该位置标记为2，代表放置的是白皇后，当所有的白皇后放置完以后，计数器现在为n代表白皇后放置完，然后放置黑皇后，放置黑皇后时，如果放置位置是2那么，则代表位置是白皇后，那么该位置不能再放置黑皇后。按照放置白皇后的方法放置黑皇后。放置方法仍然采用回溯法。 算法设计放置位置检查是否合适一种皇后算法1234567891011bool check(int x,int y)//皇后的放置位置是否合适&#123;//x为行，y为列 int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) //判断是否在同一列或同斜行 return false; &#125; return true;&#125; 两种皇后算法12345678910bool check(int x, int y,int s)//x为行，y为列&#123; int i; for (i = 0; i &lt; x; i++) &#123; if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i]))) return false; &#125; return true;&#125; 在放置一种的基础上添加标志，当s==2时表示放置白皇后，所用到的是a数组，当s==3时，表示放置黑皇后，所用到的是c数组。a数组用来记录白皇后在各行的位置。c数组表示黑皇后在各行的位置。 回溯算法一种皇后回溯1234567891011121314151617void king(int k)&#123; int i; if(k==n)//如果n皇后符合位置，合法方案加一 &#123; count++;//合法方案计数 return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/ &#123; a[k]=i; king(k+1); &#125; &#125;&#125; 两种皇后回溯123456789101112131415161718192021void king(int k,int s)&#123; int i; if (k == n) &#123; if (s==2)king(0, 3);//s==3时放置黑皇后 else count++;//如果白皇后和黑皇后都等于n则计数器加一 return; &#125; for (i = 0; i &lt; n; i++) &#123; if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s))//与放置一种相比，增加两种条件，所放位置上不能等0或不能等2 &#123; s==2?a[k] = i:c[k] = i; b[k][i] = s;//记录白皇后、黑皇后的位置 king(k + 1,s);//第一行放置完，开始第二行 b[k][i] = 1;//还原棋盘 &#125; &#125;&#125; 源代码编译器vs2017 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n ;int count = 0;int a[10];int c[10];int b[10][10];bool check(int x, int y,int s)&#123; int i; for (i = 0; i &lt; x; i++) &#123; if (y == (s==2?a[i]:c[i]) || abs(x - i) == abs(y - (s == 2 ? a[i] : c[i]))) return false; &#125; return true;&#125;void king(int k,int s)&#123; int i; if (k == n) &#123; if (s==2)king(0, 3); else count++; return; &#125; for (i = 0; i &lt; n; i++) &#123; if (b[k][i] != 2 &amp;&amp; b[k][i] != 0 &amp;&amp; check(k, i,s)) &#123; s==2?a[k] = i:c[k] = i; b[k][i] = s; king(k + 1,s); b[k][i] = 1; &#125; &#125;&#125;int main(void)&#123; int i, j; scanf_s(\"%d\",&amp;n); for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) scanf_s(\"%d\", &amp;b[i][j]); king(0,2); printf(\"%d\", count); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://soliym.top/categories/算法/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://soliym.top/tags/递归/"}]},{"title":"n皇后","slug":"n皇后","date":"2019-04-06T10:10:57.536Z","updated":"2019-04-06T14:34:57.514Z","comments":true,"path":"2019/04/06/n皇后/","link":"","permalink":"http://soliym.top/2019/04/06/n皇后/","excerpt":"问题描述​ n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。","text":"问题描述​ n皇后问题是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两均不在同一行、同一列、同一条线上，求合法的方案数。 问题分析​ 如果采用枚举法判断每一种情况，需要枚举n^2的组合数，如果n=8;南无需要枚举54502232次，如果n再增大，需要枚举的次数就太过庞大。所以采用回溯法，尽量减少不必要的循环，当问题达到边界时，返回上一层，不必再浪费资源。如果只考虑每一行放置一个皇后、每一列也只放置一个皇后。从第一行开始放置皇后，当第一行的皇后确定后，结束循环，开始从下一行开始放置皇后，且放置皇后的位置不能与前面的皇后在同一列或同一条对角线。需要一个判断函数，判定在该位置能否放置皇后。如果一行的所有位置都不能放置皇后，那么回溯至上一行。 回溯法按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的。 算法设计皇后位置比较算法1234567891011bool check(int x,int y)//皇后的放置位置是否合适&#123;//x为行，y为列 int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) //判断是否在同一列或同斜行 return false; &#125; return true;&#125; 每一行放一个皇后，就解决了不在同行的问题。 在第i行的时候，遍历n列，试探位置。和之前所有行放的位置进行比较。 比较列：当前列col 不等于 之前 所有列。 即col != arr[i]。 比较斜线， 因为不再同一斜率为1或者-1的斜线。(row - i) / (col - arr[i]) != 1 或 -1 可以取巧用绝对值函数: abs(row-i) != abs(col-arr[i])。回溯算法 1234567891011121314151617void king(int k)&#123; int i; if(k==n)//如果n皇后符合位置，合法方案加一 &#123; count++;//合法方案计数 return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i))/*判断是否能放皇后，如果可以则记录皇后的所在的列，然后递归到下一行，如果不满足则回溯至上一行*/ &#123; a[k]=i; king(k+1); &#125; &#125;&#125; 回溯每行放置一个皇后，记录每个皇后所在的列数，如果递归后的结果不符合，则回退至该位置，从该位置继续遍历。回溯的条件有两种，一种是在一行中没有找到适合放置皇后的位置，另一种是符合放置方案，然后回溯，寻找下一个方案。 源代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int n=8;int count=0;int a[10];bool check(int x,int y)&#123; int i; for(i=0;i&lt;x;i++) &#123; if(y==a[i]||abs(x-i)==abs(y-a[i])) return false; &#125; return true;&#125;void king(int k)&#123; int i; if(k==n) &#123; count++; return; &#125; for(i=0;i&lt;n;i++) &#123; if(check(k,i)) &#123; a[k]=i; king(k+1); &#125; &#125;&#125;int main(void)&#123; king(0); printf(\"%d\",count); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://soliym.top/categories/算法/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://soliym.top/tags/递归/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2019-03-30T06:59:22.507Z","updated":"2019-03-30T07:03:58.902Z","comments":true,"path":"2019/03/30/贪心算法/","link":"","permalink":"http://soliym.top/2019/03/30/贪心算法/","excerpt":"贪心算法概述：贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。 注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。","text":"贪心算法概述：贪心算法（贪婪）又叫登山法，它的根本思想为：逐步求解最优解，将问题分解为每个小部分，使每个部分都达到最优解，从而使全局达到最优。贪心算法求解问题得到的解不一定是最优的解。例如Prim算法和Kruskal算法都是使用贪心算法的策略。 注意：有些问题用贪心算法可以达到最优解，但是不是所有问题都是局部最优从而全局最优，面对最优解问题时除了贪心算法以外还有动态规划。 完美的代价问题描述 回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。 交换的定义是：交换两个相邻的字符 例如mamad 第一次交换 ad : mamda 第二次交换 md : madma 第三次交换 ma : madam (回文！完美！) 输入格式 第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000) 第二行是一个字符串，长度为N.只包含小写字母 输出格式 如果可能，输出最少的交换次数。 否则输出Impossible 样例输入 5mamad 样例输出 3 问题分析​ 在输入的字符串中不匹配的字母可能是一个或零，所以可以先找出这个字母，创建一个包含26个空间是数组，分别表示字符串中字母的个数，然后遍历这个数组，如果字母的个数为奇数，则表示该字母为不匹配字母。首先从首字母开始，找到与它匹配的字符，再将它与最后一个字母交换，这样一对匹配的字母就交换完了，如果遇到不匹配的字母，则将它与中间的字母交换，然后在开始遍历。但是问题要求的是相邻的交换，所以这种方法不符合要求。 ​ 我们需要相邻交换，所以要找到交换的起点和终点。求解方法和上面类似，先从首字母开始，在从与字符串的另一方向开始，遍历找到与首字母匹配的字母，记录它的位置，从该位置起，将后一个字母向前一个位置移动，直到与最后，记录交换次数，再将首字母元素赋值给最后一个元素，这样一趟交换完成。 全局循环次数：1 to n/2; 每次循环需判断是否为不匹配元素 匹配元素循环次数：n-i-1 to j(当字母为匹配字母时) 匹配元素移动次数：j to n-i-1 不匹配元素循环次数：i to j(当字母为匹配字母时) 不匹配元素移动次数：j to i 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;int count=0;//交换次数 void hunwen(char x,int y,char *z)&#123; int i,j,k; for(i=0;i&lt;y/2;i++) &#123; if(z[i]!=x) &#123;//匹配字母情况 j=y-i-1; while(j!=i&amp;&amp;(z[j]!=z[i]))j--; for(k=j;k&lt;y-i-1;k++) &#123; z[k]=z[k+1]; count++; &#125; z[k]=z[i]; &#125; else &#123;//不匹配字母情况 j=i; while(j!=y-i-1&amp;&amp;(z[j]!=z[y-i-1])) j++; for(k=j;k&gt;i;k--) &#123; z[k]=z[k-1]; count++; &#125; z[k]=z[y-i-1]; &#125; &#125;&#125;int main(void)&#123; int n; int i,j=0; char w;//记录不匹配字符 int b[26]=&#123;0&#125;; char a[801]; scanf(\"%d\",&amp;n); getchar();//清除缓存 for(i=0;i&lt;n;i++) scanf(\"%c\",&amp;a[i]); for(i=0;i&lt;n;i++) b[a[i]-97]++; //对字母个数计数 for(i=0;i&lt;26;i++) &#123; if(b[i]%2!=0) &#123; w=i+97; j++; &#125;//遍历找到不匹配字母 &#125; if(j&gt;=2)printf(\"impossible\"); else &#123; hunwen(w,n,a);//交换函数 printf(\"%d\",count);&#125; return 0; &#125; 每一次循环都使字符串两边的字母匹配，达到局部最优的方案，贪心算法没有固定的算法模式，只有固定的算法思想：局部最优，从而全局最优。","categories":[{"name":"算法","slug":"算法","permalink":"http://soliym.top/categories/算法/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://soliym.top/tags/贪心/"}]},{"title":"建站分享","slug":"关于博客的搭建","date":"2018-11-26T14:40:01.936Z","updated":"2019-03-29T15:27:24.299Z","comments":true,"path":"2018/11/26/关于博客的搭建/","link":"","permalink":"http://soliym.top/2018/11/26/关于博客的搭建/","excerpt":"Github Pages + Hexo 我的博客是Github Pages + Hexo在github上搭建的。 下面是我对搭建博客过程中的一些分享","text":"Github Pages + Hexo 我的博客是Github Pages + Hexo在github上搭建的。 下面是我对搭建博客过程中的一些分享 一、 Git、node.js 先下载安装好Git、node.js，具体的过程参照了网上很多的帖子，很多都不是很详细，对于我这种小白来说就是一种折磨（完全看不懂，虽然学了一点前端的HTML、css、js，但这里完全用不上，到是在后面修改主题的时候到是能看明白了。。。。）这些博客里有一个挺详细的，按照他的过程，很容易就弄出来了（其实也不容易。。。。。出现好多问题，当时就很崩溃，明明按照他的步骤完成的，为啥就不通过呢，只能靠着百度一一解决了。。。 这个帖子有点小错误，可能是环境和版本不同的原因吧（我搭建的时候有些地方会出错，需要自己去改） 1http://jantc.cn/2017/04/16/%E5%BB%BA%E7%AB%99%E5%88%86%E4%BA%AB%E4%B9%8BGithub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(%E4%B8%80)/ 二、Github 在github上申请免费的空间来搭建网页，以前西部数码上购买过一个虚拟主机，很贵，一年要几百大洋，主要是国内的主要备案很麻烦，后来就放弃了。在github上可以搭建一个简单的静态网页，虽然是静态的，但是也可以加入很多功能，比如评论、分享系统。用来写写博客或作为个人的自我接受很好用。没有繁琐的管理，搭建好以后只管写博客就好。 注册GitHub的时候最好是在chrome浏览器中，因为可以翻译网页，像我这种还没过四级的渣渣，看见这些英文网站就头疼。。。。 具体的注册步骤就不说了，反正我也是看着别人的帖子弄的。。。这个很容易网上就能找到（我忘了我是在按照那个弄的了） 三、hexo配置完hexo本地就算配置完成了，接下来就是将hexo托管到github。 那个_config.yml有两个，一个是在hexo文件夹下的，另一个是在主题文件夹下的，一定要分清楚这两个，后面修改主题配置的时候会对这两个文件进行修改。 到这基础的就弄完了，可以说有个简单的博客就搭建完了，不过这时候页面有点丑（太low而且没啥功能），接下来就是对博客的美化-主题 123hexo g hexo s hexo d 四、主题我使用的是Material X作为博客的主题，想弄的话可以在我们博客的最下面点Material X连接，里面有关于这个主题的修改方法，在最下方有主题的源代码，下载后将文件放在主题文件夹中，上传就Ok了，具体的方法可以百度（有时间是话我会写篇文章来详细说一下我是怎样修改的和遇到的问题） 1https://xaoxuu.com/blog/ 1https://www.wushile.top/ 关于搭建博客 博客搭建花了大概四天多的时间才完成对博客的简单搭建，第一次弄博客，遇到了很多很多的问题，几乎都快要放弃了，但想想已经花费的很多的时间去做这个博客，就该把它弄完，从无到有，很庆幸坚持到了最后，从一无所知的小白到完成搭建这个博客，学到了很多知识，在网上查找解决问题的时候也见识到了很多。很久都没有这么专注的去做一件事情，每天就想着一件事，就想把这个博客建好，现在终于把基础搭建完了，不足的地方以后再去修改，千里之行始于足下。这是第一次写博客，很多格式都不动，写的很low，没办法，这会已经快一点，也没时间去学了，明天还有课。这两周可能不会对博客再进行大的修改了，还有两周考数据结构，没时间去美化了，等考完试再去博客进行修改吧","categories":[{"name":"随笔","slug":"随笔","permalink":"http://soliym.top/categories/随笔/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://soliym.top/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-25T08:55:32.795Z","updated":"2019-03-28T15:00:56.177Z","comments":true,"path":"2018/11/25/hello-world/","link":"","permalink":"http://soliym.top/2018/11/25/hello-world/","excerpt":"hello world","text":"hello world first personalblog1你好，世界！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://soliym.top/categories/随笔/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://soliym.top/tags/hexo/"}]}]}